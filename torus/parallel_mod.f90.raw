module parallel_mod

! subprograms used for parallel computation

!$MPI  !use MPI__INCLUDE
!$MPI  !use MPI
  implicit none

!$MPIcontains  

!$MPI  subroutine mpiBlockHandout(nProc,unitBelongsRank,&
!$MPI                             blockDivFactor,tag,&
!$MPI                             minBlockSize,maxBlockSize,setDebug)
!$MPI    ! this routine will divide a task into many small blocks, and
!$MPI    !   hand them out to processes that request work.
!$MPI  
!$MPI    use input_variables, only: blockhandout
!$MPI    implicit none
!$MPI    include 'mpif.h'  
!$MPI  
!$MPI    integer, intent(in) :: nProc    ! the number of processes
!$MPI    integer, intent(in) :: blockDivFactor ! used to set block size
!$MPI    integer, dimension(:), intent(inout) :: unitBelongsRank
!$MPI    integer, intent(in) :: tag ! MPI tag (probably zero)
!$MPI    integer,intent(in),optional :: minBlockSize
!$MPI    integer,intent(in),optional :: maxBlockSize
!$MPI    logical,intent(in),optional :: setDebug ! print debug messages
!$MPI  
!$MPI    integer :: blockSize
!$MPI    integer :: iErr     ! error flag
!$MPI    integer :: nUnits
!$MPI    integer :: startUnit, endUnit
!$MPI    integer :: iRank
!$MPI    logical, dimension(:), allocatable :: rankComplete
!$MPI    logical :: debugInfo
!$MPI    integer, dimension(MPI_STATUS_SIZE) :: mpiStatus    
!$MPI    character*(MPI_MAX_ERROR_STRING) :: errorString
!$MPI        !    ^ outdated, but required to work with MPI wrapper 
!$MPI    integer :: errorLength, count
!$MPI
!$MPI
!$MPI    if (present(setDebug)) then
!$MPI      debugInfo = setDebug
!$MPI    else
!$MPI      debugInfo = .false.
!$MPI    end if
!$MPI    
!$MPI    if (present(minBlockSize)) then
!$MPI      if (minBlockSize > nUnits) then
!$MPI        print *, 'Warning: in ''mpiBlockHandout'', minBlockSize > nUnits'
!$MPI      end if
!$MPI    end if
!$MPI    
!$MPI    unitBelongsRank = -999
!$MPI    nUnits = SIZE(unitBelongsRank)
!$MPI    startUnit = 1
!$MPI    
!$MPI    blockSize = nUnits / (nProc * blockDivFactor)
!$MPI
!$MPI    ! force blockSize to be within sensible limits
!$MPI    blockSize = MAX(1,blockSize)
!$MPI    if (present(minBlockSize)) blockSize = MAX(minBlockSize,blockSize) 
!$MPI    if (present(maxBlockSize)) blockSize = MIN(maxBlockSize,blockSize)
!$MPI  !  print *, 'Work unit blocksize = ', blockSize
!$MPI
!$MPI    ! th added this
!$MPI
!$MPI    if (.not.BlockHandout) then
!$MPI       blockSize = nUnits / (nProc-1)
!$MPI       iRank = 0
!$MPI     endif
!$MPI    endUnit = startUnit + (blockSize - 1)
!$MPI       
!$MPI    allocate(rankComplete(nProc-1)) ! we don't need a status value for rank 0
!$MPI    rankComplete = .false.
!$MPI       
!$MPI    do 
!$MPI      if (debugInfo) print *, 'At start of DO loop: ', startUnit, endUnit
!$MPI      
!$MPI      ! wait until we get sent the rank of a process needing a new block
!$MPI
!$MPI    ! th added if statement
!$MPI
!$MPI    if (blockHandout) then
!$MPI      if (debugInfo) print *, 'Waiting for a block request...'
!$MPI      call MPI_RECV(iRank,1,MPI_INTEGER,MPI_ANY_SOURCE,tag,MPI_COMM_WORLD,mpiStatus,iErr)
!$MPI    else
!$MPI      iErr = 0
!$MPI      iRank = iRank + 1
!$MPI      if (iRank .eq. (nProc-1)) endUnit=nUnits+1 ! last thread finishes rest
!$MPI      if (iRank .eq. nProc) exit
!$MPI    endif
!$MPI
!$MPI
!$MPI      if (debugInfo .and. iErr /= 0) then
!$MPI        print *, 'MPI return value = ',iErr
!$MPI        print *, 'source = ', mpiStatus(MPI_SOURCE)
!$MPI        print *, 'tag = ', mpiStatus(MPI_TAG)
!$MPI        print *, 'error = ', mpiStatus(MPI_ERROR)
!$MPI        !call MPI_ERROR_STRING(mpiStatus(MPI_ERROR),errorString,errorLength,iErr)
!$MPI        print *, 'errorString = ', errorString(1:errorLength), iErr
!$MPI        call MPI_GET_COUNT(mpiStatus,MPI_INTEGER,count,iErr)
!$MPI        print *, 'count = ',count, iErr
!$MPI      end if
!$MPI      
!$MPI      if (debugInfo) print *, 'Received request from rank ', iRank   
!$MPI      
!$MPI      ! check whether we have ran out of blocks to give out
!$MPI      if (startUnit > nUnits) then
!$MPI        if (debugInfo) print *,'Have ran out of units', iRank
!$MPI        
!$MPI        call MPI_SEND(-999,1,MPI_INTEGER,iRank,tag,MPI_COMM_WORLD,iErr)
!$MPI        if (debugInfo .and. iErr /= 0) print *, 'MPI return value = ',iErr
!$MPI        call MPI_SEND(-999,1,MPI_INTEGER,iRank,tag,MPI_COMM_WORLD,iErr)
!$MPI        if (debugInfo .and. iErr /= 0) print *, 'MPI return value = ',iErr
!$MPI        rankComplete(iRank) = .true.
!$MPI        
!$MPI      else if (endUnit > nUnits) then
!$MPI        ! this is the last block we have left
!$MPI        if (debugInfo) print *,' (endUnit > nUnits) ', iRank, startUnit, nUnits
!$MPI        
!$MPI        endUnit = nUnits
!$MPI        
!$MPI        ! sanity check
!$MPI        if (endUnit > nUnits .or. startUnit < 1) then
!$MPI           print *, 'Trying to send an invalid work unit!' 
!$MPI           print *, startUnit, endUnit, nUnits     
!$MPI           stop
!$MPI        end if
!$MPI        
!$MPI        if (ANY(unitBelongsRank(startUnit:endUnit) /= -999)) then
!$MPI          print *, 'Trying to give out an already allocated block!'
!$MPI          stop
!$MPI        end if
!$MPI        
!$MPI        unitBelongsRank(startUnit:nUnits) = iRank
!$MPI        call MPI_SEND(startUnit,1,MPI_INTEGER,iRank,tag,MPI_COMM_WORLD,iErr)
!$MPI        if (debugInfo .and. iErr /= 0) print *, 'MPI return value = ',iErr
!$MPI        call MPI_SEND(endUnit,1,MPI_INTEGER,iRank,tag,MPI_COMM_WORLD,iErr)
!$MPI        if (debugInfo .and. iErr /= 0) print *, 'MPI return value = ',iErr
!$MPI        
!$MPI      else 
!$MPI        ! we have (at least) one complete block still to give out
!$MPI        if (debugInfo) print *,'Normal allocation:', iRank, startUnit, endUnit
!$MPI        
!$MPI        ! sanity check
!$MPI        if (endUnit > nUnits .or. startUnit < 1) then
!$MPI           print *, 'Trying to send an invalid work unit!' 
!$MPI           print *, startUnit, endUnit, nUnits     
!$MPI           stop
!$MPI        end if
!$MPI        
!$MPI        if (ANY(unitBelongsRank(startUnit:endUnit) /= -999)) then
!$MPI          print *, 'Trying to give out an already allocated block!'
!$MPI          stop
!$MPI        end if
!$MPI        
!$MPI        unitBelongsRank(startUnit:endUnit) = iRank
!$MPI        call MPI_SEND(startUnit,1,MPI_INTEGER,iRank,tag,MPI_COMM_WORLD,iErr)
!$MPI        if (debugInfo .and. iErr /= 0) print *, 'MPI return value = ',iErr
!$MPI        call MPI_SEND(endUnit,1,MPI_INTEGER,iRank,tag,MPI_COMM_WORLD,iErr)
!$MPI        if (debugInfo .and. iErr /= 0) print *, 'MPI return value = ',iErr
!$MPI      end if  
!$MPI    
!$MPI      ! check if we're all done
!$MPI      if (ALL(rankComplete)) exit  
!$MPI    
!$MPI      ! increment the counter variables
!$MPI      startUnit = startUnit + blockSize 
!$MPI      endUnit = endUnit + blockSize 
!$MPI    
!$MPI    end do
!$MPI
!$MPI    deallocate(rankComplete)
!$MPI  
!$MPI  end subroutine mpiBlockHandout

!$MPI  subroutine mpiGetBlock(myRank,startUnit,endUnit,allDone,tag,setDebug)
!$MPI    ! this requests a work unit from the root process (which runs mpiBlockHandout)
!$MPI  
!$MPI    use input_variables, only: blockhandout
!$MPI    implicit none
!$MPI    include 'mpif.h'  
!$MPI  
!$MPI    integer, intent(in) :: myRank
!$MPI    integer, intent(out) :: startUnit, endUnit
!$MPI    logical, intent(out) :: allDone
!$MPI    integer, intent(in) :: tag ! MPI tag (probably zero)
!$MPI    logical, intent(in), optional :: setDebug
!$MPI  
!$MPI    integer :: iErr     ! error flag
!$MPI    logical :: debugInfo
!$MPI    integer, dimension(MPI_STATUS_SIZE) :: mpiStatus    
!$MPI    !character, dimension(MPI_MAX_ERROR_STRING) :: errorString
!$MPI    character*(MPI_MAX_ERROR_STRING) :: errorString
!$MPI    integer :: errorLength, count
!$MPI
!$MPI
!$MPI    if (present(setDebug)) then
!$MPI      debugInfo = setDebug
!$MPI    else
!$MPI      debugInfo = .false.
!$MPI    end if
!$MPI    
!$MPI    ! send 'my_rank' to indicate we need another block 
!$MPI    if (debugInfo) print *, 'Rank ', myRank, ' requesting a block'
!$MPI
!$MPI    ! th added if statement
!$MPI
!$MPI    iErr = 0
!$MPI    if (blockHandout) then
!$MPI    call MPI_SEND(myRank,1,MPI_INTEGER,0,tag,MPI_COMM_WORLD,ierr)
!$MPI    if (debugInfo .and. iErr /= 0) print *, 'MPI return value = ',iErr
!$MPI    if (debugInfo) print *, 'Rank ', myRank, ' request sent'
!$MPI    endif
!$MPI    
!$MPI    ! wait until we receive the block boundaries
!$MPI    call MPI_RECV(startUnit,1,MPI_INTEGER,0,tag,MPI_COMM_WORLD,mpiStatus,ierr)
!$MPI
!$MPI      if (debugInfo .and. iErr /= 0) then
!$MPI        print *, 'MPI return value = ',iErr
!$MPI        print *, 'source = ', mpiStatus(MPI_SOURCE)
!$MPI        print *, 'tag = ', mpiStatus(MPI_TAG)
!$MPI        print *, 'error = ', mpiStatus(MPI_ERROR)
!$MPI        !call MPI_ERROR_STRING(mpiStatus(MPI_ERROR),errorString,errorLength,iErr)
!$MPI        print *, 'errorString = ', errorString(1:errorLength), iErr
!$MPI        call MPI_GET_COUNT(mpiStatus,MPI_INTEGER,count,iErr)
!$MPI        print *, 'count = ',count, iErr
!$MPI      end if
!$MPI
!$MPI    call MPI_RECV(endUnit,1,MPI_INTEGER,0,tag,MPI_COMM_WORLD,mpiStatus,ierr)
!$MPI
!$MPI      if (debugInfo .and. iErr /= 0) then
!$MPI        print *, 'MPI return value = ',iErr
!$MPI        print *, 'source = ', mpiStatus(MPI_SOURCE)
!$MPI        print *, 'tag = ', mpiStatus(MPI_TAG)
!$MPI        print *, 'error = ', mpiStatus(MPI_ERROR)
!$MPI        !call MPI_ERROR_STRING(mpiStatus(MPI_ERROR),errorString,errorLength,iErr)
!$MPI        print *, 'errorString = ', errorString(1:errorLength), iErr
!$MPI        call MPI_GET_COUNT(mpiStatus,MPI_INTEGER,count,iErr)
!$MPI        print *, 'count = ',count, iErr
!$MPI      end if
!$MPI    
!$MPI    if (debugInfo) print *, 'Rank ', myRank, ' received ',startUnit, endUnit
!$MPI    
!$MPI    if (startUnit == -999) then
!$MPI      allDone = .true. 
!$MPI    else
!$MPI      allDone = .false. 
!$MPI    end if
!$MPI
!$MPI  end subroutine mpiGetBlock
  
end module parallel_mod

!!! vim:set filetype=fortran :                                !!!
!!! otherwise vim won't recognize a file with the suffix .raw !!!

! photoionization module - started on October 4th 2005 by th

module photoion_mod

use parallel_mod
use source_mod
use timing
use grid_mod
use amr_mod
use constants_mod
use messages_mod
use diffusion_mod

implicit none

private :: intersectcubeamr

type SAHAMILNETABLE
   integer :: nFreq 
   integer :: nTemp 
   real(double), pointer :: temp(:)
   real(double), pointer :: freq(:)
   real(double), pointer :: Clyc(:, :)
   real(double), pointer :: emissivity(:)
end type SAHAMILNETABLE

type RECOMBTABLE
   integer :: nrho
   integer :: nTemp 
   real(double), pointer :: rho(:)
   real(double),  pointer :: temp(:)
   real(double), pointer :: emissivity(:, :)
end type RECOMBTABLE


type GAMMATABLE
   integer :: nGamma
   integer :: nFreq
   integer :: nTemp
   real(double), pointer :: freq(:)
   real(double), pointer :: temp(:)
   real(double), pointer :: gamma(:,:)
end type GAMMATABLE



  real :: heIRecombinationFit(32, 3, 3)
  real :: heIRecombinationLambda(32)
  real :: heIRecombinationNe(3)
  real :: heIIrecombinationLines(3:30, 2:16)
  type(GAMMATABLE) :: gammaTableArray(3) ! H, HeI, HeII

contains


  subroutine photoIonizationloop(grid, source, nSource, nLambda, lamArray, readlucy, writelucy, &
       lucyfileout, lucyfilein)
    use input_variables, only : smoothFactor, blockHandout, zoomFactor, &
         nlucy, photoionization
    implicit none
!$MPI include 'mpif.h'
    type(GRIDTYPE) :: grid
    character(len=*) :: lucyfileout, lucyfilein
    logical :: readlucy, writelucy
    type(OCTAL), pointer :: thisOctal, tempOctal, endOctal
    integer :: nCellsInDiffusion
    logical :: directPhoton
    character(len=80) :: message
    integer :: tempSubcell, endSubcell
    integer :: nlambda
    real :: lamArray(:)
    integer :: nSource
    type(SOURCETYPE) :: source(:), thisSource
    integer :: iSource
    type(OCTALVECTOR) :: rVec, uHat, rHat
    real(double) :: alphaA, alpha1, v, lCore
    integer :: nMonte, iMonte
    integer :: subcell
    integer :: i, j
    logical :: escaped
    real(double) :: wavelength, thisFreq
    real :: thisLam
    type(OCTALVECTOR) :: outVec, octVec
    real(double) :: r
    integer :: ilam
    integer :: nInf
    real(double) :: kappaScadb, kappaAbsdb
    real(double) :: epsOverDeltaT, kappaH, kappaHe
    real :: dummy(3)
    real :: pops(10)
    integer :: nIter
    logical :: converged
    real(double) :: crate
    real :: xsec, temp, e, h0, he0
    real(double) :: luminosity1, luminosity2, luminosity3
    type(IONTYPE) :: thisIon
    real(double) :: alpha21s, alpha21p, alpha23s, photonPacketWeight
    real :: excitation, deexcitation, excitation2
    real(double) :: fac
    logical :: gridConverged
    real(double) :: probEsc, albedo

    type(SAHAMILNETABLE) :: hTable, heTable
    type(RECOMBTABLE) :: Hrecombtable

    real(double) :: hRecombemissivity, hlymanContemissivity, helymanContEmissivity
    real(double) :: hiContEmissivity, forbiddenEmissivity
    real(double) :: probNonIonizing, probHydrogen
    real(double) :: freq(1000), spectrum(1000), nuStart, nuEnd
    real(double) :: r1, kappaAbsGas, kappaAbsDust

    integer, parameter :: nFreq = 1000
    logical, save :: firsttime = .true.
    integer :: iMonte_beg, iMonte_end, nSCat
!$MPI    ! For MPI implementations
!$MPI  ! For MPI implementations =====================================================
!$MPI  integer ::   my_rank        ! my processor rank
!$MPI  integer ::   n_proc         ! The number of processes
!$MPI  integer ::   ierr           ! error flag
!$MPI  integer ::   n_rmdr, m      !
!$MPI  integer ::   mphotons       ! number of photons (actual) 
!$MPI  integer ::   tempInt        !
!$MPI  real, dimension(:), allocatable :: tempRealArray
!$MPI  real, dimension(:), allocatable :: tempRealArray2
!$MPI  integer, dimension(:), allocatable :: photonBelongsRank
!$MPI  integer, parameter :: tag = 0
!$MPI  logical :: rankComplete
!$MPI    ! data space to store values from all processors
!$MPI    real, save, allocatable  :: buffer_real(:)     
!$MPI    logical, save  :: first_time = .true.
!$MPI
!!$MPI    ! find the number of the processors for the first time.    
!!$MPI    if (first_time) then
!$MPI       call MPI_COMM_SIZE(MPI_COMM_WORLD, n_proc, ierr)
!!$MPI       allocate(buffer_real(n_proc))
!!$MPI       first_time = .false.
!!$MPI    end if
!$MPI
!$MPI       allocate(buffer_real(n_proc))
!$MPI
!$MPI    ! FOR MPI IMPLEMENTATION=======================================================
!$MPI    !  Get my process rank # 
!$MPI    call MPI_COMM_RANK(MPI_COMM_WORLD, my_rank, ierr)
!$MPI  
!$MPI    ! Find the total # of precessor being used in this run
!$MPI    call MPI_COMM_SIZE(MPI_COMM_WORLD, n_proc, ierr)
!$MPI    
!$MPI    if (my_rank .eq. 0) then
!$MPI       print *, ' '
!$MPI       print *, 'Photoionization loop computed by ', n_proc, ' processors.'
!$MPI       print *, ' '
!$MPI    endif
!$MPI    
!$MPI    ! ============================================================================



    nuStart = cSpeed / (1000.e4 * 1.d-8)
    nuEnd =  2.d0*maxval(grid%ion(1:grid%nIon)%nuThresh)

    do i = 1, nFreq
       freq(i) = log10(nuStart) + dble(i-1)/dble(nFreq-1) * (log10(nuEnd)-log10(nuStart))
       freq(i) = 10.d0**freq(i)
    enddo


    call createGammaTable(gammaTableArray(1), 'gammaHI.dat')
    call createGammaTable(gammaTableArray(2), 'gammaHeI.dat')
    call createGammaTable(gammaTableArray(3), 'gammaHeII.dat')

    call createSahaMilneTables(hTable, heTable)

    call createRecombTable(Hrecombtable, 'e1b.d')


    call readHeIRecombinationLinesFit()

    call readHeIIrecombination()

    lCore = 0.d0
    do i = 1, nSource
       lCore = lCore + source(i)%luminosity
    enddo

    write(*,'(a,1pe12.5)') "Total souce luminosity (lsol): ",lCore/lSol

    nMonte = nlucy

    nIter = 0
    
    converged = .false.

    if (readlucy) then
       call readAmrGrid(lucyfilein,.false.,grid)
       converged = .true.
    endif

    do while(.not.converged)
       nIter = nIter + 1
       nInf=0


       nCellsInDiffusion = 0
       call defineDiffusionOnRosseland(grid,grid%octreeRoot, ndiff=nCellsInDiffusion)
       write(message,*) "Number of cells in diffusion zone: ", nCellsInDiffusion
       call writeInfo(message,IMPORTANT)


       if (writeoutput) then
          call plot_AMR_values(grid, "ionization", "x-z", 0., &
               "ionization.ps/vcps", .true., .true., &
               0, dummy, dummy, dummy, real(grid%octreeRoot%subcellsize), .false.)

          
          call locate(lamArray, nLambda, 5500., ilam)
          call plot_AMR_values(grid, "tau", "x-z", real(grid%octreeRoot%centre%y), &
               "tau.ps/vcps", .true., .false., &
               0, dummy, dummy, dummy, real(grid%octreeRoot%subcellsize), .false.,ilam=ilam) 

          call plot_AMR_values(grid, "photocoeff", "x-z", 0., &
               "photocoeff.ps/vcps", .true., .true., &
               0, dummy, dummy, dummy, real(grid%octreeRoot%subcellsize), .false.)

       call plot_AMR_values(grid, "rho", "x-z", real(grid%octreeRoot%centre%y), &
            "rho_temp_zoom.ps/vcps", .true., .false., &
            0, dummy, dummy, dummy, real(grid%octreeRoot%subcellsize), .false.,boxfac=zoomFactor) 

       call plot_AMR_values(grid, "rho", "x-y", real(grid%octreeRoot%centre%y), &
            "rho_temp_xy.ps/vcps", .true., .false., &
            0, dummy, dummy, dummy, real(grid%octreeRoot%subcellsize), .false.) 

       call plot_AMR_values(grid, "temperature", "x-z", real(grid%octreeRoot%centre%y), &
            "lucy_zoom_xz.ps/vcps", .true., .false., &
            0, dummy, dummy, dummy, real(grid%octreeRoot%subcellsize), .false.,boxfac=zoomFactor) 
          
          call plot_AMR_values(grid, "temperature", "x-z", real(grid%octreeRoot%centre%y), &
            "lucy_temp_xz.ps/vcps", .true., .false., &
            0, dummy, dummy, dummy, real(grid%octreeRoot%subcellsize), .false.) 

       endif


       epsoverdeltat = lcore/dble(nMonte)

       call zeroDistanceGrid(grid%octreeRoot)

       if (writeoutput) then
          write(*,*) "Running loop with ",nmonte," photons. Iteration: ",niter
       endif

!$MPI       if (my_rank == 1) &
       call tune(6, "One photoionization itr")  ! start a stopwatch

       iMonte_beg = 1
       iMonte_end = nMonte

!$MPI  !====================================================================================
!$MPI  ! Splitting the innerPhoton loop for multiple processors.
!$MPI  if (my_rank == 0) then
!$MPI     print *, ' '
!$MPI     print *, 'photonLoop computed by ', n_proc-1, ' processors.'
!$MPI     print *, ' '
!$MPI  endif
!$MPI  if (my_rank == 0) then
!$MPI     ! we will use an array to store the rank of the process
!$MPI     !   which will calculate each photon
!$MPI     allocate(photonBelongsRank(nMonte))
!$MPI    
!$MPI     call mpiBlockHandout(n_proc,photonBelongsRank,blockDivFactor=10,tag=tag,&
!$MPI                          setDebug=.false.)
!$MPI     deallocate(photonBelongsRank) ! we don't really need this here. 
!$MPI  end if
!$MPI  !====================================================================================

!$MPI    
!$MPI    
!$MPI  if (my_rank /= 0) then
!$MPI    mpiBlockLoop: do  
!$MPI      call mpiGetBlock(my_rank,imonte_beg, imonte_end,rankComplete,tag,setDebug=.false.)  
!$MPI      if (rankComplete) exit mpiBlockLoop  
!$MPI    


       mainloop: do iMonte = iMonte_beg, iMonte_end

          call randomSource(source, nSource, iSource)
          thisSource = source(iSource)
          call getPhotonPositionDirection(thisSource, rVec, uHat,rHat)
          escaped = .false.

          call amrGridValues(grid%octreeRoot, rVec, foundOctal=tempOctal, &
            foundSubcell=tempsubcell)

          if (tempOctal%diffusionApprox(tempsubcell)) then
             call randomWalk(grid, tempOctal, tempSubcell, thisOctal, Subcell, temp)
             directPhoton = .false.
             rVec = subcellCentre(thisOctal, subcell)
          endif


          call getWavelength(thisSource%spectrum, wavelength)

          photonPacketWeight = 1.d0
          thisFreq = cSpeed/(wavelength / 1.e8)


!          if ((thisFreq*hcgs*ergtoev) < 13.6) then
!             cycle mainloop
!          endif
          nScat = 0
          do while(.not.escaped)
             nScat = nScat + 1

             call toNextEventPhoto(grid, rVec, uHat, escaped, thisFreq, nLambda, lamArray, photonPacketWeight)
             if (.not. escaped) then


                thisLam = (cSpeed / thisFreq) * 1.e8
                call locate(lamArray, nLambda, real(thisLam), iLam)
                octVec = rVec 
                call amrGridValues(grid%octreeRoot, octVec, foundOctal=thisOctal, foundsubcell=subcell,iLambda=iLam, &
                     lambda=real(thisLam), kappaSca=kappaScadb, kappaAbs=kappaAbsdb, grid=grid)


                albedo = kappaScaDb / (kappaAbsdb + kappaScadb)
                call random_number(r)
                if (r < albedo) then
                   uHat = randomUnitVector() ! isotropic scattering
                else
                   spectrum = 1.d-30

                   call returnKappa(grid, thisOctal, subcell, ilambda=ilam, kappaAbsDust=kappaAbsDust, kappaAbsGas=kappaAbsGas, &
                        kappaSca=kappaScadb, kappaAbs=kappaAbsdb)


                   if ((thisFreq*hcgs*ergtoev) > 13.6) then ! ionizing photon
                      call random_number(r1)
                      if (r1 < (kappaAbsGas / (kappaAbsGas + kappaAbsDust))) then  ! absorbed by gas rather than dust
                         call addLymanContinua(nFreq, freq, spectrum, thisOctal, subcell, grid)
                         call addHigherContinua(nfreq, freq, spectrum, thisOctal, subcell, grid, GammaTableArray)
                         call addHydrogenRecombinationLines(nfreq, freq, spectrum, thisOctal, subcell, grid)
!                        call addHeRecombinationLines(nfreq, freq, spectrum, thisOctal, subcell, grid)
                         call addForbiddenLines(nfreq, freq, spectrum, thisOctal, subcell, grid)
                      else
                         call addDustContinuum(nfreq, freq, spectrum, thisOctal, subcell, grid, nlambda, lamArray)
                      endif
                   else ! non-ionizing photon must be absorbed by dust
                         call addDustContinuum(nfreq, freq, spectrum, thisOctal, subcell, grid, nlambda, lamArray)
                   endif
                   if (firsttime.and.writeoutput) then
                      firsttime = .false.
                      open(67,file="pdf.dat",status="unknown",form="formatted")
                      do i = 1, nfreq
                         write(67,*) freq(i), spectrum(i)
                      enddo
                      close(67)
                   endif

                   thisFreq =  getPhotonFreq(nfreq, freq, spectrum)
!                   write(*,*) 1.d8*cspeed/thisFreq, thisFreq*hCgs*ergtoev
                   uHat = randomUnitVector() ! isotropic emission
                endif
                

             endif
             if (nScat > 100000) then
                write(*,*) "Nscat exceeded 10000, forcing escape"
                escaped = .true.
             endif
          enddo
          nInf = nInf + 1
       end do mainloop

!$MPI if (.not.blockHandout) exit mpiblockloop        
!$MPI    end do mpiBlockLoop  
!$MPI  end if ! (my_rank /= 0)

!$MPI       if(my_rank == 0) write(*,*) "Calling update_octal_MPI"

!$MPI       call MPI_BARRIER(MPI_COMM_WORLD, ierr)


!$MPI       call updateGridMPI(grid)





!$MPI       if (my_rank == 1) &
       call tune(6, "One photoionization itr")  ! stop a stopwatch

       epsOverDeltaT = (lCore) / dble(nMonte)

       call  identifyUndersampled(grid%octreeRoot)

       do i = 1 , 3
          if (writeoutput) &
               write(*,*) "Calculating ionization and thermal equilibria",i
          call calculateIonizationBalance(grid,grid%octreeRoot, epsOverDeltaT)
          call calculateThermalBalance(grid, grid%octreeRoot, epsOverDeltaT)
          if (writeoutput) &
               write(*,*) "Done."
       enddo

!$MPI  if (my_rank == 1) &
       call tune(6, "Gauss-Seidel sweeps")
       call defineDiffusionOnRosseland(grid,grid%octreeRoot)
!$MPI       if (my_rank==0) &
       call plot_AMR_values(grid, "crossings", "x-z", real(grid%octreeRoot%centre%y), &
            "crossings.ps/vcps", .true., .false., &
            0, dummy, dummy, dummy, real(grid%octreeRoot%subcellsize), .false., boxfac=zoomfactor)

       nCellsInDiffusion = 0
       call defineDiffusionOnUndersampled(grid%octreeroot, nDiff=nCellsInDiffusion)

       call plot_AMR_values(grid, "rho", "x-z", real(grid%octreeRoot%centre%y), &
            "rho_temp_zoom.ps/vcps", .true., .false., &
            0, dummy, dummy, dummy, real(grid%octreeRoot%subcellsize), .false.,boxfac=zoomFactor) 

       call solveArbitraryDiffusionZones(grid)
       call defineDiffusionOnRosseland(grid,grid%octreeRoot, nDiff=nCellsInDiffusion)
!       call unsetOnDirect(grid%octreeRoot)
       write(message,*) "Number of cells in diffusion zone: ", nCellsInDiffusion
       call writeInfo(message,IMPORTANT)

!$MPI  if (my_rank == 1) &
       call tune(6, "Gauss-Seidel sweeps")



       
if (writeoutput) then
       call dumpLexington(grid, epsoverdeltat)
       fac = 2.06e37

       luminosity1 = 0.d0
       call getHbetaLuminosity(grid%octreeRoot, grid, luminosity1)
       write(*,'(a,2f12.4)') "H beta :",luminosity1/1.e37,luminosity1/2.05e37
       fac = luminosity1
       

       call getForbiddenLineLuminosity(grid, "N II", 1.22d6, luminosity1)
       write(*,'(a,2f12.4)') "N II (122 um):",(luminosity1)/fac,(luminosity1)/(0.034*2.05e37)

       call getForbiddenLineLuminosity(grid, "N II", 6584.d0, luminosity1)
       call getForbiddenLineLuminosity(grid, "N II", 6548.d0, luminosity2)
       write(*,'(a,2f12.4)') "N II (6584+6548):",(luminosity1+luminosity2)/fac,(luminosity1+luminosity2)/(0.730*2.05e37)

       call getForbiddenLineLuminosity(grid, "N III", 5.73d5, luminosity1)
       write(*,'(a,2f12.4)') "N III (57.3 um):",(luminosity1)/fac,(luminosity1+luminosity2)/(0.292*2.05e37)


       call getForbiddenLineLuminosity(grid, "O I", 6300.d0, luminosity1)
       call getForbiddenLineLuminosity(grid, "O I", 6363.d0, luminosity2)
       write(*,'(a,2f12.4)') "O I (6300+6363):",(luminosity1+luminosity2)/fac,(luminosity1+luminosity2)/(0.0086*2.05e37)

       call getForbiddenLineLuminosity(grid, "O II", 7320.d0, luminosity1)
       call getForbiddenLineLuminosity(grid, "O II", 7330.d0, luminosity2)
       write(*,'(a,2f12.4)') "O II (7320+7330):",(luminosity1+luminosity2)/fac,(luminosity1+luminosity2)/(0.029*2.05e37)

       call getForbiddenLineLuminosity(grid, "O II", 3726.d0, luminosity1)
       call getForbiddenLineLuminosity(grid, "O II", 3729.d0, luminosity2)
       write(*,'(a,2f12.4)') "O II (3726+3729):",(luminosity1+luminosity2)/fac,(luminosity1+luminosity2)/(2.03*2.05e37)

       call getForbiddenLineLuminosity(grid, "O III", 5007.d0, luminosity1)
       call getForbiddenLineLuminosity(grid, "O III", 4959.d0, luminosity2)
       write(*,'(a,2f12.4)') "O III (5007+4959):",(luminosity1+luminosity2)/fac,(luminosity1+luminosity2)/(2.18*2.05e37)

       call getForbiddenLineLuminosity(grid, "O III", 4363.d0, luminosity3)
       write(*,'(a,2f12.4)') "O III (4363):",(luminosity3)/1.e37,luminosity3/(0.0037*2.05e37)

       call getForbiddenLineLuminosity(grid, "O III", 518145.d0, luminosity1)
       call getForbiddenLineLuminosity(grid, "O III", 883562.d0, luminosity2)
       write(*,'(a,2f12.4)') "O III (52+88um):,",(luminosity1+luminosity2)/fac,(luminosity1+luminosity2)/((1.06+1.22)*2.05e37)


       call getForbiddenLineLuminosity(grid, "Ne II", 1.28d5, luminosity1)
       write(*,'(a,2f12.4)') "Ne II (12.8um):",(luminosity1)/fac,luminosity1/(0.195*2.05e37)

       call getForbiddenLineLuminosity(grid, "Ne III", 1.56d5, luminosity1)
       write(*,'(a,2f12.4)') "Ne III (15.5um):",(luminosity1)/fac,luminosity1/(0.322*2.05e37)

       call getForbiddenLineLuminosity(grid, "Ne III", 3869.d0, luminosity1)
       call getForbiddenLineLuminosity(grid, "Ne III", 3968.d0, luminosity2)
       write(*,'(a,2f12.4)') "Ne III (3869+3968):",(luminosity1+luminosity2)/fac,(luminosity1+luminosity2)/(0.085*2.05e37)


       call getForbiddenLineLuminosity(grid, "S II", 6716.d0, luminosity1)
       call getForbiddenLineLuminosity(grid, "S II", 6731.d0, luminosity2)
       write(*,'(a,2f12.4)') "S II (6716+6731):",(luminosity1+luminosity2)/fac,(luminosity1+luminosity2)/(0.147*2.05e37)

       call getForbiddenLineLuminosity(grid, "S II", 4068.d0, luminosity1)
       call getForbiddenLineLuminosity(grid, "S II", 4076.d0, luminosity2)
       write(*,'(a,2f12.4)') "S II (4068+4076):",(luminosity1+luminosity2)/fac,(luminosity1+luminosity2)/(0.008*2.05e37)

       call getForbiddenLineLuminosity(grid, "S III", 1.87d5, luminosity1)
       write(*,'(a,2f12.4)') "S III (18.7um):",(luminosity1)/fac,luminosity1/(0.577*2.05e37)

       call getForbiddenLineLuminosity(grid, "S III", 9532.d0, luminosity1)
       call getForbiddenLineLuminosity(grid, "S III", 9069.d0, luminosity2)
       write(*,'(a,2f12.4)') "S III (9532+9069):",(luminosity1+luminosity2)/fac,(luminosity1+luminosity2)/(1.22*2.05e37)
    endif


!       if ((niter > 2).and.(nIter < 8)) then
!          call locate(grid%lamArray, grid%nLambda,900.,ilam)
!          if (writeoutput) write(*,*) "Smoothing adaptive grid structure for ionization..."
!          call smoothAMRgridIonization(grid%octreeRoot,grid,gridConverged,ilam,inheritprops = .false., interpProps = .false.)
!          if (writeoutput) write(*,*) "...grid smoothing complete"
!          call locate(grid%lamArray, grid%nLambda,400.,ilam)
!          if (writeoutput) write(*,*) "Smoothing adaptive grid structure for ionization..."
!          call smoothAMRgridIonization(grid%octreeRoot,grid,gridConverged,ilam,inheritprops = .false., interpProps = .false.)
!          if (writeoutput) write(*,*) "...grid smoothing complete"
!          if (writeoutput) write(*,*) "Smoothing adaptive grid structure..."
!          gridConverged = .false.
!          do
!             call smoothAMRgrid(grid%octreeRoot,grid,smoothFactor,gridConverged,inheritprops=.false., interpProps=.false.)
!             if (gridConverged) exit
!          end do
!          if (writeoutput) write(*,*) "...grid smoothing complete"
!       endif

!       nMonte = nMonte * 2

    if (niter == 3) converged = .true. !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

 enddo

 thisOctal => grid%octreeRoot
 call writeInfo("Calculating continuum emissivities...",TRIVIAL)
  call  calcContinuumEmissivity(grid, thisOctal, nfreq, freq, spectrum, nlambda, lamArray)
 call writeInfo("Done.",TRIVIAL)

 if (writelucy) then
    call writeAmrGrid(lucyfileout,.false.,grid)
 endif
end subroutine photoIonizationloop


 subroutine toNextEventPhoto(grid, rVec, uHat,  escaped,  thisFreq, nLambda, lamArray, photonPacketWeight)

   type(GRIDTYPE) :: grid
   type(OCTALVECTOR) :: rVec,uHat, octVec,thisOctVec, tvec
   type(OCTAL), pointer :: thisOctal, tempOctal, sourceOctal
   type(OCTAL),pointer :: oldOctal
   type(OCTAL),pointer :: foundOctal, endOctal
   integer :: endSubcell
   real(double) :: photonPacketWeight
   integer :: subcell, isubcell, tempSubcell, sourceSubcell
   real(oct) :: tval, tau, r
   real :: lamArray(:)
   integer :: nLambda
   logical :: stillinGrid
   logical :: escaped
   logical :: twoD
   real(double) :: kappaScaDb, kappaAbsDb
   real(oct) :: thisTau
   real(oct) :: thisFreq
   real(oct) :: thisLam
   integer :: iLam
   logical ::inFlow
   integer :: imonte
   real :: diffusionZoneTemp
   logical :: photonInDiffusionZone
   logical :: leftHandBoundary
   real(double) :: prob
   real :: e, h0
   real :: lambda
   integer :: ilambda, i

    stillinGrid = .true.
    escaped = .false.
       


    thisLam = (cSpeed / thisFreq) * 1.e8
    call locate(lamArray, nLambda, real(thisLam), iLam)
    if ((ilam < 1).or.(ilam > nlambda)) then
       write(*,*) "ilam errro",ilam,thisLam
    endif

! select an initial random tau and find distance to next cell

    call random_number(r)
    tau = -log(r)

    call distanceToCellBoundary(grid, rVec, uHat, tval)


!    if (grid%octreeRoot%threed) then
!       call intersectCubeAMR(grid, rVec, uHat, tVal)
!    else
!       call intersectCubeAMR2D(grid, rVec, uHat, tVal)
!    endif


    octVec = rVec
    thisOctVec = rVec

    call locate(lamArray, nLambda, real(thisLam), iLam)


    call amrGridValues(grid%octreeRoot, octVec,  iLambda=iLam, lambda=real(thisLam), foundOctal=thisOctal, &
         foundSubcell=subcell, kappaSca=kappaScadb, kappaAbs=kappaAbsdb, &
         grid=grid, inFlow=inFlow)
    oldOctal => thisOctal

    if (inFlow) then
       thisTau = dble(tVal) * (kappaAbsdb + kappaScadb)
    else
       thisTau = 1.0e-28
    end if

! if tau > thisTau then the photon has traversed a cell with no interactions

    do while(stillinGrid .and. (tau > thisTau)) 

! add on the distance to the next cell

       rVec = rVec + tVal * uHat

       octVec = rVec


! check whether the photon has escaped from the grid

       if (.not.inOctal(grid%octreeRoot, octVec)) then
          stillinGrid = .false.
          escaped = .true.
       endif


! update the distance grid

       call updateGrid(grid, thisOctal, subcell, thisFreq, tVal, photonPacketWeight, ilam)
          


       call amrGridValues(grid%octreeRoot, octVec, foundOctal=thisOctal, &
            foundSubcell=subcell)
       if (thisOctal%diffusionApprox(subcell)) then
          call randomWalk(grid, thisOctal, subcell,  endOctal, endSubcell, diffusionZoneTemp)
          rVec = subcellCentre(endOctal,endSubcell)
          octVec = rVec
          call amrGridValues(grid%octreeRoot, rVec, foundOctal=tempOctal, &
            foundSubcell=tempsubcell)
          uHat = randomUnitVector()
       endif





! now if the photon is in the grid choose a new random tau

       if (stillinGrid) then
          call random_number(r)
          tau = -log(r)
          call locate(lamArray, nLambda, real(thisLam), iLam)
          call amrGridValues(grid%octreeRoot, octVec, iLambda=iLam,lambda=real(thisLam), foundOctal=thisOctal, &
               foundSubcell=subcell, kappaSca=kappaScadb, kappaAbs=kappaAbsdb, &
               grid=grid, inFlow=inFlow)
          oldOctal => thisOctal
          thisOctVec = octVec

! calculate the distance to the next cell


          call distanceToCellBoundary(grid, rVec, uHat, tval, sOctal=thisOctal)
!          if (grid%octreeRoot%threed) then
!             call intersectCubeAMR(grid, rVec, uHat, tVal)
!          else
!             call intersectCubeAMR2D(grid, rVec, uHat, tVal)
!          endif
          octVec = rVec

! calculate the optical depth to the next cell boundary

          if (inFlow) then
             thisTau = dble(tVal) * (kappaAbsdb + kappaScadb)
          else
             thisTau = 1.0e-28
          end if

          if (tVal == 0.0d0) then
             escaped = .true.
             stillingrid = .false.
          endif
       endif ! still in grid

! if photon is still in grid and  tau > tau_to_the_next_cell then loop round again
! choosing a new tau

       
    enddo
    

! the photon may have escaped the grid...

    if (.not.inOctal(grid%octreeRoot, octVec))  escaped = .true.

 ! if not the photon must interact in this cell
       

    if (.not.escaped) then



       octVec = rVec
!       if (.not.inOctal(grid%octreeRoot, octVec)) then
!          write(*,*) "Error:: Photon location is out of boundaries, but its status is not ESCAPED."
!          write(*,*) "        .... [lucy_mod::toNextEventAMR]"
!          write(*,*) "octVec-centre = ",octVec-grid%octreeRoot%centre
!          write(*,*) "cell size = ",grid%octreeRoot%subcellsize
!          stop
!       endif
       if (dble(tau)/thisTau .gt. 1.d0) then
          write(*,*) "tau prob",tau,thisTau
       endif

       call amrGridValues(grid%octreeRoot, octVec, startOctal=oldOctal, iLambda=iLam,lambda=real(thisLam),&
            foundOctal=thisOctal, foundSubcell=subcell, & 
            kappaAbs=kappaAbsdb,kappaSca=kappaScadb, grid=grid, inFlow=inFlow)
       thisOctVec = octVec


       if (thisOctal%diffusionApprox(subcell)) then
          write(*,*) "Photon in diff zone but not escaped"
       endif

       if (.not.inFlow) kappaAbsdb =0.0d0


! update the distance grid

       if (thisTau > 0.d0) then

!          lambda = cSpeed*1.e8/thisFreq
!          call locate(lamArray, nLambda, lambda, ilambda)
          call updateGrid(grid, thisOctal, subcell, thisFreq, dble(tval)*dble(tau)/thisTau, photonPacketWeight, ilam)

          oldOctal => thisOctal
          
       endif

       if (tau > thisTau) then
          write(*,*) "tau > thistau"
          stop
       endif

! move the requisite distance within the cell and return

       tVec = rVec
       rVec = rVec + (dble(tVal)*dble(tau)/thisTau) * uHat


       octVec = rVec
       call amrGridValues(grid%octreeRoot, octVec, startOctal=oldOctal, iLambda=iLam,lambda=real(thisLam),&
            foundOctal=thisOctal, foundSubcell=subcell)
       if (thisOctal%diffusionApprox(subcell)) then
          call randomWalk(grid, thisOctal, subcell,  endOctal, endSubcell, diffusionZoneTemp)
          rVec = subcellCentre(endOctal,endSubcell)
          octVec = rVec
          call amrGridValues(grid%octreeRoot, rVec, foundOctal=tempOctal, &
            foundSubcell=tempsubcell)
          uHat = randomUnitVector()
       endif

    endif

666 continue

 end subroutine toNextEventPhoto


  subroutine intersectCube(grid, posVec, i1,i2,i3,direction, tval)
   use vector_mod
   use grid_mod
   implicit none
   type(GRIDTYPE) :: grid
   type(OCTALVECTOR) :: direction
   type(OCTALVECTOR) :: posVec, norm(6), p3(6)
   real(oct) :: t(6),tval,denom(6)
   integer :: i,j
   logical :: ok, thisOk(6)
   integer :: i1, i2, i3

   ok = .true.

   norm(1) = VECTOR(1., 0., 0.)
   norm(2) = VECTOR(0., 1., 0.)
   norm(3) = VECTOR(0., 0., 1.)
   norm(4) = VECTOR(-1., 0., 0.)
   norm(5) = VECTOR(0., -1., 0.)
   norm(6) = VECTOR(0., 0., -1.)

   p3(1) = VECTOR(grid%xAxis(i1+1), 0., 0.)
   p3(2) = VECTOR(0.,grid%yAxis(i2+1),0.)
   p3(3) = VECTOR(0.,0.,grid%zAxis(i3+1))
   p3(4) = VECTOR(grid%xAxis(i1), 0., 0.)
   p3(5) = VECTOR(0.,grid%yAxis(i2),0.)
   p3(6) = VECTOR(0.,0.,grid%zAxis(i3))

   thisOk = .true.
   
   do i = 1, 6

      denom(i) = norm(i) .dot. direction
      if (denom(i) /= 0.) then
         t(i) = (norm(i) .dot. (p3(i)-posVec))/denom(i)
      else
         thisOk(i) = .false.
         t(i) = 0.
      endif
      if (t(i) < 0.) thisOk(i) = .false.
!      if (denom > 0.) thisOK(i) = .false.
 enddo




  
  j = 0
  do i = 1, 6
    if (thisOk(i)) j=j+1
  enddo

  if (j == 0) ok = .false.
   
  if (.not.ok) then
     write(*,*) i1, i2, i3
     write(*,*) direction%x,direction%y,direction%z
     write(*,*) t(1:6)
     stop
  endif

  tval = minval(t, mask=thisOk)
  tval = max(tval * 1.001d0,dble((grid%xAxis(2)-grid%xAxis(1))/1000.))


  if (tval == 0.) then
     write(*,*) i1, i2, i3,tval
     write(*,*) posVec
     write(*,*) grid%xAxis(i1),grid%yAxis(i2),grid%zAxis(i3)
     write(*,*) grid%xAxis(i1+1),grid%yAxis(i2+1),grid%zAxis(i3+1)
     write(*,*) direction%x,direction%y,direction%z
     write(*,*) t(1:6)
     stop
  endif

  if (tval > 2.*(grid%xAxis(2)-grid%xAxis(1))) then
!     write(*,*) "tval too big",tval,i1,i2,i3,posvec
!     write(*,*) "direction",direction
!     write(*,*) t(1:6)
!     write(*,*) denom(1:6)
  endif


  end subroutine intersectCube 
  subroutine intersectCubeAMR(grid, posVec, direction, tval)
   implicit none
   type(GRIDTYPE), intent(in)    :: grid
   type(OCTALVECTOR), intent(in) :: posVec
   type(OCTALVECTOR), intent(in) :: direction
   real(oct), intent(out) :: tval
   !
   type(OCTALVECTOR) :: norm(6), p3(6)
   type(OCTAL),pointer :: thisOctal
   type(OCTALVECTOR) :: subcen, point
   integer :: subcell
   
   real(oct) :: t(6),denom(6)
   integer :: i,j
   logical :: ok, thisOk(6)


   point = posVec

   call amrGridValues(grid%octreeRoot, point, foundOctal=thisOctal, foundSubcell=subcell, grid=grid)
   subcen =  subcellCentre(thisOctal,subcell)
   ok = .true.

   norm(1) = OCTALVECTOR(1.0d0, 0.d0, 0.0d0)
   norm(2) = OCTALVECTOR(0.0d0, 1.0d0, 0.0d0)
   norm(3) = OCTALVECTOR(0.0d0, 0.0d0, 1.0d0)
   norm(4) = OCTALVECTOR(-1.0d0, 0.0d0, 0.0d0)
   norm(5) = OCTALVECTOR(0.0d0, -1.0d0, 0.0d0)
   norm(6) = OCTALVECTOR(0.0d0, 0.0d0, -1.0d0)

   p3(1) = OCTALVECTOR(subcen%x+thisOctal%subcellsize/2.0d0, subcen%y, subcen%z)
   p3(2) = OCTALVECTOR(subcen%x, subcen%y+thisOctal%subcellsize/2.0d0 ,subcen%z)
   p3(3) = OCTALVECTOR(subcen%x,subcen%y,subcen%z+thisOctal%subcellsize/2.0d0)
   p3(4) = OCTALVECTOR(subcen%x-thisOctal%subcellsize/2.0d0, subcen%y,  subcen%z)
   p3(5) = OCTALVECTOR(subcen%x,subcen%y-thisOctal%subcellsize/2.0d0, subcen%z)
   p3(6) = OCTALVECTOR(subcen%x,subcen%y,subcen%z-thisOctal%subcellsize/2.0d0)

   thisOk = .true.

   do i = 1, 6

      denom(i) = norm(i) .dot. direction
      if (denom(i) /= 0.0d0) then
         t(i) = (norm(i) .dot. (p3(i)-posVec))/denom(i)
      else
         thisOk(i) = .false.
         t(i) = 0.0d0
      endif
      if (t(i) < 0.) thisOk(i) = .false.
!      if (denom > 0.) thisOK(i) = .false.
 enddo

  
  j = 0
  do i = 1, 6
    if (thisOk(i)) j=j+1
  enddo

  if (j == 0) ok = .false.
   
  if (.not.ok) then
     write(*,*) "Error: j=0 (no intersection???) in lucy_mod::intersectCubeAMR. "
     write(*,*) direction%x,direction%y,direction%z
     write(*,*) t(1:6)
     stop
  endif

  tval = minval(t, mask=thisOk)
  tval = max(tval * 1.001d0,dble(thisOctal%subCellSize/1000.))


  if (tval == 0.) then
     write(*,*) posVec
     write(*,*) direction%x,direction%y,direction%z
     write(*,*) t(1:6)
     stop
  endif

  if (tval > sqrt(3.)*thisOctal%subcellsize) then
!     write(*,*) "tval too big",tval/(sqrt(3.)*thisOctal%subcellSize)
!     write(*,*) "direction",direction
!     write(*,*) t(1:6)
!     write(*,*) denom(1:6)
  endif


  end subroutine intersectCubeAMR

  subroutine intersectCubeAMR2D(grid, posVec, direction, tval)

! this is to find a cell intersection for a 2D AMR grid
! which is essentially a 2D-grid that projects into
! a 3D cylindrical coordinate system


   implicit none
   type(GRIDTYPE), intent(in)    :: grid
   type(OCTALVECTOR), intent(in) :: posVec
   type(OCTALVECTOR), intent(inout) :: direction
   real(oct), intent(out) :: tval
   !
   type(OCTALVECTOR) :: norm(6), p3(6)
   type(OCTAL),pointer :: thisOctal
   type(OCTALVECTOR) :: subcen, point
   real :: dx, dz ! directions in cylindrical coords
   integer :: subcell
   real(double) :: compX, compZ,currentX,currentZ
   real(double) :: distToZBoundary, distToXboundary
   real(oct) :: r1,r2,d,cosmu,x1,x2,distTor1,distTor2, theta, mu
   integer :: i,j
   logical :: ok, thisOk(6)
   type(OCTALVECTOR) :: xHat, zHAt

   point = posVec

   call amrGridValues(grid%octreeRoot, point, foundOctal=thisOctal, foundSubcell=subcell, grid=grid)
   subcen =  subcellCentre(thisOctal,subcell)
   ok = .true.


   r1 = subcen%x - thisOctal%subcellSize/2.d0
   r2 = subcen%x + thisOctal%subcellSize/2.d0
   d = sqrt(point%x**2+point%y**2)
   xHat = VECTOR(point%x, point%y,0.d0)
   call normalize(xHat)

   cosmu =((-1.d0)*xHat).dot.direction
   call solveQuadDble(1.d0, -2.d0*d*cosmu, d**2-r2**2, x1, x2, ok)
   if (.not.ok) then
      write(*,*) "Quad solver failed in intersectcubeamr2d"
      direction = randomUnitVector()
      x1 = thisoctal%subcellSize/2.d0
      x2 = 0.d0
   endif
   distTor2 = max(x1,x2)

   theta = asin(max(-1.d0,min(1.d0,r1 / d)))
   cosmu = xHat.dot.direction
   mu = acos(max(-1.d0,min(1.d0,cosmu)))
   distTor1 = 1.e30
   if (mu  < theta ) then
      call solveQuadDble(1.d0, -2.d0*d*cosmu, d**2-r1**2, x1, x2, ok)
      if (.not.ok) then
         write(*,*) "Quad solver failed in intersectcubeamr2d"
         direction = randomUnitVector()
         x1 = thisoctal%subcellSize/2.d0
         x2 = 0.d0
      endif
      distTor1 = max(x1,x2)
   endif
         
   distToXboundary = min(distTor1, distTor2)


   zHat = VECTOR(0.d0, 0.d0, 1.d0)
   compZ = zHat.dot.direction
   currentZ = point%z

   if (compZ /= 0.d0 ) then
      if (compZ > 0.d0) then
         distToZboundary = (subcen%z + thisOctal%subcellsize/2.d0 - currentZ ) / compZ
      else
         distToZboundary = abs((subcen%z - thisOctal%subcellsize/2.d0 - currentZ ) / compZ)
      endif
   else
      disttoZboundary = 1.e30
   endif

   tVal = min(distToZboundary, distToXboundary) +0.0001d0*grid%halfsmallestsubcell
   if (tVal > 1.e29) then
      write(*,*) tVal,compX,compZ, distToZboundary,disttoxboundary
      write(*,*) "subcen",subcen
      write(*,*) "x,z",currentX,currentZ
   endif
   if (tval < 0.) then
      write(*,*) tVal,compX,compZ, distToZboundary,disttoxboundary
      write(*,*) "subcen",subcen
      write(*,*) "x,z",currentX,currentZ
   endif

  end subroutine intersectCubeAMR2D

  recursive subroutine zeroDistanceGrid(thisOctal)
  type(octal), pointer   :: thisOctal
  type(octal), pointer  :: child 
  integer :: subcell, i
  
  do subcell = 1, thisOctal%maxChildren
       if (thisOctal%hasChild(subcell)) then
          ! find the child
          do i = 1, thisOctal%nChildren, 1
             if (thisOctal%indexChild(i) == subcell) then
                child => thisOctal%child(i)
                call zeroDistanceGrid(child)
                exit
             end if
          end do
       else
          thisOctal%distanceGrid(subcell) = 0.d0
          thisOctal%nCrossings(subcell) = 0
          thisOctal%undersampled(subcell) = .false.
          thisOCtal%nDiffusion(subcell) = 0.
          thisOctal%Hheating(subcell) = 0.d0
          thisOctal%Heheating(subcell) = 0.d0
          thisOctal%photoIonCoeff(subcell,:) = 0.d0
          thisOctal%distanceGrid(subcell) = 0.d0
       endif
    enddo
  end subroutine zeroDistanceGrid

  recursive subroutine getHbetaluminosity(thisOctal, grid, luminosity)
  type(octal), pointer   :: thisOctal
  type(octal), pointer  :: child 
  type(GRIDTYPE) :: grid
  real(double) :: luminosity, v, r1, r2, hbeta
  type(OCTALVECTOR) :: rVec
  integer :: subcell, i
  
  do subcell = 1, thisOctal%maxChildren
       if (thisOctal%hasChild(subcell)) then
          ! find the child
          do i = 1, thisOctal%nChildren, 1
             if (thisOctal%indexChild(i) == subcell) then
                child => thisOctal%child(i)
                call getHbetaLuminosity(child, grid, luminosity)
                exit
             end if
          end do
       else
          v = cellVolume(thisOctal, subcell)
          hbeta = (10.d0**(-0.870d0*log10(thisOctal%temperature(subcell))+3.57d0)) * &
               thisOctal%ne(subcell) * thisOctal%ionFrac(subcell, 2) * &
               thisOctal%nh(subcell)*grid%ion(1)%abundance*1.d-25
          luminosity = luminosity + hbeta * (v*1.d30)
       endif
    enddo
  end subroutine getHbetaluminosity

  recursive subroutine calculateIonizationBalance(grid, thisOctal, epsOverDeltaT)
    type(gridtype) :: grid
    type(octal), pointer   :: thisOctal
    type(octal), pointer  :: child 
    real(double) :: epsOverDeltaT, v, r1, r2, ionizationCoeff, recombCoeff
    integer :: subcell, i
    type(OCTALVECTOR) :: rVec
    
    do subcell = 1, thisOctal%maxChildren
       if (thisOctal%hasChild(subcell)) then
          ! find the child
          do i = 1, thisOctal%nChildren, 1
             if (thisOctal%indexChild(i) == subcell) then
                child => thisOctal%child(i)
                call calculateIonizationBalance(grid, child, epsOverDeltaT)
                exit
             end if
          end do
       else
          if (thisOctal%inflow(subcell)) then
             if (.not.thisOctal%undersampled(subcell)) then
                call solveIonizationBalance(grid, thisOctal, subcell, thisOctal%temperature(subcell), epsOverdeltaT)
             else
!                write(*,*) "Undersampled cell",thisOctal%ncrossings(subcell)
             endif
          endif
       endif
    enddo
  end subroutine calculateIonizationBalance

  recursive subroutine calculateThermalBalance(grid, thisOctal, epsOverDeltaT)
    type(gridtype) :: grid
    type(octal), pointer   :: thisOctal
    type(octal), pointer  :: child 
    real(double) :: epsOverDeltaT, v, r1, r2, ionizationCoeff, recombCoeff
    real(double) :: totalHeating, nHii, nHeII, nh
    integer :: subcell, i, j
    type(OCTALVECTOR) :: rVec
    logical :: converged, found
    real :: t1, t2, tm
    real(double) :: y1, y2, ym, ymin, Hheating, Heheating, tot, dustHeating
    real :: deltaT
    real(double) :: junk
    real :: underCorrection = 1.
    real :: pops(10)
    
    do subcell = 1, thisOctal%maxChildren
       if (thisOctal%hasChild(subcell)) then
          ! find the child
          do i = 1, thisOctal%nChildren, 1
             if (thisOctal%indexChild(i) == subcell) then
                child => thisOctal%child(i)
                call calculateThermalBalance(grid, child, epsOverDeltaT)
                exit
             end if
          end do
       else
          if (thisOctal%inflow(subcell)) then
             if (.not.thisOctal%undersampled(subcell)) then


                call getHeating(grid, thisOctal, subcell, hHeating, heHeating, dustHeating, totalHeating, epsOverDeltaT)

                if (totalHeating == 0.d0) then
                   thisOctal%temperature(subcell) = 1.e-3
                else
                   converged = .false.

                   t1 = 1.
                   t2 = 30000.
                   found = .true.

                   if (found) then
                      y1 = (HHecooling(grid, thisOctal, subcell, epsOverDeltat,t1) &
                           - totalHeating)
                      y2 = (HHecooling(grid, thisOctal, subcell, epsOverDeltat,t2) &
                           - totalHeating)
                      if (y1*y2 > 0.d0) then
!                         do i = 1, 100
!                            t1 = 40000.*real(i-1)/99.
!                            y1 = (HHecooling(grid, thisOctal, subcell, epsOverDeltat,t1) &
!                                 - totalHeating)
!                            write(*,*) t1,y1
!                         enddo



                         write(*,*) "t1", &
                              t1,HHecooling(grid, thisOctal, subcell, epsOverDeltat,t1), &
                              totalHeating,thisOctal%rho(subcell)
                         write(*,*) "t2", &
                              t2,HHecooling(grid, thisOctal, subcell, epsOverDeltat,t2), &
                              totalHeating,thisOctal%rho(subcell)
                         tm = t1
                         converged = .true.
                      endif
                   
                      ! Find root of heating and cooling by bisection
                      
                      do while(.not.converged)
                         tm = 0.5*(t1+t2)
                         y1 = (HHecooling(grid, thisOctal, subcell, epsOverDeltat,t1) &
                              - totalheating)
                         y2 = (HHecooling(grid, thisOctal, subcell, epsOverDeltat,t2) &
                              - totalheating)
                         ym = (HHecooling(grid, thisOctal, subcell, epsOverDeltat,tm) &
                              - totalheating)
                         
                         if (y1*ym < 0.d0) then
                            t1 = t1
                            t2 = tm
                         else if (y2*ym < 0.d0) then
                            t1 = tm
                            t2 = t2
                         else
                            converged = .true.
                            tm = 0.5*(t1+t2)
                            write(*,*) t1, t2, y1,y2,ym
                         endif
                         
                         if (abs((t1-t2)/t1) .le. 1.e-2) then
                            converged = .true.
                         endif
                      
                      enddo
                   endif
                   deltaT = tm - thisOctal%temperature(subcell)
                   thisOctal%temperature(subcell) = &
                        max(thisOctal%temperature(subcell) + underCorrection * deltaT,1.e-3)
                endif
             else
 !                write(*,*) "Undersampled cell",thisOctal%ncrossings(subcell)
             endif
          endif
       endif
    enddo
  end subroutine calculateThermalBalance


  function hRecombination(temperature) result (rate)
    real :: temperature
    real(double) :: rate, t0, t1, b

    t0 = sqrt(temperature/3.148d0)
    t1 = sqrt(temperature/7.036d5)
    b = 0.7480

    rate = 7.982d-11 / (t0*(1.d0+t0)**(1.d0-b) * (1.d0 + t1)**(1.d0+b))
  end function hRecombination

  function recombToGround(temperature) result (alpha1)
    real :: temperature
    real(double) :: alpha1

    alpha1 = 1.58d-13 * (temperature/1.d4)**(-0.53d0)  ! kenny's photo paper equation 24
  end function recombToGround

  
  function HHeCooling(grid, thisOctal, subcell, epsOverDeltaT, temperature, debug) result (coolingRate)
    type(OCTAL),pointer :: thisOctal
    integer :: subcell
    real(double) :: epsOverDeltaT
    type(GRIDTYPE) :: grid
    real(double) :: nHii, nHeii, ne, nh
    real :: temperature
    logical, optional :: debug
    real(double) :: coolingRate, crate, dustCooling
    real(double) :: gff
    real :: rootTbetaH(31) = (/ 8.287e-11, 7.821e-11, 7.356e-11, 6.982e-11, 6.430e-11, 5.971e-11, 5.515e-11, 5.062e-11, 4.614e-11, &
                               4.170e-11, 3.734e-11, 3.306e-11, 2.888e-11, 2.484e-11, 2.098e-11, 1.736e-11, 1.402e-11, 1.103e-11, &
                               8.442e-12, 6.279e-12, 4.539e-12, 3.192e-12, 2.185e-12, 1.458e-12, 9.484e-13, 6.023e-13, 3.738e-13, &
                               2.268e-13, 1.348e-13, 7.859e-14, 4.499e-14 /)

    real :: rootTbetaHe(18) = (/ 8.347e-11, 7.889e-11, 7.430e-11, 6.971e-11, 6.512e-11, 6.056e-11, 5.603e-11, 5.154e-11, 4.710e-11,&
                               4.274e-11, 3.847e-11, 3.431e-11, 3.031e-11, 2.650e-11, 2.291e-11, 1.960e-11, 1.660e-11, 1.394e-11 /)

    real :: logT(31) = (/ 1.0, 1.2, 1.4, 1.6, 1.8, 2.0, 2.2, 2.4, 2.6, 2.8, 3.0, 3.2, 3.4, 3.6, 3.8, 4.0, 4.2, 4.4, 4.6, 4.8, 5.0, &
                      5.2, 5.4, 5.6, 5.8, 6.0, 6.2, 6.4, 6.6, 6.8, 7.0 /)
    real(double) :: fac, thisRootTbetaH, betaH, betaHe, thisRootTbetaHe
    real :: thisLogT
    integer :: n
    real(double) :: log10te,betarec, coolrec, betaff, coolff
    real :: ch12, ch13, ex12, ex13, th12, th13, coolcoll, te4, teused
    real(double) :: becool
    real :: kappap
    real, parameter                :: hcRyd = &    ! constant: h*c*Ryd (Ryd at inf used) [erg]
         & 2.1799153e-11


!    call solveIonizationBalance(grid, thisOctal, subcell,  temperature, epsOverdeltaT)
                
    nHii = thisOctal%nh(subcell) * thisOctal%ionFrac(subcell,2) * grid%ion(2)%abundance
    nHeii = thisOctal%nh(subcell) * thisOctal%ionFrac(subcell,4) * grid%ion(4)%abundance
    nh = thisOctal%nh(subcell)
    ne = thisOctal%ne(subcell)
                


    becool = 0.
    coolingRate = 0.d0

    gff = 1.1d0 + 0.34d0*exp(-(5.5d0 - log10(temperature))**2 / 3.d0)  ! Kenny equation 23

    coolingRate = 1.42d-27 * (nHii+nHeii) * ne * gff * sqrt(temperature)  ! Kenny equation 22 (free-free)

    thisLogT = log10(temperature)
    log10te = thisLogT
    teused = temperature


    ! cooling of gas due to FF radiation from H+ 
    ! fits to Hummer, MNRAS 268(1994) 109, Table 1. or  least square fitting to m=4

    betaFF = 1.0108464E-11 + 9.7930778E-13*log10Te - &
         & 6.6433144E-13*log10Te*log10Te + 2.4793747E-13*log10Te*log10Te*log10Te -&
         & 2.3938215E-14*log10Te*log10Te*log10Te*log10Te
    
    coolFF = Nhii*Ne*betaFF*kerg*TeUsed/sqrt(TeUsed)

    becool = becool + coolfF

    ! cooling of gas due to recombination of H+
    ! fits to Hummer, MNRAS 268(1994) 109, Table 1.  
    ! least square fitting to m=4
    betaRec = 9.4255985E-11 -4.04794384E-12*log10Te &
         & -1.0055237E-11*log10Te*log10Te +  1.99266862E-12*log10Te*log10Te*log10Te&
         & -1.06681387E-13*log10Te*log10Te*log10Te*log10Te
    
    coolRec = Nhii*Ne*betaRec*kerg*TeUsed/sqrt(TeUsed)
    

    becool = becool+ coolrec


    ! collisional excitation of Hydrogen
    ! Mathis, Ly alpha, beta
    ch12 = 2.47e-8
    ch13 = 1.32e-8
    ex12 = -0.228
    ex13 = -0.460
    th12 = 118338.
    th13 = 140252.
    te4 = temperature / 1.e4
    coolColl = 0.
    if (TeUsed > 5000.) then 
       
       coolColl = (ch12*exp(-th12/TeUsed)*Te4**ex12 + &
            & ch13*exp(-th13/TeUsed)*Te4**ex13) * &
            & hcRyd*(nh-nhii)*Ne
       
    else
       
       coolColl = 0.
       
    end if
    coolingrate = coolingrate + coolcoll

    becool = becool +coolcoll

    if (PRESENT(debug)) then
       if (debug) then
          if (becool /= 0.) then
             write(*,*) coolff/becool, coolrec/becool, coolcoll/becool
          endif
       endif
    endif

    if (coolingRate < 0.) then
       write(*,*) "negative ff cooling",nhii,nheii,ne,gff,sqrt(temperature)
    endif

    call locate(logT, 31, thisLogT, n)
    fac = (thisLogT - logT(n))/(logT(n+1)-logT(n))

    thisRootTbetaH = rootTbetaH(n) + (rootTbetaH(n+1)-rootTbetaH(n)) * fac


    if (thisLogT < logT(18)) then
       thisRootTbetaHe = rootTbetaHe(n) + (rootTbetaHe(n+1)-rootTbetaHe(n)) * fac
    else
       thisRootTbetaHe = 0.d0
    endif

    betaH = thisrootTbetaH / sqrt(temperature)
    betaHe = thisrootTbetaHe / sqrt(temperature)


    betah = betah * 2.d0 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    coolingRate = coolingRate +  ne * nhii * kerg * temperature * betaH



    if (ne * nhii * kerg * temperature * betaH < 0.) then
       write(*,*) "negative H cooling",ne,nhii,kerg,temperature,betah
    endif


    coolingRate = coolingRate + ne * nheii * kerg * temperature * betaHe

    if (ne * nheii * kerg * temperature * betaHe < 0.) then
       write(*,*) "negative He cooling",ne,nheii,kerg,temperature,betaHe
    endif


    call metalcoolingRate(grid%ion, grid%nIon, thisOctal, subcell, nh, ne, temperature, crate)
    if (crate < 0.) then
       write(*,*) "total negative metal cooling",crate
    endif
!    write(*,*) coolingRate,crate,coolingRate/(coolingrate+crate)
    coolingRate = coolingRate + crate

    call returnKappa(grid, thisOctal, subcell, kappap=kappap)

    dustCooling = fourPi * kappaP * (stefanBoltz/pi) * temperature**4

    coolingRate = coolingRate + dustCooling

  end function HHeCooling

  subroutine updateGrid(grid, thisOctal, subcell, thisFreq, distance, photonPacketWeight, ilambda)
    type(GRIDTYPE) :: grid
    type(OCTAL), pointer :: thisOctal
    integer :: subcell
    real(double) :: thisFreq, distance, kappaAbs,kappaAbsDust
    real :: lambda
    integer :: ilambda
    real(double) :: photonPacketWeight
    integer :: i 
    real :: e, xsec

    thisOctal%nCrossings(subcell) = thisOctal%nCrossings(subcell) + 1

    e = thisFreq * hCgs * ergtoEV



    do i = 1, grid%nIon
       call phfit2(grid%ion(i)%z, grid%ion(i)%n, grid%ion(i)%outerShell , e , xsec)
       if (xSec > 0.) then
          thisOctal%photoIonCoeff(subcell,i) = thisOctal%photoIonCoeff(subcell,i) &
               + distance * dble(xsec) / (dble(hCgs) * thisFreq) * photonPacketWeight
       endif

       ! neutral H heating

       if ((grid%Ion(i)%z == 1).and.(grid%Ion(i)%n == 1)) then
          thisOctal%Hheating(subcell) = thisOctal%Hheating(subcell) &
            + dble(distance) * dble(xsec / (thisFreq * hCgs)) &
            * (dble(hCgs * thisFreq) - dble(hCgs * grid%ion(i)%nuThresh)) * photonPacketWeight
       endif

       ! neutral He heating

       if ((grid%Ion(i)%z == 2).and.(grid%Ion(i)%n == 2)) then
          thisOctal%Heheating(subcell) = thisOctal%Heheating(subcell) &
            + dble(distance) * dble(xsec / (thisFreq * hCgs)) &
            * (dble(hCgs * thisFreq) - dble(hCgs * grid%ion(i)%nuThresh)) * photonPacketWeight
       endif

    enddo



    call returnKappa(grid, thisOctal, subcell, ilambda=ilambda, kappaAbsDust=kappaAbsDust, kappaAbs=kappaAbs)

    thisOctal%distanceGrid(subcell) = thisOctal%distanceGrid(subcell) &
         + dble(distance) * dble(kappaAbsDust)


  end subroutine updateGrid

subroutine solveIonizationBalance(grid, thisOctal, subcell, temperature, epsOverdeltaT)
  implicit none
  type(GRIDTYPE) :: grid
  type(OCTAL) :: thisOctal
  real(double) :: epsOverDeltaT, V
  real :: temperature
  integer :: subcell
  integer :: i, j, k
  real(double), allocatable :: matrixA(:,:), MatrixB(:,:), tempA(:,:)
  integer :: nIonizationStages
  type(OCTALVECTOR) :: rVec
  real(double) :: r1, r2
  integer :: iStart, iEnd, iIon
  real(double) :: chargeExchangeIonization, chargeExchangeRecombination
  logical :: ok, easyWay
  real(double) :: ionRateInto, recombRateOutof
  real(double), allocatable :: xplus1overx(:)

  v = cellVolume(thisOctal, subcell)
  k = 1
  do while(k <= grid%nIon)

     iStart = k
     iEnd = k+1
     do while(grid%ion(istart)%z == grid%ion(iEnd)%z)
        iEnd = iEnd + 1
     enddo
     iEnd = iEnd - 1
     nIonizationStages = iEnd - iStart + 1
     
     
     allocate(xplus1overx(1:nIonizationStages-1))
     do i = 1, nIonizationStages-1
        iIon = iStart+i-1
        call getChargeExchangeRecomb(grid%ion(iion+1), temperature, &
             thisOctal%nh(subcell)*grid%ion(1)%abundance*thisOctal%ionFrac(subcell,1),  &
             thisOctal%nh(subcell)*grid%ion(2)%abundance*thisOctal%ionFrac(subcell,2),  &
             chargeExchangeRecombination)
        
        call getChargeExchangeIon(grid%ion(iion), temperature, &
             thisOctal%nh(subcell)*grid%ion(1)%abundance*thisOctal%ionFrac(subcell,1),  &
             thisOctal%nh(subcell)*grid%ion(2)%abundance*thisOctal%ionFrac(subcell,2),  &
             chargeExchangeIonization)
        
        
        xplus1overx(i) = ((epsOverDeltaT / (v * 1.d30))*thisOctal%photoIonCoeff(subcell, iIon) + chargeExchangeIonization) / &
             max(1.d-50,(recombRate(grid%ion(iIon),temperature) * thisOctal%ne(subcell) + chargeExchangeRecombination))
        !           if (grid%ion(iion)%species(1:1) =="C") write(*,*) i,xplus1overx(i)
     enddo
     thisOctal%ionFrac(subcell, iStart:iEnd) = 1.
     do i = 1, nIonizationStages - 1
        iIon = iStart+i-1
        thisOctal%ionFrac(subcell,iIon+1) = thisOctal%ionFrac(subcell,iIon) * xplus1overx(i)
        !           if (grid%ion(iion)%species(1:1) =="C") write(*,*) i,thisOctal%ionFrac(subcell,iIon)
     enddo
     if (SUM(thisOctal%ionFrac(subcell,iStart:iEnd)) /= 0.d0) then
        thisOctal%ionFrac(subcell,iStart:iEnd) = &
             max(1.d-50,thisOctal%ionFrac(subcell,iStart:iEnd))/SUM(thisOctal%ionFrac(subcell,iStart:iEnd))
     else
        thisOctal%ionFrac(subcell,iStart:iEnd) = 1.d-50
     endif
     

        deallocate(xplus1overx)

        k = iEnd + 1
     end do

     thisOctal%ne(subcell) = returnNe(thisOctal, subcell, grid%ion, grid%nion)

   end subroutine solveIonizationBalance


function recombRate(thisIon, temperature) result (rate)
  type(IONTYPE) :: thisIon
  real :: temperature
  real(double) :: rate
  real(double) :: a, b, t0, t1, c, d, f, t, z

! recombinations INTO this species

  select case(thisIon%z)

     case(1)
        select case(thisIon%n)
           case(1) ! H I
              a = 7.982e-11
              b = 0.7480
              t0 = 3.148e0
              t1 = 7.036e5
              rate = vernerFerland(a, dble(temperature), t0, t1, b)
           case DEFAULT
              write(*,*) "No recombination rate for ",thisIon%species
              rate = 0.
        end select
     case(2)
        select case(thisIon%n)
           case(2) ! He I 
              a = 3.294e-11
              b = 0.6910
              t0 = 1.544e1
              t1 = 3.676e7
              rate = vernerFerland(a, dble(temperature), t0, t1, b)
           case(1) ! He II
              a = 1.891e-10
              b = 0.7524
              t0 = 9.370e00
              t1 = 2.774e6
              rate = vernerFerland(a, dble(temperature), t0, t1, b)
           case DEFAULT
              write(*,*) "No recombination rate for ",thisIon%species
              rate  = 0.
        end select
     case(6)
        select case(thisIon%n)
           case(6) ! C I 
              a = 0.0108
              b = -0.1075
              c = 0.2810
              d = -0.0193
              f = -0.1127
              t = temperature / 10000.
              rate = nussbaumerStorey1983(t,a,b,c,d,f)
              z = 1
              a = 5.068
              b = -0.6192
              c = -0.0815
              d = 1.2910
              rate = rate + ppb1991(z, a, b, c, d, dble(temperature))
           case(5) ! C II
              a = 1.8267
              b = 4.1012
              c = 4.8443
              d = 0.2261
              f = 0.5960
              t = temperature / 10000.
              rate = nussbaumerStorey1983(t,a,b,c,d,f)
              z = 2
              a = 5.434
              b = -0.6116
              c = 0.0694
              d = 0.7866
              rate = rate + ppb1991(z, a, b, c, d, dble(temperature))
           case(4) ! C III
              a = 2.3196
              b = 10.7328
              c = 6.8830
              d = -0.1824
              f = 0.4101
              t = temperature / 10000.
              rate = nussbaumerStorey1983(t,a,b,c,d,f)
              z = 3
              a = 4.742
              b = -0.6167
              c = 0.2960
              d = 0.6167
              rate = rate + ppb1991(z, a, b, c, d, dble(temperature))
           case(3) ! C IV
              a = 8.540e-11
              b = 0.5247
              t0 = 5.014e2
              t1 = 1.479e7
              rate = vernerFerland(a, dble(temperature), t0, t1, b)
           case(2) ! C V
              a = 2.765e-10
              b = 0.6858
              t0 = 1.535e2
              t1 = 2.556e7
              rate = vernerFerland(a, dble(temperature), t0, t1, b)
           case DEFAULT
              write(*,*) "No recombination rate for ",thisIon%species
              rate  = 0.
        end select
     case(7)
        select case(thisIon%n)
           case(7) ! N I 
              a = 0.0
              b = 0.6310
              c = 0.1990
              d = -0.0197
              f = 0.4398
              t = temperature / 10000.
              rate = nussbaumerStorey1983(t,a,b,c,d,f)
              z = 1
              a = 3.874
              b = -0.6487
              c = 0.
              d = 1.
              rate = rate + ppb1991(z, a, b, c, d, dble(temperature))
           case(6) ! N II
              a = 0.0320
              b = -0.6624
              c = 4.3191
              d = 0.0003
              f = 0.5946
              t = temperature / 10000.
              rate = nussbaumerStorey1983(t,a,b,c,d,f)
              z = 2
              a = 4.974
              b = -0.6209
              c = 0.
              d = 1.
              rate = rate + ppb1991(z, a, b, c, d, dble(temperature))
           case(5) ! N III
              a = -0.8806
              b = 11.2406
              c = 30.7066
              d = -1.1721
              f = 0.6127
              t = temperature / 10000.
              rate = nussbaumerStorey1983(t,a,b,c,d,f)
              z = 3
              a = 4.750
              b = -0.5942
              c = 0.8452
              d = 2.8450
              rate = rate + ppb1991(z, a, b, c, d, dble(temperature))
           case(4) ! N IV
              a = 0.4134
              b = -4.6319
              c = 25.9172
              d = -2.2290
              f = 0.2360
              t = temperature / 10000.
              rate = nussbaumerStorey1983(t,a,b,c,d,f)
              z = 4
              a = 4.626
              b = -0.9521
              c = 0.4729
              d = -0.4477
              rate = rate + ppb1991(z, a, b, c, d, dble(temperature))
           case(3) ! N V
              a = 1.169e-10
              b = 0.5470
              t0 = 6.793e2
              t1 = 1.650e7
              rate = vernerFerland(a, dble(temperature), t0, t1, b)
           case DEFAULT
              write(*,*) "No recombination rate for ",thisIon%species
              rate  = 0.
        end select
     case(8)
        select case(thisIon%n)
           case(8) ! O I 
              t = temperature / 10000.
              if (t < 2.) then
                 a = -0.0001
                 b = 0.0001
                 c = 0.0956
                 d = 0.0193
                 f = 0.4106
              else
                 a = 0.3715
                 b = -0.0293
                 c = -0.0597
                 d = 0.0678
                 f = 0.7993
              endif
              rate = nussbaumerStorey1983(t,a,b,c,d,f)
              z = 1
              a = 3.201
              b = -0.6880
              c = -0.0174
              d = 1.7070
              rate = rate + ppb1991(z, a, b, c, d, dble(temperature))
           case(7) ! O II
              a = -0.0036
              b = 0.7519
              c = 1.5252
              d =-0.0838
              f = 0.2769
              t = temperature / 10000.
              rate = nussbaumerStorey1983(t,a,b,c,d,f)
              z = 2
              a = 4.092
              b = -0.6413
              c = 0.
              d = 1.
              rate = rate + ppb1991(z, a, b, c, d, dble(temperature))
           case(6) ! O III
              a = 0.0
              b = 21.8790
              c = 16.2730
              d = -0.7020
              f = 1.1899
              t = temperature / 10000.
              rate = nussbaumerStorey1983(t,a,b,c,d,f)
              z = 3
              a = 4.890
              b = -0.6213
              c = 0.0184
              d = 1.5550
              rate = rate + ppb1991(z, a, b, c, d, dble(temperature))
           case(5) ! O IV
              t = temperature / 10000.
              if (t < 2.) then
                 a = -0.3648
                 b =  7.2698
                 c =  17.2187
                 d =  9.8335
                 f = -0.0166
              else
                 a = -2.5053
                 b = 3.4903
                 c = 67.4128
                 d = -3.4450
                 f = 0.8501
              endif
              rate = nussbaumerStorey1983(t,a,b,c,d,f)
              z = 4
              a = 14.665
              b = -0.5140
              c = 2.7300
              d = 0.2328
              rate = rate + ppb1991(z, a, b, c, d, dble(temperature))
           case(4) ! O V
              a = -2.8425
              b = 0.2283
              c = 40.4072
              d = -3.4956
              f = 1.7558
              t = temperature / 10000.
              rate = nussbaumerStorey1983(t,a,b,c,d,f)
              z = 5
              a = 4.626
              b = -0.9521
              c = 0.4729
              d = -0.4477
              rate = rate + ppb1991(z, a, b, c, d, dble(temperature))
           case DEFAULT
              write(*,*) "No recombination rate for ",thisIon%species
              rate  = 0.
        end select

     case(10)
        select case(thisIon%n) ! from nussbaumer and storey 1987
           case(10) ! Ne I
              z = 1
              a = 7.317
              b = -0.5358
              c = 2.4130
              d = 0.4176
              rate = ppb1991(z, a, b, c, d, dble(temperature))
           case(9) ! Ne II
              a = 0.0129
              b =-0.1779
              c = 0.9353
              d =-0.0682
              f = 0.4516
              t = temperature / 10000.
              rate = nussbaumerStorey1983(t,a,b,c,d,f)
              z = 2
              a = 11.80
              b = -0.5404
              c = 3.0300
              d = 0.2050
              rate = rate + ppb1991(z, a, b, c, d, dble(temperature))
           case(8) ! Ne III
              a = 3.6781
              b = 14.1481
              c = 17.1175
              d = -0.5017
              f = 0.2313
              t = temperature / 10000.
              rate = nussbaumerStorey1983(t,a,b,c,d,f)
              z = 3
              a = 5.841
              b = -0.5921
              c = 0.4498
              d = 0.6395
              rate = rate + ppb1991(z, a, b, c, d, dble(temperature))
           case(7) ! Ne IV
              a =-0.0254
              b = 5.5365
              c = 17.0727
              d = -0.7225
              f = 0.1702
              t = temperature / 10000.
              rate = nussbaumerStorey1983(t,a,b,c,d,f)
              z = 4
              a = 15.550
              b = -0.4825
              c = 3.2740
              d = 0.3030
              rate = rate + ppb1991(z, a, b, c, d, dble(temperature))
           case(6) ! Ne V
              a = -0.0141
              b = 33.8479
              c = 43.1608
              d =-1.6072
              f = 0.1942
              t = temperature / 10000.
              rate = nussbaumerStorey1983(t,a,b,c,d,f)
              z = 5
              a = 7.538
              b = -0.5540
              c = 1.2960
              d = 0.3472
              rate = rate + ppb1991(z, a, b, c, d, dble(temperature))
           case(5) ! Ne VI
              a = 19.9280
              b = 235.0536
              c = 152.5096
              d = 9.1413
              f = 0.1282
              t = temperature / 10000.
              rate = nussbaumerStorey1983(t,a,b,c,d,f)
              z = 6
              a = 5.239
              b = -0.5966
              c = 0.7135
              d = 0.4537
              rate = rate + ppb1991(z, a, b, c, d, dble(temperature))
           case DEFAULT
              write(*,*) "No recombination rate for ",thisIon%species
              rate  = 0.
        end select

     case(16)
        select case(thisIon%n) ! from nussbaumer and storey 1987
           case(16) ! S I 
              rate = 3.e-13
              rate = rate + svs1982(dble(temperature), 4.10D-13, 6.30D-1)
           case(15) ! S II
              rate = 3.e-30 ! page 1344, para 2, kenny's paper
              rate = rate + svs1982(dble(temperature), 1.80D-12, 6.86D-1)
           case(14) ! S  III
              rate = 1.5e-11
              rate = rate + svs1982(dble(temperature), 2.70D-12, 7.45D-1)
           case(13) ! S IV
              rate = 2.5e-11
              rate = rate + svs1982(dble(temperature), 5.70D-12, 7.55D-1)
        end select
     case DEFAULT
        write(*,*) "No recombination rate for ",thisIon%species
        rate  = 0.
  end select
end function recombRate

real function vernerFerland(a, t, t0, t1, b)
  real(double):: a, t, t0, t1, b

! based on Verner and Ferland (1996) ApJS 103 467

  vernerFerland = a / (sqrt(t/t0) * (1.d0+sqrt(t/t0))**(1.d0-b) * (1.d0+sqrt(t/t1))**(1.d0+b))
end function vernerFerland



function nussbaumerStorey1983(t, a, b, c, d, f) result(rate)

! based on Nussbaumer & Storey 1983 AA 126 75
  real(double) :: t, a, b, c, d, f, rate
  if (t ==0.d0) then
     rate = tiny(rate)
  else
     rate = (1.d-12) * ((a/t) + b + (c*t) + d*(t**2))*(t**(-1.5d0))*exp(-f/t)
  endif

end function nussbaumerStorey1983

function ppb1991(z, a, b, c, d, temperature) result(rate)

! radiative recombination rates
! based on Pequignot, Petitjean & Boisson (1991) A&A 251 680

  real(double) :: z, a, b, c, d, temperature, t, rate

  t = 1.d-4 * temperature / z**2

  rate = 1.d-13 * z * (a*t**b)/(1.d0+c*t**d)

end function ppb1991

function svs1982(t, alpharad, xrad) result (rate)

! radiative recombination rates based on
! Shull and Van Steenberg, 1992, ApJS, 48, 95

  real(double) :: t, alpharad, xrad, rate

  rate = alpharad * (t /1.d4)**(-xrad)
end function svs1982

function returnNe(thisOctal, subcell, ionArray, nion) result (ne)
  real(double) :: ne, tot
  integer :: subcell
  type(OCTAL) :: thisOctal
  type(IONTYPE) :: ionArray(:)
  integer :: nion, i

  tot = 0.d0 
  do i = 1, nIon
     tot = tot + ionArray(i)%abundance * thisOctal%nh(subcell) * &
          thisOctal%ionFrac(subcell, i) * dble(ionArray(i)%z-ionArray(i)%n)
  enddo
  ne = tot
end function returnNe

subroutine dumpLexington(grid, epsoverdt)
  type(GRIDTYPE) :: grid
  type(OCTAL), pointer :: thisOctal
  integer :: subcell
  integer :: i, j
  real(double) :: r, theta
  real :: t,hi,hei,oii,oiii,cii,ciii,civ,nii,niii,niv,nei,neii,neiii,neiv
  real(double) :: oirate, oiirate, oiiirate, oivrate
  real(double) :: v, epsoverdt,r1,r2
  type(OCTALVECTOR) :: rvec
  type(OCTALVECTOR) :: octVec
  real :: fac
  real(double) :: hHeating, heHeating, totalHeating, heating, nh, nhii, nheii, ne
  real(double) :: cooling, dustHeating
  real :: netot
  open(20,file="lexington.dat",form="formatted",status="unknown")
  open(21,file="orates.dat",form="formatted",status="unknown")
  open(22,file="ne.dat",form="formatted",status="unknown")

  do i = 1, 50
     r = (1.+7.d0*dble(i-1)/49.d0)*pctocm/1.e10

     t=0;hi=0; hei=0;oii=0;oiii=0;cii=0;ciii=0;civ=0;nii=0;niii=0;niv=0;nei=0;neii=0;neiii=0;neiv=0;ne=0.

     oirate = 0; oiirate = 0; oiiirate = 0; oivrate = 0
     heating = 0.d0; cooling = 0.d0
     do j = 1, 100
        call random_number(theta)
        theta = theta * Pi
        
        octVec = OCTALVECTOR(r*sin(theta),0.d0,r*cos(theta))
        
        call amrgridvalues(grid%octreeRoot, octVec,  foundOctal=thisOctal, foundsubcell=subcell)

        nHii = thisOctal%nh(subcell) * thisOctal%ionFrac(subcell,2) * grid%ion(2)%abundance
        nHeii = thisOctal%nh(subcell) * thisOctal%ionFrac(subcell,4) * grid%ion(4)%abundance
        nh = thisOctal%nh(subcell)
        ne = thisOctal%ne(subcell)

!        cooling = cooling + HHeCooling(grid, thisOctal, subcell, thisOctal%temperature(subcell))

        v = cellVolume(thisOctal, subcell)

        HI = HI + thisOctal%ionfrac(subcell,returnIonNumber("H I", grid%ion, grid%nIon))
        HeI = HeI + thisOctal%ionfrac(subcell,returnIonNumber("He I", grid%ion, grid%nIon))
        OII = OII + thisOctal%ionfrac(subcell,returnIonNumber("O II", grid%ion, grid%nIon))
        OIII = OIII + thisOctal%ionfrac(subcell,returnIonNumber("O III", grid%ion, grid%nIon))
        CII = CII + thisOctal%ionfrac(subcell,returnIonNumber("C II", grid%ion, grid%nIon))
        CIII = CIII + thisOctal%ionfrac(subcell,returnIonNumber("C III", grid%ion, grid%nIon))
        CIV = CIV + thisOctal%ionfrac(subcell,returnIonNumber("C IV", grid%ion, grid%nIon))
        NII = NII + thisOctal%ionfrac(subcell,returnIonNumber("N II", grid%ion, grid%nIon))
        NIII = NIII + thisOctal%ionfrac(subcell,returnIonNumber("N III", grid%ion, grid%nIon))
        NIV = NIV + thisOctal%ionfrac(subcell,returnIonNumber("N IV", grid%ion, grid%nIon))
        NeI = NeI + thisOctal%ionfrac(subcell,returnIonNumber("Ne I", grid%ion, grid%nIon))
        NeII = NeII + thisOctal%ionfrac(subcell,returnIonNumber("Ne II", grid%ion, grid%nIon))
        NeIII = NeIII + thisOctal%ionfrac(subcell,returnIonNumber("Ne III", grid%ion, grid%nIon))
        NeIV = NeIV + thisOctal%ionfrac(subcell,returnIonNumber("Ne IV", grid%ion, grid%nIon))
        netot = netot + thisOctal%ne(subcell)
        call getHeating(grid, thisOctal, subcell, hHeating, heHeating, dustHeating, totalHeating, epsOverDT)
        heating = heating + totalHeating
!        fac = thisOctal%nh(subcell) * returnAbundance(8) !* thisOctal%ionfrac(subcell,returnIonNumber("O I", grid%ion, grid%nIon))
        fac = 1.
        oirate = oirate + &
             fac*((epsOverDT / (v * 1.d30))*thisOctal%photoIonCoeff(subcell,returnIonNumber("O I", grid%ion, grid%nIon)))
        oiirate = oiirate + &
             fac*((epsOverDT / (v * 1.d30))*thisOctal%photoIonCoeff(subcell,returnIonNumber("O II", grid%ion, grid%nIon)))
        oiiirate = oiiirate + &
             fac*((epsOverDT / (v * 1.d30))*thisOctal%photoIonCoeff(subcell,returnIonNumber("O III", grid%ion, grid%nIon)))
!        oivrate = oivrate + &
!             fac*((epsOverDT / (v * 1.d30))*thisOctal%photoIonCoeff(subcell,returnIonNumber("O IV", grid%ion, grid%nIon)))

        t  = t + thisOctal%temperature(subcell)
     enddo


     hi = hi / 100.; hei = hei/100.; oii = oii/100; oiii = oiii/100.; cii=cii/100.
     ciii = ciii/100; civ=civ/100.; nii =nii/100.; niii=niii/100.; niv=niv/100.
     nei=nei/100.;neii=neii/100.; neiii=neiii/100.; neiv=neiv/100.;t=t/100.
     netot = netot / 100

     oirate = oirate / 100.
     oiirate = oiirate / 100.
     oiiirate = oiiirate / 100.
     oivrate = oivrate / 100.
     heating = heating / 100.
     cooling = cooling / 100.

     hi = log10(max(hi, 1e-10))
     hei = log10(max(hei, 1e-10))
     oii = log10(max(oii, 1e-10))
     oiii = log10(max(oiii, 1e-10))
     cii = log10(max(cii, 1e-10))
     ciii = log10(max(ciii, 1e-10))
     civ = log10(max(civ, 1e-10))
     nii = log10(max(nii, 1e-10))
     niii = log10(max(niii, 1e-10))
     niv= log10(max(niv, 1e-10))
     nei = log10(max(nei, 1e-10))
     neii = log10(max(neii, 1e-10))
     neiii = log10(max(neiii, 1e-10))
     neiv = log10(max(neiv, 1e-10))
     ne = log10(max(ne,1.d-10))


     write(21,'(f5.3,1p,6e12.3,0p)') r*1.e10/pctocm,heating,cooling,oirate,oiirate,oiiirate,oivrate

     write(20,'(f5.3,f9.1,  14f8.3)') &
          r*1.e10/pctocm,t,hi,hei,oii,oiii,cii,ciii,civ,nii,niii,niv,nei,neii,neiii,neiv
     write(22,*) r*1.e10/pctocm,netot
  enddo
  close(20)
  close(21)
  close(22)
end subroutine dumpLexington

subroutine getChargeExchangeRecomb(parentIon, temperature, nHI, nHII, recombRate)
  type(IONTYPE) :: parentIon
  real(double) :: nHI, nHII,  recombRate
  real :: t4, a, b, c, d
  real :: temperature

  recombRate  = 0.d0

  select case(parentIon%z)
     case(7)
        select case(parentIon%n)
           case(4) ! N IV
              t4 = temperature / 1.e4
              a = 3.05e-10
              b = 0.60
              c = 2.65
              d = -0.93
              recombRate  = kingdonFerland96(t4, a, b, c, d)
        end select
     case(8)
        select case(parentIon%n)
           case(7) ! O II
              t4 = temperature / 1.e4
              a = 1.04e-9
              b = 3.15e-2
              c = -0.61
              d = -9.73
              recombRate  = kingdonFerland96(t4, a, b, c, d)
           case(6) ! OIII
              t4 = temperature / 1.e4
              a = 1.04e-9
              b = 0.27
              c = 2.02
              d = -5.92
              recombRate  = kingdonFerland96(t4, a, b, c, d)
       end select
   end select

  recombRate = recombRate * nhi

end subroutine getChargeExchangeRecomb

subroutine getChargeExchangeIon(parentIon, temperature, nHI, nHII, IonRate)
  type(IONTYPE) :: parentIon
  real(double) :: nHI, nHII, ionRate
  real :: temperature
  real :: t4, a, b, c, d

  IonRate = 0.d0

  select case(parentIon%z)
     case(7)
        select case(parentIon%n)
           case(7) ! N I charge exchange Ionization
              t4 = temperature / 1.e4
              a = 4.55e-12
              b = -0.29
              c = -0.92
              d = -8.38
              ionRate  = kingdonFerland96(t4, a, b, c, d)
        end select
     case(8)
        select case(parentIon%n)
           case(8) ! O I charge exchange ionization
              t4 = temperature / 1.e4
              a = 7.40e-11
              b = 0.47
              c = 24.37
              d = -0.74
              ionRate  = kingdonFerland96(t4, a, b, c, d)
       end select
   end select

  ionRate = ionRate * nhii
end subroutine getChargeExchangeIon


function kingdonFerland96(t4, a, b, c, d) result (alpha)
  real :: alpha
  real :: t4, a, b, c, d
  alpha = a*(t4**b)*(1.+c*exp(d*t4))
end function kingdonFerland96
  

subroutine getCollisionalRates(thisIon, iTransition, temperature, excitation, deexcitation)
  real :: excitation, deexcitation
  type(IONTYPE) :: thisIon
  integer :: iTransition, i
  real :: temperature
  real :: thisGamma
  real :: t , fac
  real :: boltzFac

  t = max(min(real(thisIon%transition(iTransition)%t(thisIon%transition(iTransition)%ngamma)),temperature), &
       real(thisIon%transition(iTransition)%t(1)))
  call locate(thisIon%transition(iTransition)%t, thisIon%transition(iTransition)%ngamma, t, i)
  fac = (t - thisIon%transition(iTransition)%t(i))/(thisIon%transition(iTransition)%t(i+1) - thisIon%transition(iTransition)%t(i))
  thisGamma = thisIon%transition(iTransition)%gamma(i) + &
       fac * (thisIon%transition(iTransition)%gamma(i+1) - thisIon%transition(iTransition)%gamma(i))

  boltzFac =  exp(-thisIon%transition(iTransition)%energy / (kev*temperature))

  fac = (8.63e-6 / sqrt(temperature)) * thisGamma

  deexcitation =  fac / thisIon%level(thisIon%transition(iTransition)%j)%g

  excitation =  fac / thisIon%level(thisIon%transition(iTransition)%i)%g * boltzFac

!  excitation = fac * boltzFac
!  deexcitation = fac * thisIon%level(thisIon%transition(iTransition)%j)%g &
!       / thisIon%level(thisIon%transition(iTransition)%i)%g

!  if (thisIon%species == "O III") then
!     do i = 1, thisIon%transition(1)%ngamma
!        write(*,*) i,thisIon%transition(1)%t(i),thisIon%transition(1)%gamma(i)
!     enddo
!     if (iTransition ==1) then
!        write(*,*) thisGamma, boltzFac, fac, excitation, deexcitation
!     endif
!  endif


end subroutine getCollisionalRates


subroutine getForbiddenLineLuminosity(grid, species, wavelength, luminosity)
  type(GRIDTYPE) :: grid
  character(len=*) :: species
  real(double) :: wavelength
  real(double) :: fac
  real(double) :: luminosity
  integer :: iIon, iTrans, i

  iTrans = 0
  iIon = returnIonNumber(species, grid%ion, grid%nIon) 
  do i = 1, grid%ion(iIon)%nTransitions
     fac = grid%ion(iIon)%transition(i)%lambda
     fac = fac - wavelength
     fac = abs(fac)
     fac = fac / wavelength
     if (fac  < 0.001d0) then
        iTrans = i
        exit
     endif
  enddo
  if (iTrans == 0) then
     write(*,*) "No transition found at ",wavelength, "Angstroms"
     stop
  endif
  luminosity = 0.d0
  call sumLineLuminosity(grid%octreeroot, luminosity, iIon, iTrans, grid)
end subroutine getForbiddenLineLuminosity

recursive subroutine sumLineLuminosity(thisOctal, luminosity, iIon, iTrans, grid)
  type(GRIDTYPE) :: grid
  type(octal), pointer   :: thisOctal
  type(octal), pointer  :: child 
  integer :: subcell, i, iIon, iTrans
  real(double) :: luminosity, v, r1, r2, rate
  real :: pops(10)
  type(OCTALVECTOR) :: rvec
  
  do subcell = 1, thisOctal%maxChildren
       if (thisOctal%hasChild(subcell)) then
          ! find the child
          do i = 1, thisOctal%nChildren, 1
             if (thisOctal%indexChild(i) == subcell) then
                child => thisOctal%child(i)
                call sumLineLuminosity(child, luminosity, iIon, iTrans, grid)
                exit
             end if
          end do
       else
          rVec = subcellCentre(thisOctal,subcell)
          v = cellVolume(thisOctal, subcell)

          call solvePops(grid%ion(iIon), pops, thisOctal%ne(subcell), thisOctal%temperature(subcell), &
               thisOctal%ionFrac(subcell,iion),thisOctal%nh(subcell))
          rate =  pops(grid%ion(iion)%transition(iTrans)%j) * grid%ion(iion)%transition(itrans)%energy * &
               grid%ion(iion)%transition(itrans)%a/ergtoev
          rate = rate * grid%ion(iion)%abundance * thisOctal%nh(subcell) * thisOctal%ionFrac(subcell, iion)
          luminosity = luminosity + rate * v * 1.d30
          
       endif
    enddo
  end subroutine sumLineLuminosity


subroutine metalcoolingRate(ionArray, nIons, thisOctal, subcell, nh, ne, temperature, total, debug)
  type(IONTYPE) :: ionArray(*)
  integer :: nIons, subcell
  type(OCTAL) :: thisOctal
  real(double) :: ne, nh
  real :: temperature
  real(double) :: rate, total
  real :: pops(10)
  integer :: i, j
  logical, optional :: debug

  total = 0.d0
  do j = 5, nIons
     if (ionArray(j)%nTransitions > 0) then
        call solvePops(ionArray(j), pops, ne, temperature, thisOctal%ionFrac(subcell,j), thisOctal%nh(subcell))
        rate = 0.d0
        do i = 1, ionArray(j)%nTransitions
           rate = rate + pops(ionArray(j)%transition(i)%j)*ionArray(j)%transition(i)%energy*ionArray(j)%transition(i)%a/ergtoev
        enddo
        rate = rate * ionArray(j)%abundance * nh * thisOctal%ionFrac(subcell, j)
        if (rate < 0.) then
           write(100,'(a,a,a,1p,e12.4,a,0p, f10.1,a,1pe12.4)') "Negative contribution from ", &
                trim(ionArray(j)%species),":",rate," at T = ",temperature, &
                " ion frac ",thisOctal%ionFrac(subcell,j)
        endif
        if (present(debug)) then
           if (debug) then
                 write(100,'(a,a,a,1p,e12.4,a,0p, f10.1,a,1pe12.4)') "Contribution from ", &
                      trim(ionArray(j)%species),":",rate," at T = ",temperature, &
                      " ion frac ",thisOctal%ionFrac(subcell,j)
           endif
        endif
     total = total + rate
     endif
  enddo
end subroutine metalcoolingRate
  

subroutine solvePops(thisIon, pops, ne, temperature, ionFrac, nh, debug)
  type(IONTYPE) :: thisIon
  real(double) :: ne
  real :: pops(*)
  real :: temperature
  real(double), allocatable :: matrixA(:,:), MatrixB(:), tempMatrix(:,:), qeff(:,:),  rates(:)
  integer :: n, iTrans, i, j
  real :: excitation, deexcitation, rateij, rateji, arateji
  real(double) :: nh, ionFrac
  logical :: ok
  logical, optional :: debug

  n = thisIon%nLevels
  allocate(matrixA(1:n, 1:n), matrixB(1:n), tempMatrix(1:n,1:n), qeff(1:n,1:n), rates(1:n))

  matrixA = 1.d-30
  matrixB = 0.d0


  call getRecombs(rates, thision, dble(temperature), ne, ionFrac, nh)

  matrixA(1,:) = 1.d0
  matrixB(1) = 1.d0

  matrixB(2:n) = 0.d0 !rates(2:n) * ne * (nh * ionFrac * thisIon%abundance)
  do iTrans = 1, thisIon%nTransitions
     i = thision%transition(itrans)%i
     j = thision%Transition(itrans)%j
     call getCollisionalRates(thisIon, iTrans, temperature, excitation, deexcitation)
     qeff(i,j) = excitation
     qeff(j,i) = deexcitation
  enddo

  do i = 2, n
     do j = 1, n

        do iTrans = 1, thisIon%nTransitions
           if (((i == thision%transition(itrans)%i).and.(j == thision%Transition(itrans)%j)).or. &
               ((i == thision%transition(itrans)%j).and.(j == thision%Transition(itrans)%i))) then
              arateji =  thisIon%transition(iTrans)%a
              
              matrixA(i,j) = matrixA(i,j) + ne * qeff(j, i)
              matrixA(i,i) = matrixA(i,i) - ne * qeff(i, j)
              if (j > i) then
                 matrixA(i,j) = matrixA(i,j) + arateji
              else
                 matrixA(i,i) = matrixA(i,i) - arateji
              endif

           endif
        enddo

     enddo
  enddo

  tempMatrix = matrixA

  if (PRESENT(debug)) then
     if (debug) then
        do i = 1, n
           write(*,'(1p,9e12.3)') tempmatrix(i,1:n)
        enddo
     endif
  endif
  
  call luSlv(matrixA, matrixB, n)

  matrixB(1:n) = matrixB(1:n) / SUM(matrixB(1:n))
  
  ok = .true.

  if (.not.ok) then
     write(*,*) "Population solver failed for: ",thisIon%species
     write(*,*) matrixB(1:n)
     write(*,*) "nlevels",thisIon%nLevels,"ntrans",thisIon%nTransitions 
     write(*,*) "temp",temperature,"ne",ne
     
     do i = 1, n
        write(*,'(1p,9e12.3)') tempmatrix(i,1:n)
     enddo
     matrixB = 0.d0
     matrixB(1) = 1.d0
     write(*,*) "Setting pops to ground state"
  endif

  do i = 1, n
     pops(i) = max(1.d-30,matrixB(i))
  enddo

  deallocate(matrixA, matrixB, tempMatrix, qeff, rates)

end subroutine solvePops

subroutine calcHeRecombs(te, alpha1, alpha21s, alpha21p, alpha23s)
  real :: te, t
  real(double) :: alpha1, alpha21s, alpha21p, alpha23s

  t = te / 1.e4

  alpha1 = 1.54e-13 * t**(-0.486)

  alpha21s = 2.06e-14 * t**(-0.676)

  alpha21p = 4.17e-14 * t**(-0.861)
  
  alpha23s = 2.10e-13 * t**(-0.778)
end subroutine calcHeRecombs


subroutine createSahaMilneTables(hTable, heTable)
  type(SAHAMILNETABLE) :: hTable, heTable
  real(double) :: nu0_h, nu0_he, nufinal_h, nufinal_he
  integer :: nFreq, nTemp
  integer :: i, j
  real :: e
  real(double) :: t1, t2
  real :: hxsec, hexsec
  real(double) :: dfreq, jnu

  nFreq = 10000
  nTemp = 100
  hTable%nFreq = nFreq
  heTable%nFreq = nFreq
  hTable%nTemp = nTemp
  heTable%nTemp = nTemp

  allocate(hTable%freq(1:nFreq), heTable%freq(1:nFreq))
  allocate(hTable%emissivity(1:nTemp), heTable%emissivity(1:ntemp))
  allocate(hTable%temp(1:ntemp), heTable%temp(1:ntemp))
  allocate(hTable%Clyc(1:nTemp,1:nFreq))
  allocate(heTable%Clyc(1:nTemp,1:nFreq))

  nu0_h = 13.6d0/ergtoev/hcgs
  nu0_he = 24.59d0/ergtoev/hcgs

  nufinal_h = 2.d0*nu0_h
  nufinal_he = 2.d0*nu0_he

  do i = 1, nFreq
     hTable%freq(i) = log10(nu0_h) + (log10(nuFinal_h)-log10(nu0_h))*dble(i-1)/dble(nFreq-1)
     heTable%freq(i) = log10(nu0_he) + (log10(nuFinal_he)-log10(nu0_he))*dble(i-1)/dble(nFreq-1)
  enddo
  hTable%freq(1:hTable%nFreq) = 10.d0**hTable%freq(1:hTable%nfreq)
  heTable%freq(1:hTable%nFreq) = 10.d0**heTable%freq(1:hTable%nfreq)

  t1 = 5000.d0
  t2 = 20000.d0

  do i = 1, nTemp
     hTable%temp(i) = t1 + (t2-t1)*dble(i-1)/dble(nTemp-1)
     heTable%temp(i) = t1 + (t2-t1)*dble(i-1)/dble(nTemp-1)
  enddo

  do i = 1, nTemp
     hTable%Clyc(i,1) = 0.d0
     heTable%Clyc(i,1) = 0.d0
     do j = 2, nFreq


        e = hTable%freq(j) * hcgs* ergtoev
        call phfit2(1, 1, 1 , e , hxsec)

        dFreq = hTable%freq(j)-hTable%freq(j-1)
        jnu = ((hcgs*hTable%freq(j)**3)/(cSpeed**2)) * ((hcgs**2) /(twoPi*mElectron*Kerg*hTable%temp(i)))**(1.5d0) * &
             dble(hxsec/1.d10) *  exp(-hcgs*(hTable%freq(j)-nu0_h)/(kerg*hTable%temp(i)))
        hTable%Clyc(i,j) = hTable%Clyc(i,j-1) + jnu * dfreq


        e = heTable%freq(j) * hcgs * ergtoev
        call phfit2(2, 2, 1 , e , hexsec)

        dFreq = heTable%freq(j)-heTable%freq(j-1)
        jnu = 2.d0*((hcgs*heTable%freq(j)**3)/(cSpeed**2)) * ((hCgs**2) / (twoPi*mElectron*kerg*heTable%temp(i)))**(1.5d0) * &
             dble(hexsec/1.d10) * exp(-hcgs*(heTable%freq(j)-nu0_he)/(kerg*heTable%temp(i)))
        heTable%Clyc(i,j) = heTable%Clyc(i,j-1) + jnu * dfreq
     enddo
     hTable%emissivity(i) = hTable%Clyc(i,hTable%nFreq)
     heTable%emissivity(i) = heTable%Clyc(i,heTable%nFreq)
     hTable%Clyc(i,1:hTable%nFreq) = hTable%Clyc(i,1:hTable%nFreq) / hTable%Clyc(i,hTable%nFreq)
     heTable%Clyc(i,1:heTable%nFreq) = heTable%Clyc(i,1:heTable%nFreq) / heTable%Clyc(i,heTable%nFreq)
  end do

!  do j = 1, nFreq
!     write(99  ,*) htable%freq(j),htable%clyc(50,j)
!  enddo


end subroutine createSahaMilneTables

subroutine getSahaMilneFreq(table,temperature, thisFreq)
  type(SAHAMILNETABLE) :: table
  real(double) :: temperature, thisfreq, r, t, fac
  integer :: i, j

  t = max(5000.d0, min(20000.d0, temperature))
  call locate(table%temp, table%nTemp, t, i)
  call random_number(r)
  call locate(table%Clyc(i,1:table%nfreq), table%nFreq, r, j)
  fac = (r - table%Clyc(i,j))/(table%Clyc(i,j+1)-table%cLyc(i,j))
  thisFreq = table%freq(j) + fac * (table%freq(j+1)-table%freq(j))
end subroutine getSahaMilneFreq

subroutine twoPhotonContinuum(thisFreq)

! based on table ii of drake, victor, dalgarno, 1969, PhyRev Vol 180, pg 25

  real(double) :: thisFreq
  real :: y(21) = (/ 0., 0.025, 0.050, 0.075, 0.100, 0.125, 0.150, 0.175, 0.200, 0.225, 0.250, 0.275, 0.300, &
       0.325, 0.350, 0.375, 0.400, 0.425, 0.450, 0.475, 0.500 /)
  real :: hei(21) = (/ 0., 7.77e0, 2.52e1, 4.35e1, 5.99e1, 7.42e1, 8.64e1, 9.69e1, 1.06e2, 1.13e2, 1.20e2, 1.25e2, &
       1.30e2, 1.34e2, 1.37e2, 1.40e2, 1.42e2, 1.43e2, 1.45e2, 1.45e2, 1.45e2 /)
  real :: freq = 3.86e15, fac, r
  real :: prob(21)
  integer :: i
  prob(1) = 0.
  do i = 2, 21
     prob(i) = prob(i-1) + (y(i)-y(i-1)) * hei(i)
  enddo
  prob(1:21) = prob(1:21)/prob(21)
  thisFreq = 0.
  do while((thisFreq*hcgs*ergtoev) < 13.6)
     call random_number(r)
     call locate(prob, 21, r, i)
     fac = y(i) + ((r - prob(i))/(prob(i+1)-prob(i)))*(y(i+1)-y(i))
     thisFreq = (1.-fac)*freq
  enddo
end subroutine twoPhotonContinuum

subroutine getRecombs(rates, thision, temperature, ne, ionFrac, nh)  
  real(double) :: rates(:)
  type(IONTYPE) :: thisIon
  real(double) :: temperature, ne, ionfrac, nh

  select case(thisIon%species)
     case("O II")
        rates(1) = 0.d0
        rates(2) = rateFit(7.218d0, -0.575d0, temperature)
        rates(3) = rateFit(4.812d0, -0.575d0, temperature)
        rates(4) = rateFit(3.581d0, -0.495d0, temperature)
        rates(5) = rateFit(1.790d0, -0.495d0, temperature)
     case DEFAULT
        rates = 0.d0
   end select
 end subroutine getRecombs


subroutine getHeating(grid, thisOctal, subcell, hHeating, heHeating, dustHeating, totalHeating, epsOverDeltaT)
  type(GRIDTYPE) :: grid
  type(OCTAL) :: thisOctal
  integer :: subcell
  real(double) :: hHeating, heHeating, totalHeating, v, r1, r2, epsOverDeltaT, dustHeating
  type(OCTALVECTOR) :: rVec

  v = cellVolume(thisOctal, subcell)
  Hheating= thisOctal%nh(subcell) * thisOctal%ionFrac(subcell,1) * grid%ion(1)%abundance &
       * (epsOverDeltaT / (v * 1.d30))*thisOctal%Hheating(subcell) ! equation 21 of kenny's
  Heheating= thisOctal%nh(subcell) * thisOctal%ionFrac(subcell,3) * grid%ion(3)%abundance &
       * (epsOverDeltaT / (v * 1.d30))*thisOctal%Heheating(subcell) ! equation 21 of kenny's
  dustHeating = (epsOverDeltaT / (v * 1.d30))*thisOctal%distanceGrid(subcell) ! equation 14 of Lucy 1999
  totalHeating = (Hheating + HeHeating + dustHeating)
  
end subroutine getHeating

function rateFit(a,b,t) result (rate)
  real(double) :: a, b, t, rate

  rate = 1.d-13 * a * (t/1.d4)**b
end function rateFit

subroutine createRecombTable(table, tablefilename)
  type(RECOMBTABLE) :: table
  character(len=*) :: tablefilename
  character(len=200) :: filename, datadirectory
  integer :: ia, ib, ne, ncut, i
  real :: e(1000)

  call unixGetenv("TORUS_DATA", dataDirectory, i)
  filename = trim(dataDirectory)//"/"//tablefilename

  open(20,file=filename,status="old",form="formatted")
  read(20,*) table%nTemp, table%nrho

  allocate(table%rho(1:table%nRho))
  allocate(table%temp(1:table%ntemp))
  allocate(table%emissivity(1:table%ntemp,1:table%nrho))

  do ia=1,table%ntemp
     do ib=1,table%nrho
        read(20,'(1x,e10.3,5x,e10.3,13x,i2)') table%rho(ib),table%temp(ia),ncut
        ne=ncut*(ncut-1)/2
        read(20,'(8e10.3)') e(1:ne)
        table%emissivity(ia,ib) = SUM(e(1:ne-1))
     enddo
  enddo
  close(20)
end subroutine createRecombTable



  
subroutine createGammaTable(table, thisfilename)

! Ferland 1980 PASP 92 596

  type(GAMMATABLE) :: table
  character(len=*) :: thisfilename
  character(len=200) :: dataDirectory, filename
  integer :: i, j

  call unixGetenv("TORUS_DATA", dataDirectory, i)
  filename = trim(dataDirectory)//"/"//thisfilename

  open(40, file=filename, form="formatted", status="old")
  read(40,*) table%nTemp, table%nFreq

  allocate(table%freq(1:table%nFreq))
  allocate(table%temp(1:table%nTemp))
  allocate(table%gamma(table%nFreq, table%nTemp))

  table%temp = 0.d0
  read(40,*)  table%temp(1:table%nTemp)

  do i = 1, table%nFreq 
     read(40,*) table%freq(i), table%gamma(i,1:table%nTemp)
  enddo

  do i = 1, table%nFreq
     table%freq(i) = table%freq(i) * nuHydrogen
  enddo

  where (table%gamma(1:table%nFreq,1:table%nTemp) == 0.d0)
     table%gamma(1:table%nFreq,1:table%nTemp) = 1.d-10
  end where
  table%gamma(1:table%nFreq,1:table%nTemp) =log10(table%gamma(1:table%nFreq,1:table%nTemp))
  table%freq(1:table%nFreq) = log10(table%freq(1:table%nFreq))
  table%temp(1:table%nTemp) = log10(table%temp(1:table%nTemp))
  close(40)
end subroutine createGammaTable

real(double) function returnGamma(table, temp, freq) result(out)
  type(GAMMATABLE) :: table
  real(double) :: temp , freq
  integer :: i, j
  real(double) :: tfac, ffac, gamma1, gamma2

  call locate(table%temp, table%nTemp, log10(temp), i)
  call locate(table%freq, table%nFreq, log10(freq), j)

  if (log10(freq) >= table%freq(1)) then
     tfac  = (log10(temp) - table%temp(i))/(table%temp(i+1) - table%temp(i))
     ffac  = (log10(freq) - table%freq(j))/(table%freq(j+1) - table%freq(j))
     
     gamma1 = table%gamma(j,i) + tfac*(table%gamma(j, i+1) - table%gamma(j,i))
     gamma2 = table%gamma(j+1,i) + tfac*(table%gamma(j+1, i+1) - table%gamma(j+1,i))
     out = gamma1 + ffac*(gamma2 - gamma1)
     out = 10.d0**out
  else
     out = tiny(out)
  endif


end function returnGamma

subroutine addLymanContinua(nFreq, freq, spectrum, thisOctal, subcell, grid)
  type(GRIDTYPE) :: grid
  TYPE(OCTAL) :: thisOctal
  integer :: subcell
  integer :: nFreq
  integer :: i, j, k, iIon, n1, n2
  real(double) :: freq(:), spectrum(:)
  real(double) :: nu0_h, nu0_he, jnu, dfreq
  real :: e, hxsec, hexsec
  real(double), parameter :: statisticalWeight(3) = (/ 2.d0, 0.5d0, 2.d0 /)


  ! do Saha-Milne continua for H, HeI and HeII

  do k = 1 , 2 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

     if (k == 1) iIon = 1
     if (k == 2) iIon = 3
     if (k == 3) iIon = 4

     call locate(freq, nfreq, grid%ion(iIon)%nuThresh, n1)
     n2 = nFreq
     if (iIon == 3) then
        call locate(freq, nfreq, grid%ion(iIon+1)%nuThresh, n2)
     endif
     do i = n1, n2
        dFreq = freq(i) - freq(i-1)
        
        e = freq(i) * hcgs* ergtoev


        call phfit2(grid%ion(iIon)%z, grid%ion(iIon)%n, grid%ion(iIon)%outerShell , e , hxsec)
        

        jnu = statisticalWeight(k) * ((hcgs*freq(i)**3)/(cSpeed**2)) * &
             ((hcgs**2) /(twoPi*mElectron*Kerg*thisOctal%temperature(subcell)))**(1.5d0) * &
             dble(hxsec/1.d10) *  exp(-hcgs*(freq(i)-grid%ion(iIon)%nuThresh)/(kerg*thisOctal%temperature(subcell)))
        jnu = jnu * thisOctal%ne(subcell) *(thisOctal%nh(subcell) * thisOctal%ionFrac(subcell,iIon+1) * grid%ion(iIon)%abundance)

        spectrum(i) = spectrum(i) + jnu * dFreq * fourPi 
     enddo
  enddo

end subroutine addLymanContinua


subroutine addHigherContinua(nfreq, freq, spectrum, thisOctal, subcell, grid, table)

! Ferland 1980 PASP 92 596

  type(GAMMATABLE) :: table(3)
  integer :: nFreq
  real(double) :: spectrum(:), freq(:)
  type(OCTAL) :: thisOctal
  integer :: subcell
  type(GRIDTYPE) :: grid
  integer :: i, k, iEnd, iIon
  real(double) :: fac

  do k = 1 , 3

     if (k == 1) iIon = 1
     if (k == 2) iIon = 3
     if (k == 3) iIon = 4

     call locate(freq, nFreq, grid%ion(iIon)%nuThresh, iEnd)
     do i = 2, iEnd
        fac = returnGamma(table(k), dble(thisOctal%temperature(subcell)) , freq(i))
        fac = fac*1.d-40 ! units of 10^-40 erg/s/cm/cm/cm
        fac = fac * thisOctal%ne(subcell) * thisOctal%nh(subcell) &
             * thisOctal%ionFrac(subcell,iIon+1) * grid%ion(iIon)%abundance
        spectrum(i) = spectrum(i) + fac*(freq(i)-freq(i-1))
     enddo
  enddo

end subroutine addHigherContinua



subroutine addHydrogenRecombinationLines(nfreq, freq, spectrum, thisOctal, subcell, grid)


  integer :: nFreq
  real(double) :: spectrum(:), freq(:)
  type(OCTAL) :: thisOctal
  integer :: subcell
  type(GRIDTYPE) :: grid
  real :: emissivity(3:15,2:8)
  integer :: ilow, iup
  real(double) :: lymanalpha, hBeta, LineEmissivity, lineFreq, energy
  integer :: i

  emissivity(3, 2:8) = (/ 0.156E-01, 0.541E-02, 0.266E-02, 0.154E-02, 0.974E-03, 0.657E-03, 0.465E-03 /)
  emissivity(4, 2:8) = (/ 0.192E-01, 0.666E-02, 0.328E-02, 0.190E-02, 0.120E-02, 0.811E-03, 0.573E-03 /)
  emissivity(5, 2:8) = (/ 0.240E-01, 0.832E-02, 0.411E-02, 0.237E-02, 0.151E-02, 0.102E-02, 0.719E-03 /)
  emissivity(6, 2:8) = (/ 0.305E-01, 0.106E-01, 0.524E-02, 0.303E-02, 0.193E-02, 0.130E-02, 0.917E-03 /)
  emissivity(7, 2:8) = (/ 0.397E-01, 0.138E-01, 0.683E-02, 0.396E-02, 0.252E-02, 0.170E-02, 0.119E-02 /)
  emissivity(8, 2:8) = (/ 0.530E-01, 0.184E-01, 0.914E-02, 0.531E-02, 0.338E-02, 0.228E-02, 0.158E-02 /)
  emissivity(9, 2:8) = (/ 0.731E-01, 0.254E-01, 0.127E-01, 0.737E-02, 0.469E-02, 0.312E-02, 0.204E-02 /)
  emissivity(10,2:8) = (/ 0.105E+00, 0.366E-01, 0.183E-01, 0.107E-01, 0.673E-02, 0.425E-02, 0.000E+00 /)
  emissivity(11,2:8) = (/ 0.159E+00, 0.555E-01, 0.278E-01, 0.162E-01, 0.976E-02, 0.000E+00, 0.000E+00 /)
  emissivity(12,2:8) = (/ 0.259E+00, 0.904E-01, 0.455E-01, 0.255E-01, 0.000E+00, 0.000E+00, 0.000E+00 /)
  emissivity(13,2:8) = (/ 0.468E+00, 0.163E+00, 0.802E-01, 0.000E+00, 0.000E+00, 0.000E+00, 0.000E+00 /)
  emissivity(14,2:8) = (/ 0.100E+01, 0.339E+00, 0.000E+00, 0.000E+00, 0.000E+00, 0.000E+00, 0.000E+00 /)
  emissivity(15,2:8) = (/ 0.286E+01, 0.000E+00, 0.000E+00, 0.000E+00, 0.000E+00, 0.000E+00, 0.000E+00 /)


  Hbeta = 10.d0**(-0.870d0*log10(thisOctal%temperature(subcell)) + 3.57d0)
  Hbeta = Hbeta * thisOctal%ne(subcell) *  thisOctal%nh(subcell) * &
       thisOctal%ionFrac(subcell, 2) * grid%ion(1)%abundance

  ! calculate emission due to HI recombination lines [e-25 ergs/s/cm^3]
  do iup = 15, 3, -1
     do ilow = 2, min0(8, iup-1)
        lineEmissivity = emissivity(iup, ilow) * Hbeta * 1.e-25
        energy = (hydE0eV / dble(iLow**2))-(hydE0eV / dble(iUp**2))
        lineFreq = (energy / ergtoev)/hCgs
        call locate(freq, nFreq, lineFreq, i)
        spectrum(i) = spectrum(i) + lineEmissivity
     end do
  end do

  LymanAlpha = 10.d0**(-0.897*log10(thisOctal%temperature(subcell)) + 5.05d0) * &
       thisOctal%ne(subcell) *(thisOctal%nh(subcell) * thisOctal%ionFrac(subcell,2) * &
       grid%ion(1)%abundance) * 1.d-25
  lineFreq = cSpeed/1215.67D-8
  call locate(freq, nFreq, lineFreq, i)
  spectrum(i) = spectrum(i) + lymanAlpha
  

end subroutine addHydrogenRecombinationLines

real(double) function getPhotonFreq(nfreq, freq, spectrum) result(Photonfreq)
  integer :: nFreq
  real(double) :: freq(:), spectrum(:), fac, r
  real(double), allocatable :: tSpec(:)
  integer :: i

  allocate(tSpec(1:nFreq))
  
  tSpec(1:nFreq) = spectrum(1:nFreq)

  do i = 2, nFreq
     tSpec(i) = tSpec(i) + tSpec(i-1)
  enddo
  tSpec(1:nFreq) = tSpec(1:nFreq) - tSpec(1)
  if (tSpec(nFreq) > 0.d0) then
     tSpec(1:nFreq) = tSpec(1:nFreq) / tSpec(nFreq)
     call random_number(r)
     call locate(tSpec, nFreq, r, i)
     fac = (r - tSpec(i)) / (tSpec(i+1)-tSpec(i))
     photonFreq = freq(i) + fac * (freq(i+1)-freq(i))
  else
     photonFreq = cSpeed / (1.d-8 * 100.e4)
  endif
end function getPhotonFreq


subroutine addForbiddenLines(nfreq, freq, spectrum, thisOctal, subcell, grid)

  integer :: nFreq
  real(double) :: spectrum(:), freq(:)
  type(OCTAL) :: thisOctal
  integer :: subcell
  type(GRIDTYPE) :: grid
  integer :: iIon, iTrans, j
  real :: pops(10)
  real(double) :: rate, lineFreq


  do iIon = 3, grid%nIon
     do iTrans = 1, grid%ion(iIon)%nTransitions
        call solvePops(grid%ion(iIon), pops, thisOctal%ne(subcell), thisOctal%temperature(subcell), &
             thisOctal%ionFrac(subcell,iion),thisOctal%nh(subcell))
        rate =  pops(grid%ion(iion)%transition(iTrans)%j) * grid%ion(iion)%transition(itrans)%energy * &
             grid%ion(iion)%transition(itrans)%a/ergtoev
        rate = rate * grid%ion(iion)%abundance * thisOctal%nh(subcell) * thisOctal%ionFrac(subcell, iion)
        lineFreq  =  (grid%ion(iion)%transition(itrans)%energy / ergtoEV) / hCgs
        call locate(freq, nFreq, lineFreq, j)
        spectrum(j) = spectrum(j) + rate
     enddo
  enddo

end subroutine addForbiddenLines
  

subroutine addHeRecombinationLines(nfreq, freq, spectrum, thisOctal, subcell, grid)

  integer :: nFreq
  real(double) :: spectrum(:), freq(:)
  type(OCTAL) :: thisOctal
  integer :: subcell
  type(GRIDTYPE) :: grid
  integer :: i, j, k
  real :: fac, t, aj ,bj, cj
  real(double) :: lineFreq, lambda
  real :: emissivity
  real :: heII4686
  integer :: ilow, iup
  integer,parameter :: nHeIILyman = 4
  real(double) :: heIILyman(4)
  real(double) :: freqheIILyman(4) = (/ 3.839530, 3.749542, 3.555121, 2.99963 /)



  ! HeI lines 

  call locate(heIrecombinationNe, 3, real(log10(thisOctal%ne(subcell))), i)
  fac = (log10(thisOctal%ne(subcell)) - heIrecombinationNe(i))/(heIrecombinationNe(i+1)-heIrecombinationNe(i))

  do j = 1, 32
     aj = heIrecombinationFit(j,i,1) + fac*(heIrecombinationfit(j,i+1,1)-heIrecombinationfit(j,i,1))
     bj = heIrecombinationFit(j,i,2) + fac*(heIrecombinationfit(j,i+1,2)-heIrecombinationfit(j,i,2))
     cj = heIrecombinationFit(j,i,3) + fac*(heIrecombinationfit(j,i+1,3)-heIrecombinationfit(j,i,3))
     t = thisOctal%temperature(subcell)/1.e4
     emissivity = aj * (t**bj) * exp(cj / t) ! Benjamin et al. 1999 ApJ 514 307
     emissivity = emissivity * thisOctal%ne(subcell) * thisOctal%nh(subcell) * &
          thisOctal%ionFrac(subcell, 3) * grid%ion(3)%abundance
     lineFreq = cspeed / (heiRecombinationLambda(j)*1.e-8)
     call locate(freq, nFreq, lineFreq, k)
     spectrum(k) = spectrum(k) + emissivity
  enddo
!

!  HeII4686 = 10.d0**(-0.997d0*log10(thisOctal%temperature(subcell))+5.16d0)
!  HeII4686 = HeII4686*thisOctal%ne(subcell)*thisOctal%nh(subcell)*thisOctal%ionFrac(subcell,5)*grid%ion(4)%abundance
!  
!  ! calculate emission due to HeII recombination lines [e-25 ergs/s/cm^3]                                                     
!  do iup = 30, 3, -1
!     do ilow = 2, min0(16, iup-1)
!        emissivity= HeIIrecombinationLines(iup, ilow)*HeII4686*1.d-25
!
!
!        lambda = 227.838 / (1./real(ilow**2)  - 1./real(iup**2))!!!!!!!!!!!!!!!!!!!
!        lineFreq = cSpeed/(lambda * 1.d-8)
!
!     call locate(freq, nFreq, lineFreq, k)
!     spectrum(k) = spectrum(k) + emissivity
!     end do
!  end do
!

  ! He II Lyman series

!  heIILyman(1:4) = (/ 0.0334, 0.0682, 0.1849, 1. /)

!  ! calculate Lyman alpha first
!  HeIILyman(4) = 10.d0**(-0.792d0*log10(thisOctal%temperature(subcell))+6.01d0)
!  HeIILyman(4) = HeIILyman(4)*thisOctal%ne(subcell)*thisOctal%nh(subcell) * &
!       grid%ion(3)%abundance * thisOctal%ionFrac(subcell, 5) * 1.d-25
!
!  do i = 1, NHeIILyman-1
!     HeIILyman(i) = HeIILyman(i)*HeIILyman(4)
!  end do
!  do i = 1, nHeIILyman
!     lineFreq = freqHeIILyman(i) * nuHydrogen
!     call locate(freq, nFreq, lineFreq, k)
!     spectrum(k) = spectrum(k) + HeIILyman(i)
!  enddo



end subroutine addHeRecombinationLines

subroutine addDustContinuum(nfreq, freq, spectrum, thisOctal, subcell, grid, nlambda, lamArray)

  integer :: nFreq
  real(double) :: spectrum(:), freq(:)
  type(OCTAL), pointer :: thisOctal
  integer :: subcell
  type(GRIDTYPE) :: grid
  integer :: nLambda
  real :: lamArray(:)
  integer :: i, iLam
  real :: lambda, thisLam
  real(double) :: dFreq
  type(OCTALVECTOR) :: octVec
  real(double), allocatable :: kabsArray(:)


  allocate(kAbsArray(1:nlambda))

  call returnKappa(grid, thisOctal, subcell, kappaAbsArray=kAbsArray)


  do i = 2, nFreq
     thisLam = (cSpeed / freq(i)) * 1.e8
     dFreq = freq(i) - freq(i-1)
     call hunt(lamArray, nLambda, real(thisLam), iLam)
     if ((ilam >=1).and.(ilam <= nlambda)) then

        spectrum(i) = spectrum(i) + bnu(freq(i), dble(thisOctal%temperature(subcell))) * kAbsArray(iLam) *1.d-10* dFreq * fourPi

     endif
  enddo

  deallocate(kAbsArray)

end subroutine addDustContinuum








subroutine readHeIRecombinationLinesFit()
  character(len=200) :: filename, datadirectory
  integer :: i

  call unixGetenv("TORUS_DATA", dataDirectory, i)
  filename = trim(dataDirectory)//"/"//"bss1999.dat"

  open(40,file=filename,status="old",form="formatted")
  do i = 1, 32
     read(40, *) HeIRecombinationLambda(i), heIRecombinationFit(i,1,1:3), &
           heIRecombinationFit(i,2,1:3),  heIRecombinationFit(i,3,1:3)
  enddo
  close(40)
!  HeiRecombinationFit(1:32, 1:3, 1:3) = log10(HeiRecombinationFit(1:32, 1:3, 1:3))
  heIrecombinationNe(1) = 2.
  heIrecombinationNe(2) = 4.
  heIrecombinationNe(3) = 6.
end subroutine readHeIRecombinationLinesFit


subroutine readHeIIrecombination()
  character(len=200) :: filename, datadirectory
  integer :: iup, ilow, i


  call unixGetenv("TORUS_DATA", dataDirectory, i)
  filename = trim(dataDirectory)//"/"//"r2b0100.dat"

  open(40,file=filename,status="old",form="formatted")
  
  ! read in HeII recombination lines [e-25 ergs*cm^3/s]                                                                      
  ! (Storey and Hummer MNRAS 272(1995)41)                                                                                    
  open(40, file=filename, status = "old",form="formatted")
  do iup = 30, 3, -1
     read(40,*) (HeIIRecombinationLines(iup, ilow), ilow = 2, min0(16, iup-1))
  end do
  close(40)
end subroutine readHeIIrecombination

!$MPI  subroutine updateGridMPI(grid)
!$MPI    implicit none
!$MPI    include 'mpif.h'
!$MPI    type(gridtype) :: grid
!$MPI    integer :: nOctals, nVoxels, i
!$MPI    real, allocatable :: nCrossings(:)
!$MPI    real, allocatable :: tempRealArray(:)
!$MPI    real(double), allocatable :: hHeating(:), heHeating(:)
!$MPI    real(double), allocatable :: photoIonCoeff(:,:)
!$MPI    real(double), allocatable :: tempDoubleArray(:)
!$MPI    real(double), allocatable :: distanceGrid(:)
!$MPI    integer :: np, ierr,my_rank, nIndex
!$MPI
!$MPI    ! FOR MPI IMPLEMENTATION=======================================================
!$MPI    !  Get my process rank # 
!$MPI    call MPI_COMM_RANK(MPI_COMM_WORLD, my_rank, ierr)
!$MPI  
!$MPI    ! Find the total # of precessor being used in this run
!$MPI    call MPI_COMM_SIZE(MPI_COMM_WORLD, np, ierr)
!$MPI
!$MPI    call MPI_BARRIER(MPI_COMM_WORLD, ierr) 
!$MPI    nOctals = 0
!$MPI    nVoxels = 0
!$MPI    call countVoxels(grid%octreeRoot,nOctals,nVoxels)
!$MPI    allocate(nCrossings(1:nVoxels))
!$MPI    allocate(hHeating(1:nVoxels))
!$MPI    allocate(heHeating(1:nVoxels))
!$MPI    allocate(distanceGrid(1:nVoxels))
!$MPI    allocate(photoIonCoeff(1:nVoxels, 1:grid%nIon))
!$MPI
!$MPI    nIndex = 0
!$MPI    call packValues(grid%octreeRoot,nIndex,nCrossings, photoIonCoeff, hHeating, HeHeating, distanceGrid)
!$MPI
!$MPI
!$MPI    allocate(tempDoubleArray(nVoxels))
!$MPI    allocate(tempRealArray(nVoxels))
!$MPI
!$MPI    do i = 1, grid%nIon
!$MPI      tempDoubleArray = 0.d0
!$MPI      call MPI_ALLREDUCE(photoIonCoeff(1:nVoxels,i),tempDoubleArray,nVoxels,MPI_DOUBLE_PRECISION,&
!$MPI          MPI_SUM,MPI_COMM_WORLD,ierr)
!$MPI       photoIonCoeff(1:nVoxels, i) = tempDoubleArray 
!$MPI    enddo
!$MPI
!$MPI    tempDoubleArray = 0.0
!$MPI    call MPI_ALLREDUCE(hHeating,tempDoubleArray,nVoxels,MPI_DOUBLE_PRECISION,&
!$MPI         MPI_SUM,MPI_COMM_WORLD,ierr)
!$MPI    hHeating = tempDoubleArray
!$MPI
!$MPI    tempDoubleArray = 0.0
!$MPI    call MPI_ALLREDUCE(heHeating,tempDoubleArray,nVoxels,MPI_DOUBLE_PRECISION,&
!$MPI         MPI_SUM,MPI_COMM_WORLD,ierr)
!$MPI    heHeating = tempDoubleArray
!$MPI
!$MPI    tempRealArray = 0.0
!$MPI    call MPI_ALLREDUCE(nCrossings,tempRealArray,nVoxels,MPI_REAL,&
!$MPI         MPI_SUM,MPI_COMM_WORLD,ierr)
!$MPI    nCrossings = tempRealArray 
!$MPI
!$MPI    tempDoublelArray = 0.0
!$MPI    call MPI_ALLREDUCE(distanceGrid,tempRealArray,nVoxels,MPI_DOUBLE_PRECISION,&
!$MPI         MPI_SUM,MPI_COMM_WORLD,ierr)
!$MPI    distanceGrid = tempRealArray 
!$MPI    
!$MPI    deallocate(tempRealArray, tempDoubleArray)
!$MPI     
!$MPI    call MPI_BARRIER(MPI_COMM_WORLD, ierr) 
!$MPI    
!$MPI    nIndex = 0
!$MPI    call unpackValues(grid%octreeRoot, nIndex,nCrossings, photoIonCoeff, hHeating, HeHeating, distanceGrid)
!$MPI
!$MPI    deallocate(nCrossings, photoIonCoeff, hHeating, heHeating, distanceGrid)
!$MPI
!$MPI  end subroutine updateGridMPI

  recursive subroutine packvalues(thisOctal,nIndex,nCrossings, photoIonCoeff, hHeating, HeHeating, distanceGrid)
  type(octal), pointer   :: thisOctal
  type(octal), pointer  :: child 
  real :: nCrossings(:)
  real(double) :: photoIonCoeff(:,:)
  real(double) :: hHeating(:)
  real(double) :: heHeating(:)
  real(double) :: distanceGrid(:)

  integer :: nIndex
  integer :: subcell, i
  
  do subcell = 1, thisOctal%maxChildren
       if (thisOctal%hasChild(subcell)) then
          ! find the child
          do i = 1, thisOctal%nChildren, 1
             if (thisOctal%indexChild(i) == subcell) then
                child => thisOctal%child(i)
                call packvalues(child, nIndex,nCrossings, photoIonCoeff, hHeating, HeHeating, distanceGrid)
                exit
             end if
          end do
       else
          nIndex = nIndex + 1
          nCrossings(nIndex) = real(thisOctal%nCrossings(subcell))
          photoIonCoeff(nIndex, :) = thisOctal%photoIonCoeff(subcell, :)
          hHeating(nIndex) = thisOctal%hHeating(subcell)
          heHeating(nIndex) = thisOctal%heHeating(subcell)
          distanceGrid(nIndex) = thisOctal%distanceGrid(subcell)
       endif
    enddo
  end subroutine packvalues

  recursive subroutine unpackvalues(thisOctal,nIndex,nCrossings, photoIonCoeff, hHeating, HeHeating, distanceGrid)
  type(octal), pointer   :: thisOctal
  type(octal), pointer  :: child 
  real :: nCrossings(:)
  real(double) :: photoIonCoeff(:,:)
  real(double) :: hHeating(:)
  real(double) :: heHeating(:)
  real(double) :: distanceGrid(:)

  integer :: nIndex
  integer :: subcell, i
  
  do subcell = 1, thisOctal%maxChildren
       if (thisOctal%hasChild(subcell)) then
          ! find the child
          do i = 1, thisOctal%nChildren, 1
             if (thisOctal%indexChild(i) == subcell) then
                child => thisOctal%child(i)
                call unpackvalues(child, nIndex,nCrossings, photoIonCoeff, hHeating, HeHeating, distanceGrid)
                exit
             end if
          end do
       else
          nIndex = nIndex + 1
          thisOctal%nCrossings(subcell) = int(nCrossings(nIndex))
          thisOctal%photoIonCoeff(subcell, :) = photoIonCoeff(nIndex, :)
          thisOctal%hHeating(subcell) = hHeating(nIndex) 
          thisOctal%heHeating(subcell) = heHeating(nIndex) 
          thisOctal%distanceGrid(subcell) = distanceGrid(nIndex) 
       endif
    enddo
  end subroutine unpackvalues

  recursive subroutine  identifyUndersampled(thisOctal)
    use input_variables, only : minCrossings
    type(octal), pointer   :: thisOctal
    type(octal), pointer  :: child 
    integer :: subcell, i
  
  do subcell = 1, thisOctal%maxChildren
       if (thisOctal%hasChild(subcell)) then
          ! find the child
          do i = 1, thisOctal%nChildren, 1
             if (thisOctal%indexChild(i) == subcell) then
                child => thisOctal%child(i)
                call identifyUndersampled(child)
                exit
             end if
          end do
       else
          if (thisOctal%nCrossings(subcell) < minCrossings) then
             thisOctal%undersampled(subcell) = .true.
          else
             thisOctal%undersampled(subcell) = .false.
          endif
       endif
    enddo
  end subroutine identifyUndersampled

  recursive subroutine  calcContinuumEmissivity(grid, thisOctal, nfreq, freq, spectrum, nlambda, lamArray)
    type(GRIDTYPE) :: grid
    integer :: nFreq
    real(double) :: freq(:), spectrum(:)
    integer :: nLambda
    real :: lamArray(:)
    type(octal), pointer   :: thisOctal
    type(octal), pointer  :: child 
    integer :: subcell, i
  
  do subcell = 1, thisOctal%maxChildren
       if (thisOctal%hasChild(subcell)) then
          ! find the child
          do i = 1, thisOctal%nChildren, 1
             if (thisOctal%indexChild(i) == subcell) then
                child => thisOctal%child(i)
                call calcContinuumEmissivity(grid, child, nfreq, freq, spectrum, nlambda, lamArray)
                exit
             end if
          end do
       else
          spectrum = 1.d-30
          thisOctal%etaCont(subcell) = 1.d-40
          if (thisOctal%temperature(subcell) > 1.5d0) then
             call addLymanContinua(nFreq, freq, spectrum, thisOctal, subcell, grid)
             call addHigherContinua(nfreq, freq, spectrum, thisOctal, subcell, grid, GammaTableArray)
             call addHydrogenRecombinationLines(nfreq, freq, spectrum, thisOctal, subcell, grid)
             !         call addHeRecombinationLines(nfreq, freq, spectrum, thisOctal, subcell, grid)
             call addForbiddenLines(nfreq, freq, spectrum, thisOctal, subcell, grid)
             call addDustContinuum(nfreq, freq, spectrum, thisOctal, subcell, grid, nlambda, lamArray)
             
             do i = 1, nFreq
                thisOctal%etaCont(subcell) = thisOctal%etaCont(subcell) + spectrum(i)
             enddo
          endif

       endif
    enddo
  end subroutine calcContinuumEmissivity


  function getRandomWavelengthPhotoion(grid, thisOctal, subcell, lamArray, nLambda) result(thisLambda)

    type(GRIDTYPE) :: grid
    type(OCTAL), pointer :: thisOctal
    integer :: subcell
    real :: thisLambda
    integer :: nFreq
    real(double), allocatable :: freq(:), spectrum(:), tspec(:),lamspec(:)
    real(double) :: nuStart, nuEnd, thisFreq, r, fac
    integer :: nLambda
    real :: lamArray(:)
    integer :: i

    nFreq = 1000

    allocate(freq(1:nFreq), spectrum(1:nFreq), lamSpec(1:nFreq))
    nuStart = cSpeed / (1000.d4 * 1.d-8)
    nuEnd =  2.d0*maxval(grid%ion(1:grid%nIon)%nuThresh)

    do i = 1, nFreq
       freq(i) = log10(nuStart) + dble(i-1)/dble(nFreq-1) * (log10(nuEnd)-log10(nuStart))
       freq(i) = 10.d0**freq(i)
    enddo

    spectrum = 1.d-30

    call addLymanContinua(nFreq, freq, spectrum, thisOctal, subcell, grid)
    call addHigherContinua(nfreq, freq, spectrum, thisOctal, subcell, grid, GammaTableArray)
    call addHydrogenRecombinationLines(nfreq, freq, spectrum, thisOctal, subcell, grid)
    !                        call addHeRecombinationLines(nfreq, freq, spectrum, thisOctal, subcell, grid)
    call addForbiddenLines(nfreq, freq, spectrum, thisOctal, subcell, grid)
    call addDustContinuum(nfreq, freq, spectrum, thisOctal, subcell, grid, nlambda, lamArray)
    

    do i = 1, nFreq
       lamSpec(i) = cspeed/freq(i)
       spectrum(i) = spectrum(i) * cspeed/(lamspec(i)**2)
    enddo
    lamSpec = lamSpec * 1.d8

    allocate(tSpec(1:nFreq))
  
    tSpec(1:nFreq) = spectrum(1:nFreq)

    do i = 2, nFreq
       tSpec(i) = tSpec(i) + tSpec(i-1)
    enddo
    tSpec(1:nFreq) = tSpec(1:nFreq) - tSpec(1)
    if (tSpec(nFreq) > 0.d0) then
       tSpec(1:nFreq) = tSpec(1:nFreq) / tSpec(nFreq)
       call random_number(r)
       call locate(tSpec, nFreq, r, i)
       fac = (r - tSpec(i)) / (tSpec(i+1)-tSpec(i))
       thisLambda = lamspec(i) + fac * (lamspec(i+1)-lamspec(i))
    else
       thisLambda = 1000.e4
  endif
    
  deallocate(freq, spectrum, lamSpec)

  end function getRandomWavelengthPhotoion

  subroutine getWavelengthBiasPhotoion(grid, thisOctal, subcell, lamArray, nLambda, ilambda, bias)

    type(GRIDTYPE) :: grid
    type(OCTAL), pointer :: thisOctal
    integer :: subcell
    real :: thisLambda
    integer :: nFreq
    real(double), allocatable :: freq(:), spectrum(:), tspec(:),lamspec(:)
    real(double) :: nuStart, nuEnd, thisFreq, r, fac
    integer :: nLambda
    real :: lamArray(:)
    real :: bias
    integer :: ilambda
    integer :: i

    nFreq = nlambda

    allocate(freq(1:nFreq), spectrum(1:nFreq), lamSpec(1:nFreq), tSpec(1:nFreq))

    do i = 1, nFreq
       freq(i) = cSpeed/(lamArray(nFreq-i+1)*1.e-8)
    enddo

    spectrum = 1.d-30

    call addLymanContinua(nFreq, freq, spectrum, thisOctal, subcell, grid)
    call addHigherContinua(nfreq, freq, spectrum, thisOctal, subcell, grid, GammaTableArray)
    call addHydrogenRecombinationLines(nfreq, freq, spectrum, thisOctal, subcell, grid)
    !                        call addHeRecombinationLines(nfreq, freq, spectrum, thisOctal, subcell, grid)
    call addForbiddenLines(nfreq, freq, spectrum, thisOctal, subcell, grid)
    call addDustContinuum(nfreq, freq, spectrum, thisOctal, subcell, grid, nlambda, lamArray)
    

    do i = 1, nFreq
       lamSpec(i) = cspeed/freq(i)
       spectrum(i) = spectrum(i) * cspeed/(lamspec(i)**2)
    enddo
    lamSpec = lamSpec * 1.d8

    do i = 1, nFreq
       tSpec(i) = spectrum(nFreq-i+1)
    enddo
    spectrum(1:nFreq) = tspec

    do i = 1, nFreq
       tSpec(i) = lamSpec(nFreq-i+1)
    enddo
    lamSpec(1:nFreq) = tspec

    fac = 0.d0
    do i = 2, nFreq
       fac = fac + spectrum(i)*(lamSpec(i)-lamSpec(i-1))
    enddo
    bias = spectrum(iLambda)/fac


    deallocate(freq, spectrum, lamSpec, tSpec)

  end subroutine getWavelengthBiasPhotoion

  subroutine refineLambdaArray(lamArray, nLambda, grid)
    type(GRIDTYPE) :: grid
    real :: lamArray(:)
    integer :: nLambda
    integer :: i, j
    real hLines(15)



    hLines = (/ 1215.67, 1025.72, 992.537, 949.743, 937.803, 6562.80, &
         4861.32, 4340.36, 4101.73, 18751.0, 12818.1, 10938.1, &
         40512.0, 26252.0, 74578.0/)
    do i = 1, 15
       call insertBin(lamArray, nLambda, hLines(i), 1.)
    enddo


! refine for forbidden line transitions

    do i = 1 , grid%nIon
       do j = 1, grid%ion(i)%nTransitions
          call insertBin(lamArray, nLambda, &
               real(grid%ion(i)%transition(j)%lambda), 1.)
       enddo
    enddo
  end subroutine refineLambdaArray

end module


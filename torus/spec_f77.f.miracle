

C
C ********************************************************************
C
      SUBROUTINE WRTSP(NPTS,STOKES_I,STOKES_Q,STOKES_QV,STOKES_U,
     &                 STOKES_UV,LAMBDA,FILENAME)
C
C This routine reads in a polarization spectrum from a TSP format file
C and puts it into the 'current' arrays
C
      IMPLICIT NONE
      INTEGER OUT_LU
c      INCLUDE '/star/include/sae_par'
c      INCLUDE '/star/include/dat_par'
C
C The current arrays
C
      INTEGER NPTS
      REAL STOKES_I(*)
      REAL STOKES_Q(*)
      REAL STOKES_QV(*)
      REAL STOKES_U(*)
      REAL STOKES_UV(*)
      REAL LAMBDA(*)
C
C Misc.
C
c      INTEGER SP
c      INTEGER NDF
c      CHARACTER*(*) CPARAM
      CHARACTER*80 PATH,FILENAME
c      CHARACTER*64 NAME
c      CHARACTER*80 ERROR
c      INTEGER UBND(1),LBND(1),NDFO,OAXISP,NDFQ,NDFU,QPTR
c      INTEGER DIMS(10)
c      INTEGER NDIMS
c      INTEGER UPTR,QVPTR,UVPTR,PLACE
c      INTEGER NELM,PTR1,NDF1,NDF2,NDF3,IPTR
c      INTEGER PTRQ,PTRQV,PTRU,PTRUV,APTR
c      CHARACTER*(DAT__SZLOC) PLOC,DLOC,QLOC,LOC      
c      INTEGER STATUS
cC
c      STATUS = SAI__OK
c      LBND(1) = 1
c      UBND(1) = NPTS
cC
cC Begin the ndf and hds systems
cC
c      CALL NDF_BEGIN
c      CALL HDS_START(STATUS)
cC
cC Create a new tsp ndf and map it
cC
c      CALL HDS_NEW(FILENAME,'OUTPUT','NDF',0,0,LOC,STATUS)
c      CALL DAT_NEW(LOC,'DATA_ARRAY','_REAL',1,UBND,STATUS)
c      CALL NDF_IMPRT(LOC,NDFO,STATUS)
c      CALL NDF_ACRE(NDFO,STATUS)
c      CALL NDF_ACPUT('Wavelength',NDFO,'Lab',1,STATUS)
c      CALL NDF_ACPUT('Angstroms',NDFO,'Unit',1,STATUS)
c      CALL NDF_AMAP(NDFO,'Centre',1,'_REAL','UPDATE',OAXISP,UBND,STATUS)
c
c      CALL NDF_XNEW(NDFO,'POLARIMETRY','EXT',0,0,PLOC,STATUS)
c      CALL NDF_PLACE(PLOC,'STOKES_Q',PLACE,STATUS)
c      CALL NDF_NEW('_REAL',1,LBND,UBND,PLACE,NDFQ,STATUS)
c      CALL NDF_PLACE(PLOC,'STOKES_U',PLACE,STATUS)
c      CALL NDF_NEW('_REAL',1,LBND,UBND,PLACE,NDFU,STATUS)
c
c      CALL NDF_MAP(NDFO,'DATA','_REAL','WRITE',IPTR,UBND,STATUS)
c      CALL NDF_MAP(NDFQ,'DATA','_REAL','WRITE',QPTR,UBND,STATUS)
c      CALL NDF_MAP(NDFU,'DATA','_REAL','WRITE',UPTR,UBND,STATUS)
c      CALL NDF_MAP(NDFQ,'VARIANCE','_REAL','WRITE',QVPTR,UBND,STATUS)
c      CALL NDF_MAP(NDFU,'VARIANCE','_REAL','WRITE',UVPTR,UBND,STATUS)
cC
cC If everything is oK then write out the arrays
cC
c      IF (STATUS.EQ.SAI__OK) THEN
c      CALL WRITE_IT(NPTS,LAMBDA,STOKES_I,STOKES_Q,STOKES_QV,STOKES_U,
c     &              STOKES_UV,
c     &UBND(1),%VAL(IPTR),%VAL(QPTR),%VAL(QVPTR),%VAL(UPTR),
c     &%VAL(UVPTR),%VAL(OAXISP))
c      ENDIF
cC
cC Close down the ndf and hds
cC
c      CALL DAT_ANNUL(PLOC,STATUS)
c      CALL NDF_END(STATUS)
c      CALL HDS_CLOSE(LOC,STATUS)
c      CALL HDS_STOP(STATUS)
      END


C
C ********************************************************************
C

      SUBROUTINE WRITE_IT(NPTS,LAMBDA,STOKES_I,STOKES_Q,STOKES_QV,
     &STOKES_U,STOKES_UV,N,IAR,Q,QV,U,UV,WA)
C
C Writes out the array mapped previously
C
      INTEGER NPTS
      REAL STOKES_I(*)
      REAL STOKES_Q(*)
      REAL STOKES_QV(*)
      REAL STOKES_U(*)
      REAL STOKES_UV(*)
      REAL LAMBDA(*)
      INTEGER STATUS,N,I
      CHARACTER*80 INFILE
      REAL Q(N),U(N),QV(N),UV(N),WA(N),IAR(N)

      DO I = 1,N
       IAR(I) = STOKES_I(I)
       WA(I) = LAMBDA(I)
       Q(I) = STOKES_Q(I)
       QV(I) = STOKES_QV(I)
       U(I) = STOKES_U(I)
       UV(I) = STOKES_UV(I)
      ENDDO
      END


! this module solves the vertical density structure of a disc
! by repeated calls to the lucy algorithm and iteratively solving the
! equation of hydrostatic equilibrium

! written by tjh

! v1.0 on 16/3/04

module disc_hydro_mod

  use input_variables
  use gridtype_mod
  use kind_mod
  use constants_mod
  use vector_mod
  use utils_mod
  use octal_mod
  use amr_mod
  use density_mod
  use source_mod
  use phasematrix_mod
  use lucy_mod

  implicit none

  public

contains
  
  subroutine solveHydro(temperature, zAxis, subcellsize, rho, nz, &
       radius, mStar, sigma0, rDisk, converged, drho)

    use input_variables, only: alphaDisc, betaDisc, rinner, geometry
    integer, intent(in) :: nz ! number of vertical grid points
    real(double),intent(in) :: subcellSize(1:nz)  ! size of this subcell
    real(single),intent(in) :: temperature(1:nz)  ! temperature
    real(double),intent(inout) :: rho(1:nz)         ! density
    real(double),intent(in) :: zAxis(1:nz)       ! z grid
    real :: mStar, rDisk                      ! stellar mass, disk mass and radius
    real :: radius, radiusAU ! radius at disc midplane
    real :: sigma0                                   ! surface density at rinner
    integer :: i
    real ::  smoothscalelength
    logical :: converged
    real :: mu ! mean molecular weight
    real, allocatable :: oldRho(:)
    real :: dz
    real :: fac, fac2
    real(double) :: scalefac
    real(double), allocatable :: lnrho(:), doubleRho(:)
    real :: dtdz ! temperature gradient
    real(double) :: sigma
    real :: drho
    real :: av

    mu = 2.3 ! mean mole mass assuming pure H_2/He
    radiusAU = (radius * 1.e10) / autocm


    allocate(oldRho(1:nz), lnrho(1:nz),doubleRho(1:nz))
    oldRho(1:nz) = rho(1:nz)

    converged = .false.

    lnrho(1) = 0.
    do i = 2, nz
       dz = (zAxis(i)-zAxis(i-1))
       dTdz = (temperature(i)-temperature(i-1))/dz
       fac = (mu * mHydrogen * bigG * mStar * zAxis(i)/ (kErg * radius**3))/1.e30
       fac2 = -1.d0*(dTdz + fac)/temperature(i)
       lnrho(i) = lnrho(i-1) + fac2 * dz
    enddo

    ! now integrate over the column to get the surface density
    ! 

    doublerho(1:nz) = exp(lnrho(1:nz))


    sigma = 0.
    do i = 1,nz
       sigma = sigma + doublerho(i) * dble(subcellSize(i)) * 1.d10
    enddo

    ! rescale the density to retain the 1/r surface density fall-off

    scalefac = 0.5 * (sigma0*(autocm/(radius*1.e10))) / sigma ! factor of 0.5 cos only integrating over half disc vertically
    
    fac =  1.d0-min(dble(radius - rInner)/(0.01d0*rinner),1.d0)
    fac = exp(-fac*10.d0)


    scalefac = 0.5 * (sigma0 * fac * (radius*1.e10/autoCm)**(betaDisc-alphaDisc)) / sigma

    if (geometry == "ppdisk") then
       smoothScaleLength = height * rHeight * (rSmooth/rHeight)**flaringPower
       scalefac = fractgap(dble(radiusAU)) / (1. + 81.d0**(dble(rSmooth-radiusAU)/smoothScaleLength)) &
            * (rHeight/radiusAU)**sigmaPower / sigma
       scalefac = scalefac * 0.5 * rho0 * Msol / autocm**2
    endif


!    scalefac = fractgap(dble(radiusAU)) / (sqrt(radiusAU) * (1 + exp(-100.*(radiusAU-rSmooth))) * sigma)
!    scalefac = scalefac * 0.5 * rho0 * Msol / autocm**2

!    write(*,*) radius, sigma0, sigma, &
!	0.5 * (sigma0 * (radius*1.e10/autoCm)**(betaDisc-alphaDisc)), scalefac

    rho(1:nz) = doublerho(1:nz) * scalefac

    ! now check for convergence. maximum fractional change in
    ! density should be less than 1%.

    do i = 1, nz
       if (oldRho(i) /= 0.) then
          drho = max(drho, abs(real(rho(i))-oldrho(i)))
       endif
    enddo

    deallocate(oldRho, doublerho)
  end subroutine solveHydro


  subroutine getTemperatureDensityRun(grid, zAxis, subcellsize, rho, temperature, xPos, yPos, nz, direction)
    type(GRIDTYPE) :: grid
    type(octal), pointer   :: thisOctal
    integer :: nz
    real(double) :: rho(:)
    real :: temperature(:)
    real(double) :: zAxis(:), subcellsize(:)
    real :: xPos, yPos
    integer :: subcell
    real(double) :: rhotemp	
    real :: temptemp
    real :: direction
    type(OCTALVECTOR) :: currentPos, temp
    real :: halfSmallestSubcell

    nz = 0
    halfSmallestSubcell = grid%halfSmallestSubcell

    currentPos = OCTALVECTOR(xPos, yPos, direction*halfSmallestSubcell)

    do while(abs(currentPos%z) < grid%ocTreeRoot%subcellsize)
       call amrGridValues(grid%octreeRoot, currentPos, foundOctal=thisOctal, &
            foundSubcell=subcell, rho=rhotemp, temperature=temptemp)
       thisOctal%chiLine(subcell) = 1.e-30
!       if (thisOctal%inFlow(subcell)) then
          nz = nz + 1
          temperature(nz) = temptemp
          rho(nz) = rhotemp
          temp = subCellCentre(thisOctal, subcell)
          zAxis(nz) = temp%z
          subcellsize(nz) = thisOctal%subcellsize
!       endif
          currentPos = OCTALVECTOR(xPos, yPos, zAxis(nz)+0.5*direction*thisOctal%subcellsize+direction*halfSmallestSubcell)
!       else
!          currentPos = OCTALVECTOR(xPos, yPos, grid%octreeRoot%subcellsize+halfSmallestSubcell)
!       endif
    end do
    zAxis(1:nz) = abs(zAxis(1:nz)) * 1.d10  ! convert to cm
  end subroutine getTemperatureDensityRun

  subroutine putDensityRun(grid, zAxis, rho, nz, xPos, yPos, direction)
    type(GRIDTYPE) :: grid
    type(octal), pointer   :: thisOctal
    integer :: nz
    real :: xPos, yPos
    real(double) :: zAxis(:)
    real(double) :: rho(:)
    integer :: i, subcell
    real :: direction
    type(octalvector) :: currentPos
    
    do i = 1, nz
       currentPos = OCTALVECTOR(xPos, yPos, direction*zAxis(i)/1.d10)
       call amrGridValues(grid%octreeRoot, currentPos, foundOctal=thisOctal, &
            foundSubcell=subcell)
! original code moved to realPutDensity
!          if (thisOctal%rho(subcell) > 1.e-30) then
!             thisOctal%rho(subcell) = rho(i)
!             thisOctal%inFlow(subcell) = .true. 
!          else
!             thisOctal%inFlow(subcell) = .false.
!          endif
          thisOctal%chiLine(subcell) = rho(i)
    enddo
  end subroutine putDensityRun

  recursive subroutine realPutDensity(grid, thisOctal)

    type(GRIDTYPE) :: grid
    type(octal), pointer   :: thisOctal
    type(octal), pointer  :: child
    real(double) :: deltaRho
    integer :: subcell, i

    do subcell = 1, thisOctal%maxChildren
       if (thisOctal%hasChild(subcell)) then
          ! find the child
          do i = 1, thisOctal%nChildren, 1
             if (thisOctal%indexChild(i) == subcell) then
                child => thisOctal%child(i)
                call realPutDensity(grid, child)
                exit
             end if
          end do
       else
          if (thisOctal%chiLine(subcell) > 1.e-30) then
!             deltaRho = thisOctal%chiLine(subcell) - thisOctal%rho(subcell)
!             thisOctal%rho(subcell) = thisOctal%rho(subcell) + 0.5d0 *deltaRho
             thisOctal%rho(subcell) = thisOctal%chiLine(subcell)
!             thisOctal%inFlow(subcell) = .true. 
          else
!             thisOctal%rho(subcell) = thisOctal%chiLine(subcell)
             thisOctal%rho(subcell) = 1.e-30
!             thisOctal%inFlow(subcell) = .false.
          endif
       end if
    end do

  end subroutine realPutDensity

  subroutine throughoutMidpane(grid, mStar, sigma0, rDisk, drho)

    type(GRIDTYPE) :: grid
    real(double) :: zAxis(10000)
    real(double) :: rho(10000)
    real :: temperature(10000)
    real(double) :: subcellsize(10000)
    real :: mStar, sigma0, rDisk
    integer :: nz
    real :: xpos, ypos, radius, drho, smallestSubcell
    logical :: converged 
    real(double) :: xAxis(1000000)
    integer :: nx, i

    nx = 0
    call getxValues(grid%octreeRoot,nx,xAxis)
    call stripSimilarValues(xAxis,nx,1.d-5*grid%halfSmallestSubcell)
    xAxis(1:nx) = xAxis(1:nx) + 1.d-5*grid%halfSmallestSubcell

    xPos = grid%halfSmallestSubcell - grid%octreeRoot%subcellSize
    smallestSubcell = 2. * grid%halfSmallestSubcell
    



  if (grid%octreeRoot%twod) then
    xPos = grid%halfSmallestSubcell
    yPos = 0.
!    do while (xPos < (2.* grid%octreeRoot%subcellSize))
!       radius = xPos
!

    do i = 1, nx
       radius = xAxis(i)
       xPos = xAxis(i)
       if ((radius > grid%rInner).and.(radius < grid%rOuter)) then
          call getTemperatureDensityRun(grid, zAxis, subcellsize, rho, temperature, xPos, yPos, nz, +1.)

          if (nz > 1) then
             call solveHydro(temperature, zAxis, subcellsize, rho, nz, radius, mStar, &
                  sigma0, rDisk, converged, drho)                

             call putDensityRun(grid, zAxis, rho, nz, xPos, yPos, +1.)
          endif

          call getTemperatureDensityRun(grid, zAxis, subcellsize, rho, temperature, xPos, yPos, nz, -1.)

          if (nz > 1) then
             call solveHydro(temperature, zAxis, subcellsize, rho, nz, radius, mStar, sigma0, rDisk, converged, drho)
             
             call putDensityRun(grid, zAxis, rho, nz, xPos, yPos, -1.)
          endif
       endif
!       xPos = xPos + smallestSubcell
!    end do
    enddo
  else if (grid%octreeRoot%threed) then
    do while (xPos < grid%octreeRoot%subcellSize)
       yPos = grid%halfSmallestSubcell - grid%octreeRoot%subcellSize
       do while (yPos < grid%octreeRoot%subcellSize)
          radius = sqrt(xPos**2 + yPos**2)
          if ((radius > grid%rInner).and.(radius < grid%rOuter)) then
             call getTemperatureDensityRun(grid, zAxis, subcellsize, rho, temperature, xPos, yPos, nz, +1.)

             if (nz > 1) then
                call solveHydro(temperature, zAxis, subcellsize, rho, &
                     nz, radius, mStar, sigma0, rDisk, converged, drho)                

                call putDensityRun(grid, zAxis, rho, nz, xPos, yPos, +1.)
             endif

             call getTemperatureDensityRun(grid, zAxis, subcellsize, rho, temperature, xPos, yPos, nz, -1.)

             if (nz > 1) then
                call solveHydro(temperature, zAxis, subcellsize, rho, &
                     nz, radius, mStar, sigma0, rDisk, converged, drho)
             
                call putDensityRun(grid, zAxis, rho, nz, xPos, yPos, -1.)
             endif
          endif
          yPos = yPos + smallestSubcell
       enddo
       xPos = xPos + smallestSubcell
    enddo
   end if
  end subroutine throughoutMidpane

  subroutine verticalHydrostatic(grid, mStar, sigma0, rDisk, miePhase, nDustType, nMuMie, nLambda, lamArray, &
       source, nSource, nLucy, massEnvelope, tThresh, twoD, expectedMass)

!$MPI include 'mpif.h'


    type(GRIDTYPE) :: grid
    real :: mStar, sigma0, rDisk, expectedMass, scaleFac
    integer :: nDustType
    logical :: converged
    type(SOURCETYPE) :: source(:)
    integer :: nSource
    integer :: nLucy
    integer :: nLambda, nMuMie
    type(PHASEMATRIX):: miePhase(1:nDusttype,1:nLambda, 1:nMuMie)
    real  :: lamArray(:)
    real :: massEnvelope
    real :: tthresh, drho
    integer :: maxIter
    integer :: nIter, j, ilamsmooth
    character(len=20) :: plotfile
    real(double) totalMass
    logical :: twoD, gridConverged
    real :: temp

!$MPI    ! For MPI implementations
!$MPI    integer       ::   my_rank        ! my processor rank
!$MPI    integer       ::   ierr           ! error flag
!$MPI
!$MPI
!$MPI    ! FOR MPI IMPLEMENTATION=======================================================
!$MPI    !  Get my process rank # 
!$MPI    call MPI_COMM_RANK(MPI_COMM_WORLD, my_rank, ierr)




    converged = .false.
    nIter = 1
    totalMass = 0.
    call findTotalMass(grid%octreeRoot, totalMass)


!$MPI    if(my_rank == 0) &
    write(*,*) "Total disc mass: ",totalMass/msol," solar masses"


!$MPI    if(my_rank == 0) then
    write(plotfile,'(a,i3.3,a)') "rho",0,".gif/gif"
    call plot_AMR_values(grid, "rho", "x-z", 0.0, plotfile, .true., .false.,boxfac=0.01)
!$MPI    endif

    do while(.not.converged)
    
!$MPI    if(my_rank == 0) then
       write(*,*) "Starting iteration number",nIter
       write(*,*) "Calling the lucy algorithm to get temperature..."
!$MPI    endif

       totalMass = 0.
       call findTotalMass(grid%octreeRoot, totalMass)


!$MPI    print *,'Process ',my_rank,' waiting to do lucy.'
!$MPI    call MPI_BARRIER(MPI_COMM_WORLD, ierr) 

       if (nIter == 1) then
          maxIter = 2
       else
          maxIter = 2
       endif

       call lucyRadiativeEquilibriumAMR(grid, miePhase, nDustType, nMuMie, & 
            nLambda, lamArray, source, nSource, nLucy, massEnvelope, tthresh, lucy_undersampled, twoD, maxIter)



!$MPI    if(my_rank == 0) &
       write(*,*) "Zeroing new density values..."
       call zeroChiline(grid%octreeRoot)       

!$MPI    if(my_rank == 0) &
       write(*,*) "Solving the vertical hydrostatic equilibrium..."
       drho = 0.
       call throughoutMidpane(grid, mStar, sigma0, rDisk, drho)

!$MPI    if(my_rank == 0) &
       write(*,*) "Updating cell densities..."
       call realPutDensity(grid, grid%octreeRoot)

!$MPI    if(my_rank == 0) &
       write(*,*) "Maximum absolute change in density: ",drho

       totalMass = 0.
       call findTotalMass(grid%octreeRoot, totalMass)
       write(*,*) "Total disc mass: ",totalMass/msol," solar masses"




!$MPI    if(my_rank == 0) then
       write(plotfile,'(a,i3.3,a)') "rho",niter,".gif/gif"
       call plot_AMR_values(grid, "rho", "x-z", 0.0, plotfile, .true., .false., boxfac=0.01)
       write(plotfile,'(a,i3.3,a)') "temp",niter,".gif/gif"
       call plot_AMR_values(grid, "temperature", "x-z", 0.0, plotfile, .true., .false.)
!       write(plotfile,'(a,i3.3,a)') "tau",niter,".gif/gif"
!       call plot_AMR_values(grid, "tau", "x-z", 0.0, plotfile, .true., .false.) !problem with passing ilam
!$MPI    endif

       ! chris (26/05/04)
       ! Smooth the grid with respect to optical depth, if requested


       call locate(grid%lamArray, grid%nLambda,lambdasmooth,ilamsmooth)

!       if (.false.) then
       if (doSmoothGridTau) then

!       write(*,*) "Tau smoothing switched off"
!	if (.true.) then
!$MPI     if(my_rank == 0) &
          write(*,*) "Smoothing adaptive grid structure for optical depth..."
!$MPI     if(my_rank == 0) &
          call plot_AMR_values(grid, "rho", "x-z", 0.0, "rho_before.ps/vcps", .true., .false., boxfac=0.005)

          do j = ilamsmooth, ilamsmooth !grid%nlambda
             do
                gridConverged = .true.
                call smoothAMRgridTau(grid%octreeRoot,grid,gridConverged,j,inheritprops = .false., interpProps = .true.)
                if (gridConverged) exit
             end do
          enddo
!$MPI     if(my_rank == 0) &
          write(*,*) "...grid smoothing complete"
          ! The tau smoothing may result in large differences in the size
          ! of neighbouring octals, so we smooth the grid again.
          if (doSmoothGrid) then
!$MPI     if(my_rank == 0) &
            write(*,*) "Smoothing adaptive grid structure (again)..."
            call smoothAMRgrid(grid,smoothFactor, inheritProps=.false., interpProps=.true.)
!$MPI     if(my_rank == 0) &
            write(*,*) "...grid smoothing complete"
          end if

!$MPI     if(my_rank == 0) &
          call plot_AMR_values(grid, "rho", "x-z", 0.0, "rho_after.ps/vcps", .true., .false., boxfac=0.005)

       end if



       nIter = nIter + 1

       if (nIter > nHydro) then
!$MPI    if(my_rank == 0) &
          write(*,*) "Maximum number of iterations exceeded. Aborting."
          converged = .true.
       else
          write(*,*) "calling set temperature..."
          temp = 20.
          call setTemperature(grid%octreeRoot, temp)
          write(*,*) "done."
       endif
       
    enddo

  end subroutine verticalHydrostatic

  recursive subroutine getxValues(thisOctal, nx, xAxis)

    type(octal), pointer   :: thisOctal
    type(octal), pointer  :: child
    type(octalvector) :: rVec
    integer :: nx, subcell, i
    real(double) :: xAxis(:)

    do subcell = 1, thisOctal%maxChildren
       if (thisOctal%hasChild(subcell)) then
          ! find the child
          do i = 1, thisOctal%nChildren, 1
             if (thisOctal%indexChild(i) == subcell) then
                child => thisOctal%child(i)
                call getxValues(child, nx, xAxis)
                exit
             end if
          end do
       else

          rVec = subcellCentre(thisOctal, subcell)
          nx = nx + 1
          xAxis(nx) = rVec%x
       end if
    end do

  end subroutine getxValues

  recursive subroutine setTemperature(thisOctal, temperature)

    use input_variables, only : rinner, router
    type(octal), pointer   :: thisOctal
    type(octal), pointer  :: child
    real :: temperature
    type(octalvector) :: rvec
    integer :: subcell, i

    do subcell = 1, thisOctal%maxChildren
       if (thisOctal%hasChild(subcell)) then
          ! find the child
          do i = 1, thisOctal%nChildren, 1
             if (thisOctal%indexChild(i) == subcell) then
                child => thisOctal%child(i)
                call setTemperature(child, temperature)
                exit
             end if
          end do
       else
          rVec = subcellCentre(thisOctal,subcell)
          if ((rVec%x > rinner).and.(rVec%x< rOuter)) then
             thisOctal%temperature(subcell) = temperature
          endif
       end if
    end do

  end subroutine setTemperature

  recursive subroutine zeroChiline(thisOctal)
  type(octal), pointer   :: thisOctal
  type(octal), pointer  :: child 
  integer :: subcell, i
  
  do subcell = 1, thisOctal%maxChildren
       if (thisOctal%hasChild(subcell)) then
          ! find the child
          do i = 1, thisOctal%nChildren, 1
             if (thisOctal%indexChild(i) == subcell) then
                child => thisOctal%child(i)
                call zeroChiline(child)
                exit
             end if
          end do
       else
          thisOctal%chiline(subcell) = tiny(thisOctal%chiline(subcell))
       endif
    enddo
  end subroutine zerochiline


end module disc_hydro_mod


!
!             T   O   R   U  S
!
! torus is a general purpose monte-carlo radiative transfer code used to
! produce polarized spectra of hot and cool stellar winds
!

! written by tjh

! v1.0 on 16/09/99

! raman scattering stuff added 3/3/2000

! OMP parallelization calls added 1/7/2001

! TJH: 19/7/02  Jorick's spotty star stuff added
! NHS: 02/9/02  adaptive mesh code merged
! RK : 12/02/03 Parallelized major loops in lucyStateEquilibriumAMR, stateqAMR, torusMain.


program torus

  use constants_mod          ! physical constants
  use kind_mod               ! variable type KIND parameters
  use vector_mod             ! vector math
  use photon_mod             ! photon manipulation
  use gridtype_mod           ! type definition for the 3-d grid
  use grid_mod               ! opacity grid routines
  use phasematrix_mod        ! phase matrices and stokes vectors
  use math_mod               ! misc maths subroutines
  use blob_mod               ! clumps initialization and movement
  use distortion_mod         ! for distorting opacity grid
  use image_mod              ! stokes image
  use utils_mod
  use stateq_mod
  use inputs_mod
  use TTauri_mod
  use unix_mod
  use path_integral
  use puls_mod
  use input_variables         ! variables filled by inputs subroutine
  use lucy_mod
  use amr_mod
  use jets_mod
  use dust_mod
  use source_mod
  use spectrum_mod
  use wr104_mod
  use sph_data_class
  use cluster_class
  use timing
  use isochrone_class
  use filter_set_class
  use cluster_utils
  use disc_hydro_mod
  use gaussian_mod

  implicit none

!$MPI  include 'mpif.h'

  integer, parameter :: nOuterLoop = 10
  integer :: iOuterLoop
  integer :: nScat
  integer :: cpuTime, startTime
  integer :: nSource
  type(SOURCETYPE), allocatable :: source(:)
  type(SOURCETYPE) a_star
  real(kind=doubleKind) :: lCore
  real ::  weightDust=1.0, weightPhoto=1.0
  

  real(kind=doubleKind) :: energyPerPhoton
  real(kind=doubleKind) :: objectDistance

  ! variables for the grid


  type(GRIDTYPE) :: grid

  integer :: error
  integer :: iPhase
  real(kind=doubleKind) :: totLineEmission
  real(kind=doubleKind) :: totContinuumEmission
  real(kind=doubleKind) :: totCoreContinuumEmission
  real(kind=doubleKind) :: totCoreContinuumEmission1
  real(kind=doubleKind) :: totCoreContinuumEmission2
  real(kind=doubleKind) :: totWindContinuumEmission
  real :: probLinePhoton 
  real :: weightContPhoton, weightLinePhoton
  real :: chanceLine, chanceContinuum
  real :: sTot
  ! optical depth variables

  integer, parameter :: maxTau = 10000, maxLambda = 500
  integer :: nTau
  real, allocatable :: contTau(:,:)
!  real :: contTau(maxTau,maxLambda)


  real :: scaleFac, ang, z, dz

!  real :: tauExt(maxTau)
!  real :: tauAbs(maxTau)
!  real :: tauSca(maxTau)
!  real :: lambda(maxTau)
  real, allocatable :: tauExt(:)
  real, allocatable :: tauAbs(:)
  real, allocatable :: tauSca(:)
  real, allocatable :: lambda(:)

  real, allocatable :: mReal(:), mImg(:)          ! size = nlambda
  real, allocatable :: mReal2D(:,:), mImg2D(:,:)  ! size = ngrain x nlambda
  real :: total_dust_abundance


  real, allocatable :: kappaAbs(:), kappaSca(:), kappaExt(:)
  real :: dlambda, thisTau

  ! variables to do with dust

  real :: xMin, xMax
  integer, parameter :: nXmie = 20, nMuMie = 20
  type(PHASEMATRIX),allocatable :: miePhase(:, :)
  real :: particleMass, abundance, expectedMass

  ! torus images

  type(IMAGETYPE) :: o6image(1)
  type(octalvector) :: imageCentre
  type(IMAGETYPE), allocatable :: obsImageSet(:)
  integer           :: nImage  ! number of images in obsImageSet
  type(filter_set)  :: filters ! a set of filters used for imaging
  character(LEN=30) :: name_filter
  real(kind=doublekind) :: bandwidth   ! Band width of a filter[A]
  real(kind=doublekind) :: lambda_eff  ! Effective wavelength of a filter[A]

  type(PVIMAGETYPE), allocatable :: pvimage(:)
  real :: imageSize
  integer :: iSlit
  type(VECTOR) :: slitPosition

  ! intrinsic profile variables

  integer, parameter :: maxIntPro = 1000
  integer :: nIntPro, iSpline
  real :: lamIntPro(maxIntPro), intPro(maxIntPro)
  real, allocatable :: splineArray(:)

  real, allocatable :: lamArray(:)
  real, allocatable :: statArray(:)
  real, allocatable :: sourceSpectrum(:)
  real, allocatable :: sourceSpectrum2(:)



  ! variables for clumped wind models
  

  integer, parameter :: maxBlobs = 10000
  integer :: nCurrent
    type(BLOBTYPE), allocatable :: blobs(:)
  real, parameter :: blobTime = 40000.
  real :: timeEnd = 20.*24.*60.*60.
  real :: timeStart = 0.
  real :: dTime, thisTime

  ! filenames

  character(len=80) :: filename, specFile

  ! photons

  type(PHOTON) :: thisPhoton
  type(PHOTON) :: outPhoton
  type(PHOTON) :: obsPhoton
  type(PHOTON) :: tempPhoton

  ! vectors

  type(VECTOR), parameter :: zAxis = VECTOR(0.,0.,1.)
  type(VECTOR), parameter :: yAxis = VECTOR(0.,1.,0.)
  type(VECTOR), parameter :: xAxis = VECTOR(1.,0.,0.)
  type(VECTOR) :: viewVec, outVec, thisVec, originalViewVec
  type(VECTOR) :: rotationAxis, normToRotation
  type(VECTOR) :: zeroVec, tempVec
  type(OCTALVECTOR) :: rHat, rVec, rHatinStar


  ! output arrays

  integer :: iLambda, itestLam, iSmoothLam
  type(STOKESVECTOR), allocatable :: yArray(:)
  type(STOKESVECTOR), allocatable :: errorArray(:,:)
  real, allocatable :: xArray(:), dx(:)
  real, allocatable :: contWeightArray(:)
!  real :: contWeightArray(maxTau)
  type(STOKESVECTOR) :: tot

  ! model flags

  logical :: escaped, absorbed
  logical :: rotateView
  logical :: tiltView = .false.
  logical :: flatSpec
  logical :: ok
  logical :: greyContinuum
  logical :: hitCore
  logical :: firstPlot

  ! model parameters

  real :: vel
  real :: nuStart, nuEnd

  ! single dust blob parameters (WR137 type model)

  real :: meanDustParticleMass, getMeanMass2


  real :: foreground = 0., background = 0.  ! plotting intensities
  real :: mu
  real(kind=octalkind) :: t1, t2, t3
  real :: junk1


  ! raman scattering model parameters

  logical :: thruStar
  type(VECTOR) :: hotSourcePosition, coolStarPosition
  type(VECTOR) :: ramanSourceVelocity

  ! O VI spectrum stuff

  character(len=80) :: o6filename
  integer, parameter :: no6pts = 100
  real, parameter :: o6start = 1031.5, o6end=1032.8
  real :: o6xarray(no6pts), o6yarray(no6pts)


  ! misc

  real :: rotateDirection
  real :: meanr_line = 0., meanr_cont = 0.
  real :: wtot_line =0., wtot_cont = 0.
  real :: meanr0_line = 0., meanr0_cont = 0.
  real :: wtot0_line =0., wtot0_cont = 0.
  real :: junk
  character(len=80) :: plotFile

  real :: thisChi, thisSca, albedo
  logical :: normalizeSpectrum
  integer :: currentScat
  logical :: redRegion
  real :: r
  logical :: contWindPhoton
  real :: ramanWeight
  real :: thisVel
  real :: fac1, fac2, fac3
  real :: vRay, vOverCsqr
  real :: directionalWeight
  real :: weight
  real :: r1, r2
  real(kind=octalkind) :: t
  integer :: i, j, k, n
  integer :: i1,i2,i3
  integer :: nTot  
  real :: observedLambda
  real :: thisLam
  real :: nu
  real :: fac
!  real(kind=doublekind) :: fac
  real :: escProb
  logical :: contPhoton
  integer :: nContPhotons
  real :: phi
  real :: deltaLambda
  real :: rStar

  !
  real(kind=doubleKind) :: totalMass
  real(kind=doubleKind) :: T_ave   ! average temperature of cluster
  real(kind=doubleKind) :: T_mass  ! mass weighted temperature
  real(kind=doubleKind) :: tau_max, tau_min, tau_ave

  real(kind=doublekind) :: Laccretion
  real :: Taccretion, fAccretion, sAccretion
  real :: theta1, theta2, chanceHotRing

  ! Spot stuff
  
  real :: chanceSpot                     ! chance of spot
  logical :: spotPhoton                  ! photon from spot?

  real :: loglamStart, logLamEnd

  real :: chanceDust = 0.
  real(kind=doublekind) :: totDustContinuumEmission, totEnvelopeEmission

  ! binary parameters

  type(VECTOR) :: starPos1, starPos2
  integer :: nVec
  type(VECTOR), allocatable :: distortionVec(:)

  ! adaptive grid stuff

  type(OCTALVECTOR) :: amrGridCentre ! central coordinates of grid
  type(OCTALVECTOR) :: octVec
  integer :: subcell, oldSubcell
  type(OCTAL), pointer :: thisOctal, oldOctal
  real :: meant, treal, meaneta, eta, kabs
  integer, parameter :: nrGrid = 1000
  real :: rGrid(nrGrid), drGrid(nrgrid),prGrid(nrGrid)
  integer :: nt
  integer           :: nOctals       ! number of octals in grid
  integer           :: nVoxels       ! number of unique voxels in grid
                                     !   (i.e. the number of childless subcells)
  logical :: gridConverged           ! true when adaptive grid structure has 
                                     !   been finalised
  integer :: intPathError            ! error code from integratePathAMR
  character(len=80) :: newcontfile   ! get rid of this once the stateq is implemented?
  type(OCTALVECTOR) :: positionOc    ! photon position position
!  type(octal),pointer :: octalLocation! octal located by search routine 
  type(octal), pointer :: foundOctal
!  integer           :: subcellLocation! subcell located by search routine
  integer           :: tooFewSamples ! number of errors from integratePathAMR
  integer           :: boundaryProbs ! number of errors from integratePathAMR

  !
  ! SPH data of Matthew
  type(sph_data) :: sphData

  ! Used for multiple sources (when geometry=cluster)
  integer :: nstar
  type(cluster)   :: young_cluster
  type(isochrone) :: isochrone_data

  ! Used in "plot_AMR_planes" and "plot_AMR_values"
  integer :: nmarker           ! number of markers
  real, allocatable    :: xmarker(:)  ! position of x
  real, allocatable    :: ymarker(:)  ! position of y
  real, allocatable    :: zmarker(:)  ! position of z
  real    :: width_3rd_dim         ! Use this to restrict the markers to be plotted..  
  real val_3rd_dim

  real    :: tmp
  type(octalvector) :: vec_offset

  integer ::   iphase_beg, iphase_end  ! the beginning and the end of the phase index.

! additional extinction stuff
  
  logical :: additionalExtinction
  real ::  testKappaAbs, testKappaSca, testKappaAbs2, testkappaSca2
  real, allocatable :: foregroundKappaAbs(:), foregroundKappaSca(:)
  real, allocatable :: foregroundKappaAbs2(:), foregroundKappaSca2(:)


!$MPI  ! For MPI implementations =====================================================
!$MPI  integer ::   my_rank        ! my processor rank
!$MPI  integer ::   n_proc         ! The number of processes
!$MPI  integer ::   ierr           ! error flag
!$MPI  integer ::   n_rmdr, m
!$MPI  integer ::   mphase   !    ! number of phases (actual) 
!$MPI
!$MPI  ! FOR MPI IMPLEMENTATION=======================================================
!$MPI  !  initialize the system for running MPI
!$MPI  call MPI_INIT(ierr) 
!$MPI
!$MPI  !  Get my process rank # 
!$MPI  call MPI_COMM_RANK(MPI_COMM_WORLD, my_rank, ierr)
!$MPI  
!$MPI  ! Find the total # of precessor being used in this run
!$MPI  call MPI_COMM_SIZE(MPI_COMM_WORLD, n_proc, ierr)
!$MPI  !===============================================================================


  
  !
  ! For time statistics
!$MPI  if (my_rank==0) &
  call tune(6, "Torus Main") ! start a stopwatch  

  ! initialize

  useNdf = .true.
  sed = .false.
  movie = .false.
  thinLine = .false.
  rotateView = .false.
  flatspec = .false.
  greyContinuum = .false.
  secondSource = .false.
  firstplot = .true.
  doRaman = .false.
  enhance = .false.
  rotateDirection = -1.

  energyPerPhoton = 1. ! default

  contFluxFile = "none"
  intProFilename = "none"

  inputKappaSca = 0.
  inputKappaAbs = 0.

  zeroVec = VECTOR(0.,0.,0.)
  vec_offset = OCTALVECTOR(1.0_oc, 1.0_oc , 1.0_oc) ! used in a optical depth test.

  starPos1 = VECTOR(-400.,0.,0.)
  starPos2 = VECTOR(+400.,0.,0.)

  tooFewSamples = 0 
  boundaryProbs = 0 

  grid%densityScaleFac = 1.
  ! hardwired stuff

  abundance = 1.e-8
  particleMass = 15.9994*mHydrogen + 47.867*mHydrogen

  do i = 1, no6pts
     o6xArray(i) = o6start + (o6end-o6start)*real(i-1)/real(no6pts-1)
     o6yarray(i) = 1.d-10
  enddo

  ! get the model parameters

  call  inputs() ! variables are passed using the input_variables module


  objectDistance = griddistance * pctocm

!  secondSourcePosition = zeroVec

  grid%resonanceLine = resonanceLine

  if (nLambda > maxLambda) then
!$MPI     if(my_rank == 0) &
     write(*,'(a,i3.3,a)') "nlambda is greater than the maximum value (",&
          maxLambda,")"
     stop
  endif

  if (geometry.eq."raman") then
     hotSourcePosition = 0.75*secondSourcePosition
     coolStarPosition = (-0.25)*secondSourcePosition
     secondSourcePosition = hotSourcePosition
!$MPI     if(my_rank == 0) &
     write(*,*) "hot",hotSourcePosition
  endif

  if (doRaman) screened = .true.

  if (.not.inputOK) goto 666

  if (dopvimage) then
     allocate(pvimage(1:nSlit))
  endif

  if (mie) then
     meanDustParticleMass = getMeanMass2(amin, amax, a0, qDist, pdist, graintype)
!$MPI     if(my_rank == 0) &
     write(*,*) "mean dust particle mass: ",meanDustParticleMass
  endif

  probLinePhoton = 1. - probContPhoton
  inclination = inclination*degToRad
  scale = scale * rSol

  rStar = 100.*rSol / 1.e10

  ! if we are computing spiral models then we rotate the view

  if ((nPhase /= 1).and.(distortionType .eq. "spiral")) rotateview = .true.

  ! we also rotate for the test model

  if (distortionType .eq. "test") rotateView = .true.

  ! we rotate wind-wind collision models


  if (distortionType .eq. "windwind") rotateView = .true.


  ! rotate for colliding winds too

  if (trim(geometry) .eq. "collide") rotateView = .true.

  if (geometry == "binary") rotateView = .true.

  ! rotate for raman

  if (geometry == "raman") rotateView = .true.


  if (geometry == "planet") rotateView = .true.

  if (geometry == "betacep") rotateView = .true.

  if (geometry == "donati") rotateView = .true.

  if ((geometry == "ttauri").and.(.not.enhance)) rotateView = .true.

  if ((geometry(1:4) == "jets")) then
     rotateView = .true.
     tiltView = .true.
  end if

  if (doRaman) then
        rotateView = .true.
        rotateDirection = 1.
  endif

  if (geometry == "rolf") rotateView = .true.

  if (geometry == "disk") rotateView = .true.

  if (geometry == "wr104") then
     rotateView = .true.
     rotateDirection = 1.
  endif

  if (geometry(1:7) == "cluster") then
     rotateView = .true.
!     tiltView = .true.
  end if
  
  ! switches for line emission

  if (lineEmission) then
     flatspec = .true.
     greyContinuum = .true.
  endif

  if (geometry == "planet") then
     flatspec = .true.
     greyContinuum = .true.
  endif

  if (geometry == "rolf") then
!     flatspec = .true.
     greyContinuum = .true.
  endif
     
  if (geometry == "shakara") rotateView = .true.  

  ! the observer's viewing direction

  rotationAxis = VECTOR(0., 0., 1.)

  normToRotation = rotationAxis .cross. yAxis
  call normalize(normToRotation)

  originalViewVec%x = 0.
  originalViewVec%y = -sin(inclination)
  originalViewVec%z = -cos(inclination)
  viewVec = originalViewVec


  !
  ! Special case
  !
  if (geometry == "cluster") then
     ! read in the sph data from a file
     call read_sph_data(sphData, "sph.dat")
     call read_stellar_disc_data(sphData, "stellar_disc.dat")
     ! Writing basic info of this data
!$MPI     if(my_rank == 0)  then
     call info(sphData, "*")
     call info(sphData, "info_sph.dat")
!$MPI     end if
     
     ! reading in the isochrone data needed to build an cluster object.
     
     call new(isochrone_data, "dam98_0225")   
     call read_isochrone_data(isochrone_data)
     
     ! making a cluster object
     call new(young_cluster, sphData, dble(amrGridSize), disc_on)
     call build_cluster(young_cluster, sphData, dble(lamstart), dble(lamend), isochrone_data)
     
     ! Wrting the stellar catalog readble for a human
!$MPI     if(my_rank == 0)  &
     call write_catalog(young_cluster, sphData)
     ! Finding the inclinations of discs seen from +z directions...
!$MPI     if(my_rank == 0)  &
     call find_inclinations(sphData, 0.0d0, 0.0d0, 1.0d0, "inclinations_z.dat")
  end if

  if (geometry == "wr104") then
     if (.not.(readPops.or.readlucy)) then
        call readWR104Particles("harries_wr104.txt", sphData, objectDistance)
!$MPI     if(my_rank == 0)  &
        call info(sphData,"*")
     endif
  endif

  
  ! allocate the grid - this might crash out through memory problems

  if (gridUsesAMR) then
     ! any AMR allocation stuff goes here
     call initAMRGrid(Laccretion,Taccretion,sAccretion,greyContinuum, &
                        newContFile,flatspec,grid,ok,theta1,theta2)
        if (.not.ok) goto 666
        
  else
     if (gridcoords /= "polar") then
        if ((.not.doRaman).and.(geometry /= "binary"))  then
           grid = initCartesianGrid(nx, ny, nz, nLambda, lamStart, lamEnd, &
                greyContinuum, ok)
           else
           grid = initCartesianGrid(nx, ny, nz, 1, lamStart, lamEnd, &
                greyContinuum, ok)
        endif
         if (.not.ok) goto 666
     else   if (plezModelOn) then
        grid = plezModel("model.plez", lamStart, lamEnd, nLambda, kfac)
     else
        grid = initPolarGrid(nr, nmu, nphi, nlambda, lamStart, &
                             lamEnd, greyContinuum, ok)
        if (.not.ok) goto 666
     endif
  end if

  ! a few dynamic arrays

!  if (mie) sed = .true.

  grid%resonanceLine = resonanceLine
  grid%lambda2 = lamline


  allocate(miePhase(1:nLambda,1:nMumie))
  allocate(kappaExt(1:nLambda))
  allocate(kappaAbs(1:nLambda))
  allocate(kappaSca(1:nLambda))
  allocate(lamArray(1:nLambda))
  allocate(statArray(1:nLambda))
  allocate(sourceSpectrum(1:nLambda))
  allocate(sourceSpectrum2(1:nLambda))

  grid%doRaman = doRaman

  statArray = 0.
  sourceSpectrum = 1.
  sourceSpectrum2 = 1.

  ! set up the wavelength array

  do i = 1, nLambda
     lamArray(i) = lamStart+(lamEnd-lamStart)*real(i-1)/real(nLambda-1)
  enddo

  if (plezModelOn) then
     call readTioCrossSection(lamArray, nLambda, kappaExt, kappaAbs, kappaSca)
  endif


  ! allocate the output arrays

  if (lamfile) then
     write(*,*) "Reading lambda array from file",trim(lamfilename)
     open(30,file=lamfilename, form="formatted", status="old")
     read(30, *) nLambda
  endif

  allocate(xArray(1:nLambda))
  allocate(dx(1:nLambda))
  allocate(yArray(1:nLambda))
  allocate(errorArray(1:nOuterLoop,1:nLambda))

  if (lamfile) then
     do i = 1, nLambda
        read(30,*) xArray(i)
     enddo
     close(30)
     lamStart = xArray(1)
     lamEnd = xArray(nLambda)
  endif



  if (.not.lamfile) then
     if (lamLinear) then
        deltaLambda = (lamEnd - lamStart) / real(nLambda)
        
        xArray(1) = lamStart + deltaLambda/2.
        yArray(1)%i = 0.
        yArray(1)%q = 0.
        yArray(1)%u = 0.
        yArray(1)%v = 0.
        do i = 2, nLambda
           xArray(i) = xArray(i-1) + deltaLambda
           yArray(i)%i = 0.
           yArray(i)%q = 0.
           yArray(i)%u = 0.
           yArray(i)%v = 0.
        enddo
        dx = deltaLambda
     else


        logLamStart = log10(lamStart)
        logLamEnd = log10(lamEnd)
        
        do i = 1, nLambda
           xArray(i) = logLamStart + real(i-1)/real(nLambda-1)*(logLamEnd - logLamStart)
           xArray(i) = 10.**xArray(i)
           yArray(i) = STOKESVECTOR(0.,0.,0.,0.)
        enddo
     endif
     if (mie) then
        call locate(xArray, nLambda, lambdaTau, i)
        t1 = (lambdaTau - xArray(i))/(xArray(i+1)-xArray(i))
        if (t1 > 0.5) then
           write(*,*) "Replacing ",xArray(i+1), " wavelength step with ",lambdaTau
           xArray(i+1) = lambdaTau
        else
           write(*,*) "Replacing ",xArray(i), " wavelength step with ",lambdaTau
           xArray(i) = lambdaTau
        endif
     endif

     dx(1) = xarray(2)-xarray(1)
     dx(nLambda) = xarray(nlambda)-xarray(nLambda-1)
     do i = 2, nLambda-1
        dx(i) = 0.5*((xarray(i+1)+xarray(i))-(xarray(i)+xarray(i-1)))
     enddo
  endif

  do i = 1, nLambda
     grid%lamArray(i) = xArray(i)
  enddo
  grid%nLambda = nLambda

  
  errorArray(1:nOuterLoop,1:nLambda) = STOKESVECTOR(0.,0.,0.,0.)

  if (doRaman) then
     yarray(1:nLambda)%i = 1.e-20
     errorArray(1:nOuterLoop,1:nLambda)%i = 1.e-20
  endif

! clumpy disc stuff
  
  if (geometry .eq. "clumpydisc") then
     grid%ng = nclumps
     allocate(grid%gArray(1:nClumps))
     write(*,'(a)') "Creating disc gaussians..."
     call createDiscGaussians(grid%ng, grid%gArray)
  endif



  ! if the grid uses an adaptive mesh, create it
     

  if (mie) then

     if (.not.dustfile) then
!$MPI           if (my_rank==0) &
     write(*,*) "fill grid mie",nLambda,grid%nlambda
     call fillGridMie(grid, scale, aMin, aMax, a0, qDist, pDist, grainType, &
          ngrain, X_grain, grainname)
     else
        do i = 1, nDustType
           call dustPropertiesfromFile(dustfilename(i), grid%nlambda, xArray, grid%onekappaAbs(i,1:grid%nlambda), &
                grid%onekappaSca(i,1:grid%nLambda))
        enddo
     endif
  endif
  
  write(*,'(a,f5.2)') "!!!! Multiplying the opacities by the dust-to-gas ratio of: ",dusttogas
  do i = 1, nDustType
     grid%oneKappaAbs(i,1:grid%nLambda) =  grid%oneKappaAbs(i,1:grid%nLambda) * dustToGas
     grid%oneKappaSca(i,1:grid%nLambda) =  grid%oneKappaSca(i,1:grid%nLambda) * dustToGas
  enddo



!  if (gridUsesAMR.and.mie) then 
!     call setKappaTest(grid, scale, aMin, aMax, a0, qDist, pDist, grainType, &
!          ngrain, X_grain, grainname, lambdaTau)
!  end if
  
  call locate(grid%lamArray, nLambda,lambdaTau,itestlam)
  call locate(grid%lamArray, nLambda,lambdasmooth,ismoothlam)
  write(*,*) "Test wavelength index: ",itestlam,ismoothlam

  if (gridUsesAMR) then
!$MPI     if(my_rank == 0)  &
     call tune(6, "AMR grid construction.")  ! start a stopwatch
     if (readPops) then 
        call readAMRgrid(popFilename,readFileFormatted,grid)

     elseif (readLucy) then
!$MPI     if(my_rank == 0)  then
           write(*,*) " "
           write(*,*) "Reading lucy radiative equilibrium data along with the AMR grid..."
!$MPI     end if
           call readAMRgrid(lucyFilenameIn,readFileFormatted,grid)
!$MPI     if(my_rank == 0)  then
           write(*,*) "done ..."
           write(*,*) " "
!$MPI     end if
     else
        amrGridCentre = octalVector(amrGridCentreX,amrGridCentreY,amrGridCentreZ)
!$MPI     if(my_rank == 0) &
        write(*,*) "Starting initial set up of adaptive grid..."

        select case (geometry)
        case("cluster")
           call initFirstOctal(grid,amrGridCentre,amrGridSize, .false.,sphData, young_cluster, nDusttype=nDustType)
           call splitGrid(grid%octreeRoot,limitScalar,limitScalar2,grid, sphData, young_cluster)
!$MPI     if(my_rank == 0) &
           write(*,*) "...initial adaptive grid configuration complete"
           call fill_in_empty_octals(young_cluster,grid%octreeRoot,sphData)

           !Removing the cells within 10^14 cm from the stars.
           call remove_too_close_cells(young_cluster,grid%octreeRoot,1.0d4)

        case("wr104")
           call initFirstOctal(grid,amrGridCentre,amrGridSize, .false., sphData, nDustType=nDustType)
           !
           call splitGrid(grid%octreeRoot,limitScalar,limitScalar2,grid, sphData)
!$MPI     if(my_rank == 0) &
           write(*,*) "...initial adaptive grid configuration complete"
!           do
!              call smoothAMRgrid(grid%octreeRoot,grid,smoothFactor,gridConverged, sphData)
!              if (gridConverged) exit
!           end do
!           write(*,*) "...grid smoothing complete"
        case DEFAULT
           call initFirstOctal(grid,amrGridCentre,amrGridSize, amr2d, nDusttype=nDustType)
           call splitGrid(grid%octreeRoot,limitScalar,limitScalar2,grid)
           if (geometry == "proto") then
              allocate(lambda(1:maxTau))
              allocate(tauExt(1:maxTau))
              allocate(tauAbs(1:maxTau))
              allocate(tauSca(1:maxTau))
              allocate(contTau(1:maxTau,1:maxLambda))
              allocate(contWeightArray(1:maxTau))
              
              if (grid%octreeRoot%threed) then
                 call IntegratePathAMR(lambdaTau,  lamLine, OCTALVECTOR(1.,1.,1.),  &
                      amrGridCentre,  &
                      OCTALVECTOR(1.,0.,0.), grid, lambda, tauExt, tauAbs, &
                      tauSca, maxTau, nTau, opaqueCore, escProb, contPhoton , &
                      lamStart, lamEnd, nLambda, Conttau, hitCore, thinLine, .false., &
                      .false., nUpper, nLower, 0., 0., 0., junk,&
                      sampleFreq,Error)
              else
                 call IntegratePathAMR(lambdaTau,  lamLine, OCTALVECTOR(1.,1.,1.),  &
                      OCTALVECTOR(0.1,0.1,0.1),  &
                      OCTALVECTOR(1.,0.,0.), grid, lambda, tauExt, tauAbs, &
                      tauSca, maxTau, nTau, opaqueCore, escProb, contPhoton , &
                      lamStart, lamEnd, nLambda, Conttau, hitCore, thinLine, .false., &
                      .false., nUpper, nLower, 0., 0., 0., junk,&
                      sampleFreq,Error)
              endif
              if (error < 0) then
                 write(*,*) '   Error encountered in cross-sections!!! (error = ',error,')'
              end if
              grid%densityscaleFac =  taurad/tauExt(ntau)
              call scaleDensityAMR(grid%octreeRoot, grid%densityscaleFac)
              call IntegratePathAMR(lambdaTau,  lamLine, OCTALVECTOR(1.,1.,1.),  &
                   OCTALVECTOR(0.1,0.1,0.1),  &
                   OCTALVECTOR(1.,0.,0.), grid, lambda, tauExt, tauAbs, &
                   tauSca, maxTau, nTau, opaqueCore, escProb, contPhoton , &
                   lamStart, lamEnd, nLambda, Conttau, hitCore, thinLine, .false., &
                   .false., nUpper, nLower, 0., 0., 0., junk,&
                   sampleFreq,Error)
              write(*,*) "Grid re-scaled..."
              write(*,*) "Optical depth at characteristic lambda",tauExt(ntau)
              call IntegratePathAMR(lambdaSmooth,  lamLine, OCTALVECTOR(1.,1.,1.),  &
                   OCTALVECTOR(0.1,0.1,0.1),  &
                   OCTALVECTOR(1.,0.,0.), grid, lambda, tauExt, tauAbs, &
                   tauSca, maxTau, nTau, opaqueCore, escProb, contPhoton , &
                   lamStart, lamEnd, nLambda, Conttau, hitCore, thinLine, .false., &
                   .false., nUpper, nLower, 0., 0., 0., junk,&
                   sampleFreq,Error)
              write(*,*) "Optical depth at smoothing lambda",tauExt(ntau)

              deallocate(lambda)
              deallocate(tauExt)
              deallocate(tauAbs)
              deallocate(tauSca)
              deallocate(contTau)
              deallocate(contWeightArray)
           endif


           if (geometry == "clumpydisc") then
              write(*,*) "Scaling clumpy disc..."
              totalmass = 0.
              call findTotalMass(grid%octreeRoot, totalMass)
              if (totalMass /= 0.) then
                 grid%densityscaleFac =  mDisc/totalMass
                 write(*,*) "Density scale factor",grid%densityScalefac
              else
                 grid%densityScaleFac = 1.
              endif
              call scaleDensityAMR(grid%octreeRoot, grid%densityscaleFac)
              totalmass = 0.
              call findTotalMass(grid%octreeRoot, totalMass)
              write(*,*) "Total disc mass",totalmass/msol
           endif

!$MPI     if(my_rank == 0) &
           write(*,*) "...initial adaptive grid configuration complete"

           if (doSmoothGrid) then
!$MPI     if(my_rank == 0) &
              write(*,*) "Smoothing adaptive grid structure..."
              gridConverged = .false.
              do
                 call smoothAMRgrid(grid%octreeRoot,grid,smoothFactor,gridConverged)
                 if (gridConverged) exit
              end do
!$MPI     if(my_rank == 0) &
              write(*,*) "...grid smoothing complete"
           end if
           ! chris (26/05/04)
           ! Smooth the grid with respect to optical depth, if requested
           if (doSmoothGridTau) then
!$MPI     if(my_rank == 0) &
              write(*,*) "Smoothing adaptive grid structure for optical depth..."
              do j = iSmoothLam,iSmoothlam
                 do
                    gridConverged = .true.
                    call smoothAMRgridTau(grid%octreeRoot,grid,gridConverged,j)
                    if (gridConverged) exit
                 end do
              enddo
!$MPI     if(my_rank == 0) &
              write(*,*) "...grid smoothing complete"
              ! The tau smoothing may result in large differences in the size
              ! of neighbouring octals, so we smooth the grid again.
              if (doSmoothGrid) then
!$MPI     if(my_rank == 0) &
                write(*,*) "Smoothing adaptive grid structure (again)..."
                gridConverged = .false.
                do
                   call smoothAMRgrid(grid%octreeRoot,grid,smoothFactor,gridConverged)
                   if (gridConverged) exit
                end do
!$MPI     if(my_rank == 0) &
                write(*,*) "...grid smoothing complete"
              end if
           end if

        end select
   
        nOctals = 0
        nVoxels = 0
        call countVoxels(grid%octreeRoot,nOctals,nVoxels)
!$MPI     if(my_rank == 0) then
        write(*,*) "Adaptive grid contains: ",nOctals," octals"
        write(*,*) "                      : ",nVoxels," unique voxels"
!$MPI   end if
        grid%nOctals = nOctals

!$MPI     if(my_rank == 0) &
        write(*,*) "Calling routines to finalize the grid variables..."
        gridConverged = .false.
     
        do
           call finishGrid(grid%octreeRoot,grid,gridConverged)
           if (gridConverged) exit
        end do



           if (geometry == "proto") then
              allocate(lambda(1:maxTau))
              allocate(tauExt(1:maxTau))
              allocate(tauAbs(1:maxTau))
              allocate(tauSca(1:maxTau))
              allocate(contTau(1:maxTau,1:maxLambda))
              allocate(contWeightArray(1:maxTau))
              
              if (grid%octreeRoot%threed) then
                 call IntegratePathAMR(lambdaTau,  lamLine, OCTALVECTOR(1.,1.,1.),  &
                      amrGridCentre,  &
                      OCTALVECTOR(1.,0.,0.), grid, lambda, tauExt, tauAbs, &
                      tauSca, maxTau, nTau, opaqueCore, escProb, contPhoton , &
                      lamStart, lamEnd, nLambda, Conttau, hitCore, thinLine, .false., &
                      .false., nUpper, nLower, 0., 0., 0., junk,&
                      sampleFreq,Error)
              else
                 call IntegratePathAMR(lambdaTau,  lamLine, OCTALVECTOR(1.,1.,1.),  &
                      OCTALVECTOR(0.1,0.1,0.1),  &
                      OCTALVECTOR(1.,0.,0.), grid, lambda, tauExt, tauAbs, &
                      tauSca, maxTau, nTau, opaqueCore, escProb, contPhoton , &
                      lamStart, lamEnd, nLambda, Conttau, hitCore, thinLine, .false., &
                      .false., nUpper, nLower, 0., 0., 0., junk,&
                      sampleFreq,Error)
              endif
              if (error < 0) then
                 write(*,*) '   Error encountered in cross-sections!!! (error = ',error,')'
              end if
              grid%densityscaleFac =  taurad/tauExt(ntau)
              call scaleDensityAMR(grid%octreeRoot, grid%densityscaleFac)
              call IntegratePathAMR(lambdaTau,  lamLine, OCTALVECTOR(1.,1.,1.),  &
                   OCTALVECTOR(0.1,0.1,0.1),  &
                   OCTALVECTOR(1.,0.,0.), grid, lambda, tauExt, tauAbs, &
                   tauSca, maxTau, nTau, opaqueCore, escProb, contPhoton , &
                   lamStart, lamEnd, nLambda, Conttau, hitCore, thinLine, .false., &
                   .false., nUpper, nLower, 0., 0., 0., junk,&
                   sampleFreq,Error)
              write(*,*) "Grid re-scaled..."
              write(*,*) "Optical depth at characteristic lambda",tauExt(ntau)
              call IntegratePathAMR(lambdaSmooth,  lamLine, OCTALVECTOR(1.,1.,1.),  &
                   OCTALVECTOR(0.1,0.1,0.1),  &
                   OCTALVECTOR(1.,0.,0.), grid, lambda, tauExt, tauAbs, &
                   tauSca, maxTau, nTau, opaqueCore, escProb, contPhoton , &
                   lamStart, lamEnd, nLambda, Conttau, hitCore, thinLine, .false., &
                   .false., nUpper, nLower, 0., 0., 0., junk,&
                   sampleFreq,Error)
              write(*,*) "Optical depth at smoothing lambda",tauExt(ntau)

              deallocate(lambda)
              deallocate(tauExt)
              deallocate(tauAbs)
              deallocate(tauSca)
              deallocate(contTau)
              deallocate(contWeightArray)
           endif

           if (geometry == "clumpydisc") then
              write(*,*) "Re-scaling clumpy disc..."
              totalmass = 0.
              call findTotalMass(grid%octreeRoot, totalMass)
              if (totalMass /= 0.) then
                 grid%densityscaleFac =  mDisc/totalMass
              else
                 grid%densityScaleFac = 1.
              endif
              call scaleDensityAMR(grid%octreeRoot, grid%densityscaleFac)
           call dumpSmoothedSurfaceDensity("surfacedens.dat", grid)
           endif


!$MPI     if(my_rank == 0) &
        write(*,*) "...final adaptive grid configuration complete"
!$MPI     if(my_rank == 0) &
        call tune(6, "AMR grid construction.") ! stop a stopwatch

        if (writePops) call writeAMRgrid(popFilename,writeFileFormatted,grid)


        if (gridUsesAMR .and. lineEmission) then
           !  calculate the statistical equilibrium (and hence the emissivities 
           !  and the opacities) for all of the subcells in an
           !  adaptive octal grid.
           !  Using a routine in stateq_mod module.
!$MPI     if(my_rank == 0) &
           write(*,*) "Calling statistical equilibrium routines..."
!$MPI     if(my_rank == 0) &
           call tune(6, "amrStateq") ! start a stopwatch  
           if (grid%geometry=="ttauri") then
              call amrStateq(grid, contfluxfile, lte, nLower, nUpper)
           else
              call amrStateq(grid, contfluxfile, lte, nLower, nUpper, ion_name, ion_frac)
           end if

!$MPI     if(my_rank == 0) &
           call tune(6, "amrStateq") ! stop a stopwatch  
!$MPI     if(my_rank == 0) &
           write(*,*) "... statistical equilibrium routines complete"
!$MPI     if(my_rank == 0) then
           if (writePops) call writeAMRgrid(popFilename,writeFileFormatted,grid)
           call plot_AMR_values(grid, "etaCont", "x-z", 0.0,  &
                "etacont.ps/vcps", .true., .false.)
           call plot_AMR_values(grid, "etaLine", "x-z", 0.0,  &
                "etaline.ps/vcps", .true., .false.)
           call plot_AMR_values(grid, "chiLine", "x-z", 0.0,  &
               "chiline.ps/vcps", .true., .false.)
           call plot_AMR_values(grid, "temperature", "x-z", 0.0, &
               "temperature.ps/vcps", .true., .false.)
!$MPI      endif

	endif

        !
        ! cleaning up unused memory here ....
        if ((geometry(1:7) == "cluster").or.(geometry(1:5)=="wr104")) then
           ! using the routine in sph_data_class
           call kill(sphData)
           ! using the routine in amr_mod.f90
           call delete_particle_lists(grid%octreeRoot)
        end if

     end if ! (readPops) 



  else ! grid is not adaptive
           
     ! fill up the grid with the appropriate opacities
 
     if (.not.plezModelOn) then
        select case(geometry)
        case("torus")
           call fillGridTorus(grid, rho, rTorus, rOuter)
        case("sphere")
           call fillGridSpheriod(grid, rho, radius, kFac)
        case("flared")
           call fillGridFlaredDisk(grid, meanDustParticleMass)
        case("ellipse")
           call fillGridEllipse(Grid,rho, rMin, rMaj, rinner, teff)
        case("disk")
           call fillGridDisk(grid, rho, rCore, rInner, rOuter, height, mCore, diskTemp)
        case("star")
           call fillGridStar(grid, radius, mdot, vel, kfac, scale)
        case("spiral")
           call fillGridSpiral(grid, radius, mdot, vel, scale)
        case("shell")
           call fillGridShell(grid, radius, shellFrac, rho, kfac)
        case("stateq")
           call fillGridStateq(grid, opacityDataFile, kfac, scaleDensity)
        case("bipolar")
           call fillGridBipolar(grid, rho,  30.)
        case("collide")
           call fillGridCollide(grid, rho, momRatio, binarySep, mie, meanDustParticleMass, logMassLossRate)
        case("dustblob")
           call fillGridDustBlob(grid, dustBlobdistance, rho, phiDustBlob, &
                xDustBlobSize, yDustBlobSize, zDustBlobSize)
        case("raman")
           call  fillGridRaman(grid, 10.*rStar, mdot, vterm, rStar, coolStarPosition, beta)
        case("binary")
           call fillGridBinary(grid, radius1, radius2, mass1, mass2, &
           temp1, temp2, vNought1, vNought2, vTerm1, vTerm2, beta1, beta2, period, &
           mdot1, mdot2, deflectionAngle, shockWidth, shockFac)
        
           call initGridStateq(grid, contFluxFile, contFluxFile2, &
                popFilename, readPops, writePops, lte, nLower, nUpper)
        
        case("rolf")
           call fillGridRolf(grid, mdot, vterm, o6width)
        case("wr137")
           call fillGridWR137(grid, rCore, mDot, vTerm, beta, temp1)
        case("planet")
           call fillGridPlanet(grid)
        case("hourglass")
           call fillGridHourglass(grid)
        case("ttauri")
           call fillGridMagneticAccretion(grid,contfluxfile, popFileName, &
              readPops, writePops, lte,  lamLine, Laccretion, Taccretion, sAccretion, &
                   curtains, dipoleOffset, nLower, nUpper, theta1, theta2)
        case("ttwind")
           call fillGridTTauriWind(grid,contfluxfile, popFileName, &
                readPops, writePops, lte, nLower, nUpper)
        case("betacep")
            call fillGridBetaCep(grid)
        case("donati")
           resonanceLine = .false.
           if (lamLine < 2000.) resonanceLine = .true.
           call fillGridDonati2(grid, resonanceLine, misc)
           if (.not.resonanceLine) then
              call initGridStateq(grid, contFluxFile, contFluxFile2, popFilename, &
                   readPops, writePops, lte, nLower, nUpper)
           endif
           grid%kappaAbs = 1.e-30


        case("puls")

           call fillGridPuls(grid, mDot, rcore, tEff, v0, vterm, beta, xfac, blobs, maxblobs, .false., vContrast)

   !        call initGridStateq(grid, contFluxFile, contFluxFile2, popFilename, &
   !                            readPops, writePops, lte, nLower, nUpper)
        case("wind")
           call fillGridWind(grid, mDot, rCore, tEff, v0, vterm, beta, &
           lte, contFluxFile, writePops, readPops, popFilename, nLower, nUpper, vrot)
        call initgridstateq(grid, contfluxFile, " ", popFileName, &
           readPops, writePops, lte, nLower, nUpper)
           grid%etaCont = 1.e-30
           grid%kappaAbs = 1.e-30

        
        case("resonance")
!           call fillGridResonance(grid, rCore, mDot, vTerm, beta, temp1)
!           grid%resonanceLine = .true.

        case DEFAULT
!$MPI           if (my_rank==0) &
           write(*,*) "! Unrecognised grid geometry: ",trim(geometry)
           goto 666
        end select
     endif ! (.not.plezModelOn)

     if (fillTio) then
        call fillGridTio(grid, scale)
     endif

     if (fillRayleighOpacity) then
        call fillGridRayleigh(grid,scale)
     endif 

     if (fillThomson) then
        call fillGridThomson(grid)
     endif

  ! the distortion types

     select case(distortionType)
     case("spiral")
        call distortGridSpiral(grid, vRot, nSpiral)
     case("rotation")
        call distortRotation(grid, vRot)
!$MPI           if (my_rank==0) &
        write(*,'(a,f5.1,a)') "Grid distorted by a rotational velocity of ", &
                               vRot/1.e5," km/s"
     case("test")
        call distortGridTest(grid)
!     case("raman")
!        call distortRaman(grid)
     case("raman")
        call  distortStrom(grid, secondSourcePosition, .true., .true., 0.5*rStar, coolStarPosition, ramanDist)

     case("wrdisk")
        call distortWRdisk(grid)
     case("windwind")
        call distortWindCollision(grid, momRatio, binarySep)

     end select


  
     if (enhance) then
        nVec = 40
        allocate(distortionVec(nVec))
        timeStart = 0.
        timeEnd = 12.*3600.
        dTime = (timeEnd - timeStart)/real(nPhase)
        call initInfallEnhancement(distortionVec, nVec)
        do i = 1, nStartPhase-1
           call infallEnhancment(grid, distortionVec, nVec, dTime, .false.)
        enddo
     endif

  endif ! (gridusesAMR)



        if (geometry == "shakara") then
           call polardump(grid)
        endif


  if (geometry(1:7) .eq. "testamr") then


    do i = 1, 1000
       meant = 0.
       meaneta =0.
       nt = 0
       r = log10(grid%rInner) + (log10(grid%rOuter)-log10(grid%rInner))* real(i-1)/999.
       r = 10.**r
       r1 = log10(grid%rInner) + (log10(grid%rOuter)-log10(grid%rInner))* real(i)/999.
       r1 = 10.**r1
       rGrid(i) = r
       drGrid(i) = r1 - r
    enddo



    open(21,file="r.dat",status="unknown",form="formatted")
    call locate(xarray, nLambda, 10.e4, ilambda)

    prGrid = 0.
    do i = 1, 1000
       meant = 0.
       meaneta =0.
       nt = 0
       outVec = VECTOR(1., 0., 0.)
       rVec = rGrid(i) * outVec 
       r = rgrid(i)
!       call integratePathAMR(10.e4,  lamLine, VECTOR(1.,1.,1.), &
!            rVec, outVec, grid, lambda, &
!            tauExt, tauAbs, tauSca, maxTau, nTau, opaqueCore, escProb, &
!            .false., lamStart, lamEnd, nLambda, contTau, &
!            hitCore, thinLine,.false.,  &
!            .false., nUpper, nLower, 0., 0., 0., junk,sampleFreq,intPathError)



       do j = 1, 100
          ang = twoPi * real(j-1)/100.
          octVec = OCTALVECTOR(r*cos(ang), r*sin(ang),0.)
          call amrGridValues(grid%octreeRoot, octVec, temperature=treal, &
              ilambda=1, grid=grid ,etacont = eta, kappaAbs=kabs)
          if (treal > 1.) then
             t1 = dble(treal)
             meant = meant + t1
             meaneta = meaneta + eta
             nt = nt + 1
          endif
       enddo
       if (nt > 0) then
!$MPI           if (my_rank==0) &
          write(21,*) r/grid%rInner,meant/real(nt), meaneta * r**2 * drgrid(i)/ real(nt)
       endif
    Enddo
    close(21)
 endif

 if (grid%geometry == "wr104") then
    open(20,file="r.dat",status="unknown",form="formatted")
    do i = 1, 1000
       r = real(i-1)/999. * amrGridSize/2.
       nt = 0
       t1 = 0.
       do j = 1, 1000
          call random_number(ang)
          ang = ang * twoPi
          octVec = OCTALVECTOR(r*cos(ang), r*sin(ang), 0.)
          call amrGridValues(grid%octreeRoot, octVec, temperature=treal)       
          if (treal > 11.) then
             t1 = t1  + treal
             nt = nt + 1
          endif
       enddo
       if (nt > 0) then
          write(20,*) r, t1/real(nt)
       endif
    enddo
    close(20)
 endif

 
  ! Print the infomation on the grid to the standard ouput.
  ! -- using a routine in grid_mod.f90
!$MPI           if (my_rank==0) &
  call grid_info(grid, "*")
!$MPI           if (my_rank==0) &
  call grid_info(grid, "info_grid.dat")


  
!  if (mie) then
!
!     if (.not.dustfile) then
!!$MPI           if (my_rank==0) &
!     write(*,*) "fill grid mie",nLambda,grid%nlambda
!     call fillGridMie(grid, scale, aMin, aMax, a0, qDist, pDist, grainType, &
!          ngrain, X_grain, grainname)
!     else
!        do i = 1, nDustType
!           call dustPropertiesfromFile(dustfilename(i), grid%nlambda, xArray, grid%onekappaAbs(i,1:grid%nlambda), &
!                grid%onekappaSca(i,1:grid%nLambda))
!        enddo
!     endif
!  endif

  if (grid%adaptive.and.movie) then
     call plotAMRthreeDMovie("/xs", "rotateZ", grid)
  endif


  !
  ! Plotting the various values stored in the AMR grid.
  !

!$MPI   if (my_rank==0) then

  if(gridUsesAMR .and. plot_maps) then

     !
!     if (grid%geometry == "jets"  .or. &
!          grid%geometry == "ttauri"  .or.  grid%geometry == "testamr" ) then
!        call draw_cells_on_density(grid, plane_for_plot, "cells_on_density.ps/vcps")
!        !     call draw_cells_on_density(grid, plane_for_plot, device)
!     end if
     

     ! Do some preparation for the arrays used in plot_AMR_* which will be used later
     if (grid%geometry(1:7) == "cluster") then
        nmarker = get_nstar(young_cluster)
        ALLOCATE(xmarker(nmarker), ymarker(nmarker), zmarker(nmarker))
        do i = 1, nmarker
           a_star = get_a_star(young_cluster, i)
           xmarker(i)= a_star%position%x
           ymarker(i)= a_star%position%y
           zmarker(i)= a_star%position%z
        end do
        width_3rd_dim = amrGridSize
     else
        nmarker = 0;
        ALLOCATE(xmarker(nmarker), ymarker(nmarker), zmarker(nmarker))
        width_3rd_dim = amrGridSize
     end if


     !  call fancyAmrPlot(grid, device)
     
     ! Plot desired AMR grid value here... This is more generalized
     ! version of fancyAmrPlot.
     !
     ! See grid_mod.f90 for details.
     !
     if (plane_for_plot == "x-y") then
        val_3rd_dim = amrGridCentre%z
     else if (plane_for_plot == "y-z") then
        val_3rd_dim = amrGridCentre%x
     else if (plane_for_plot == "z-x") then
        val_3rd_dim = amrGridCentre%y
     else if (plane_for_plot == "x-z") then
        val_3rd_dim = amrGridCentre%y
     else
        val_3rd_dim = 0.0d0        
     end if

     call plot_AMR_values(grid, "rho", plane_for_plot, val_3rd_dim, &
             "rho_grid.ps/vcps",.true., .true.,&
              nmarker, xmarker, ymarker, zmarker, width_3rd_dim, show_value_3rd_dim)
     call plot_AMR_values(grid, "rho", plane_for_plot, val_3rd_dim, &
             "rho_zoom.ps/vcps",.true., .true.,&
              nmarker, xmarker, ymarker, zmarker, width_3rd_dim, show_value_3rd_dim, BOXFAC=0.01)
     call plot_AMR_values(grid, "rho", plane_for_plot, val_3rd_dim, &
             "rho_lin.ps/vcps",.false., .true.,&
              nmarker, xmarker, ymarker, zmarker, width_3rd_dim, show_value_3rd_dim)
     if (.not.lineEmission) then
        call plot_AMR_values(grid, "tau", plane_for_plot, val_3rd_dim, &
             "tau_grid.ps/vcps",.true., .false.,&
             nmarker, xmarker, ymarker, zmarker, width_3rd_dim, show_value_3rd_dim, ilam=itestlam)
        call plot_AMR_values(grid, "tau", plane_for_plot, val_3rd_dim, &
             "tau_zoom.ps/vcps",.true., .false.,&
             nmarker, xmarker, ymarker, zmarker, width_3rd_dim, show_value_3rd_dim, ilam=itestlam, boxFac=0.01)
     endif
     ! Plotting the slices of planes
     call plot_AMR_planes(grid, "rho", plane_for_plot, 3, "rho", .true., .false., &
          nmarker, xmarker, ymarker, zmarker, show_value_3rd_dim)
   
     ! Plotting some grid values
     call plot_AMR_values(grid, "etaCont", plane_for_plot, val_3rd_dim,  &
          "etacont.ps/vcps", .true., .false.,  &
          nmarker, xmarker, ymarker, zmarker, width_3rd_dim, show_value_3rd_dim)
     call plot_AMR_values(grid, "temperature", plane_for_plot, val_3rd_dim, &
          "temperature.ps/vcps", .true., .false., &
          nmarker, xmarker, ymarker, zmarker, width_3rd_dim, show_value_3rd_dim)
     call plot_AMR_values(grid, "Vx", plane_for_plot, val_3rd_dim,  &
          "Vx.ps/vcps", .false., .false.,  &
          nmarker, xmarker, ymarker, zmarker, width_3rd_dim, show_value_3rd_dim)
     call plot_AMR_values(grid, "Vy", plane_for_plot, val_3rd_dim, &
          "Vy.ps/vcps", .false., .false., &
          nmarker, xmarker, ymarker, zmarker, width_3rd_dim, show_value_3rd_dim)
     call plot_AMR_values(grid, "Vz", plane_for_plot, val_3rd_dim, &
          "Vz.ps/vcps", .false., .false., &
          nmarker, xmarker, ymarker, zmarker, width_3rd_dim, show_value_3rd_dim)
     if (lineEmission) then
        call plot_AMR_values(grid, "etaLine", plane_for_plot, val_3rd_dim,  &
             "etaline.ps/vcps", .true., .false., & 
             nmarker, xmarker, ymarker, zmarker, width_3rd_dim, show_value_3rd_dim)
        call plot_AMR_values(grid, "chiLine", plane_for_plot, val_3rd_dim,  &
             "chiline.ps/vcps", .true., .false., &
           nmarker, xmarker, ymarker, zmarker, width_3rd_dim, show_value_3rd_dim)
     end if

!     ! plotting column density (new routine in grid_mod.f90)
!     if (grid%geometry(1:7) == "cluster") then 
!       call plot_column_density(grid, plane_for_plot,  "column_density.ps/vcps", &
!             nmarker, xmarker, ymarker, zmarker, width_3rd_dim, show_value_3rd_dim,val_3rd_dim)
!     end if
     
  end if

!$MPI  end if  ! if (my_rank ==0)
  
  ! The source spectrum is normally a black body

  if (.not.grid%lineEmission) then
     stot = 0.
     do i = 1, nLambda
        sourceSpectrum(i) = bLambda(dble(xArray(i)), dble(teff))
        stot = stot + sourceSpectrum(i)
     enddo
     sourceSpectrum  = sourceSpectrum / stot
  endif



  ! set up a random seed

  call random_seed()


  outVec = (-1.)* originalViewVec


  ! compute the mie scattering phase matrices if necessary

  xMin =  2.*pi*grainSize/(lamEnd*angstromToCm)
  xMax =  2.*pi*grainSize/(lamStart*angstromToCm)

  if (mie) then
!$MPI     if (my_rank==0) &
     write(*,'(a)') "Computing Mie phase grid..."

     allocate(mReal(1:nLambda))
     allocate(mImg(1:nLambda))

     if (graintype(1:5) == "mixed") then
        ! Synthetic grains
         
        ! quick test for zero total dust abundance.
        total_dust_abundance = SUM(X_grain)
        if ( total_dust_abundance <= 0.0 ) then
!$MPI     if (my_rank==0) &
           write(*,*) "Error:: total_dust_abundance <= 0.0 in torusMain."
!$MPI     if (my_rank==0) &
           write(*,*) "  ==> You probably forgot to assign dust abundance in your "// &
                & "parameter file!"
!$MPI     if (my_rank==0) &
           write(*,*) "  ==> Exiting the prograim ... "
            stop 
         end if

         ! allocate mem for temp arrays
         allocate(mReal2D(1:ngrain, 1:nLambda))
         allocate(mImg2D(1:ngrain, 1:nLambda))
         ! initializing the values
         mReal2D(:,:) = 0.0; mImg2D(:,:) = 0.0
         
         ! Find the index of refractions for all types of grains available
         do j = 1, ngrain
            call getRefractiveIndex(xArray, nLambda, grainname(j), mReal, mImg)
            mReal2D(j,:) = mReal(:)  ! copying the values to a 2D maxtrix
            mImg2D(j,:)  = mImg(:)   ! copying the values to a 2D maxtrix            
         end do

         ! Finding the weighted average of the refractive index.
         mReal(:) = 0.0; mImg(:) = 0.0
         do i = 1, nLambda
            do j = 1, ngrain
               mReal(i) = mReal2D(j,i)*X_grain(j) + mReal(i)
               mImg(i)  = mImg2D(j,i) *X_grain(j) + mImg(i)
            end do
            mReal(i) = mReal(i) / total_dust_abundance
            mImg(i)  = mImg(i)  / total_dust_abundance
         end do


         deallocate(mReal2D)
         deallocate(mImg2D)

      else 
         ! Do a single grain calculations... 

         call getRefractiveIndex(xArray, nLambda, graintype, mReal, mImg)
         
      end if


      do i = 1, nLambda
         do j = 1, nMumie
            mu = 2.*real(j-1)/real(nMumie-1)-1.
            if (.not.((geometry == "benchmark").or.(geometry == "shakara").or.(geometry == "proto"))) then
               call mieDistPhaseMatrix(aMin, aMax, a0, qDist, pDist, xArray(i), &
                    mu, miePhase(i,j), mReal(i), mImg(i))               
            else
               write(*,*) "! ISOTROPIC SCATTERING ENFORCED"
               miePhase(i,j) = fillIsotropic(mu)
            endif
         end do
      end do


     deallocate(mReal)
     deallocate(mImg)

!$MPI     if (my_rank==0) &
     write(*,'(a)') "Completed."



  endif

  ! set up the sources

  nSource = 0

  select case(geometry)
    case("testamr","proto")
       nSource = 1
       allocate(source(1:1))
       source(1)%luminosity = grid%lCore
       source(1)%radius = grid%rCore
       source(1)%teff = teff
       source(1)%position = VECTOR(1.,0.,1.)
       call fillSpectrumBB(source(1)%spectrum, dble(teff),  dble(lamStart), dble(lamEnd),nLambda)
       call normalizedSpectrum(source(1)%spectrum)
    case("melvin")
       nSource = 1
       teff = 30000.
       allocate(source(1:1))
       source(1)%luminosity = fourPi * (10.*rsol)**2 * stefanBoltz * teff**4
       source(1)%radius = 10.*rSol / 1.e10
       source(1)%teff = teff
       source(1)%position = VECTOR(0.,0.,0.)
       call fillSpectrumBB(source(1)%spectrum, dble(teff),  dble(lamStart), dble(lamEnd),nLambda)
       call normalizedSpectrum(source(1)%spectrum)
    case("benchmark")
       nSource = 1
       allocate(source(1:1))
       source(1)%luminosity = grid%lCore
       source(1)%radius = grid%rCore
       source(1)%teff = teff
       source(1)%position = VECTOR(0.,0.,0.)
       call fillSpectrumBB(source(1)%spectrum, dble(teff),  dble(lamStart), dble(lamEnd), nLambda)
       call normalizedSpectrum(source(1)%spectrum)
    case("wr104")
       nSource = 2

       allocate(source(1:nSource)) 
       source(1)%teff = 30000.  ! o star
       source(1)%radius = 20. * rSol / 1.e10
       source(1)%position = (VECTOR(0.,0.,1.)*autocm)/1.e10
       source(1)%luminosity = fourPi * stefanBoltz * (20.*rSol)**2 * (source(1)%teff)**4
       call readSpectrum(source(1)%spectrum, "ostar.flx")
       call normalizedSpectrum(source(1)%spectrum)

       source(2)%teff = 40000.             ! wr star 
       source(2)%radius = 20. * rSol / 1.e10
       source(2)%position = (VECTOR(0.,0.,-1)*autocm)/1.e10
       source(2)%luminosity = 0.5 * source(1)%luminosity
       call readSpectrum(source(2)%spectrum, "wr.flx")
       call normalizedSpectrum(source(2)%spectrum)

    case ("cluster")
       ! Extract some info from cluster object.
       nstar = get_nstar(young_cluster)  ! number of stars in the cluster
       nSource =  n_stars_in_octal(young_cluster, grid%octreeRoot)
       
       ! copy the star over in the array.
       ! This is ugly. Maybe lucyRadiativeEquilibriumAMR should be changed to take
       ! an cluster_class object as an input variable in future.
       ALLOCATE(source(nSource))
       
       ! Restricting the source to be within the root cell (in case the root cell is 
       ! is smaller than the sph model space!
       j = 0 
       do i = 1, nstar
          a_star = get_a_star(young_cluster, i)
          ! using a function in source_mod
          if ( source_within_octal(a_star, grid%octreeRoot) ) then
             j = j+1
             source(j) = a_star
          end if
       end do
       
!    case("jets")
!       !  This should be consistent with the contfile read 
!       !  in amrStateq later! 
!       nSource = 1
!       allocate(source(1:1))
!       source(1)%radius = get_jets_parameter("Rmin")
!       source(1)%teff = teff   
!       source(1)%position = VECTOR(0.,0.,0.)
!       tmp = source(1)%radius * 10.e10  ! [cm]
!       source(1)%luminosity = fourPi * stefanBoltz * (tmp*tmp) * (source(1)%teff)**4
!       call fillSpectrumBB(source(1)%spectrum, dble(teff), &
!            dble(lamStart), dble(lamEnd),nLambda)
!       call normalizedSpectrum(source(1)%spectrum)

    case("shakara","clumpydisc")
       nSource = 1
       allocate(source(1:1))
       source(1)%radius = grid%rCore
       source(1)%teff = teff   
       source(1)%position = VECTOR(0.,0.,0.)
       tmp = source(1)%radius * 1.e10  ! [cm]
       source(1)%luminosity = fourPi * stefanBoltz * (tmp*tmp) * (source(1)%teff)**4
       call fillSpectrumBB(source(1)%spectrum, dble(teff), &
            dble(lamStart), dble(lamEnd),nLambda)


!       call readSpectrum(source(1)%spectrum, "kurucz.dat")
       call normalizedSpectrum(source(1)%spectrum)


    case("aksco")
       nSource = 2
       allocate(source(1:2))
       source(1)%radius = 1.6 * rSol / 1.e10
       source(1)%teff = 6500.
       source(1)%luminosity = fourPi * stefanBoltz * (source(1)%radius*1.e10)**2 * source(1)%teff**4
       source(2) = source(1)
       source(1)%position = VECTOR(0.15*autocm/1.e10,0.,0.)
       source(2)%position = VECTOR(-0.15*autocm/1.e10,0.,0.)
       call fillSpectrumBB(source(1)%spectrum, dble(teff), &
            dble(lamStart), dble(lamEnd),nLambda)
       call normalizedSpectrum(source(1)%spectrum)
       call fillSpectrumBB(source(2)%spectrum, dble(teff), &
            dble(lamStart), dble(lamEnd),nLambda)
       call normalizedSpectrum(source(2)%spectrum)


    case default
       ! Allocating the source array with size =0 to avoid, non-allocated array passed problem
       ! in subroutine initPhoton...
       if (.not. allocated(source)) ALLOCATE(source(0))
       nSource = 0  ! This must be zero!
       
  end select

  
  

     if (geometry == "wr104") then
!        call IntegratePathAMR(lambdatau,  lamLine, VECTOR(1.,1.,1.), zeroVec, &
!             VECTOR(0.,0.,1.), grid, lambda, tauExt, tauAbs, &
!             tauSca, maxTau, nTau, opaqueCore, escProb, .false. , &
!             lamStart, lamEnd, nLambda, contTau, hitCore, thinLine, .false., &
!             .false., nUpper, nLower, 0., 0., 0., junk,&
!             sampleFreq,intPathError)
!        if (intPathError < 0) then
!           write(*,*) '   Error encountered in cross-sections!!! (error = ',intPathError,')'
!        end if
        totalMass = 0.d0
        call findTotalMass(grid%octreeRoot, totalMass)
        scaleFac = massEnvelope / totalMass
!$MPI     if (my_rank==0) &
        write(*,'(a,1pe12.5)') "Density scale factor: ",scaleFac
        call scaleDensityAMR(grid%octreeRoot, scaleFac)

     else if (geometry == "cluster") then
        call find_average_temperature(grid, T_ave, T_mass, totalMass)
!$MPI     if (my_rank==0)  then
        write(*,*) " "
        write(*,'(a,1pe12.4, a5)') "Total dust mass in cluster  : ", TotalMass, " [g]"
        write(*,'(a,1pe12.4, a5)') "Ave. temperature of cluster : ", T_ave,    " [K]"
        write(*,'(a,1pe12.4, a5)') "Mass weighted ave. temperature of cluster : ",T_mass,  " [K]"
        write(*,*) " "
!$MPI     end if
        ! computing the max, min and average tau at 2 micron (of all
        ! active cells)
        ilambda = findIlambda(20000.0, xArray, nLambda, ok)
        call find_max_min_ave_tau(grid, ilambda, tau_max, tau_min,  tau_ave)
!$MPI     if (my_rank==0)  then
        write(*,*) " "
        write(*,'(a,1pe12.4, a11)') "Max tau(1 micron) = ", tau_max, " [continuum]"
        write(*,'(a,1pe12.4, a11)') "Min tau(1 micron) = ", tau_min, " [continuum]"
        write(*,'(a,1pe12.4, a11)') "Ave tau(1 micron) = ", tau_ave, " [continuum]"
        write(*,*) " "
!$MPI     end if
     end if





     if (mie) then
        totalMass =0.d0
        call findTotalMass(grid%octreeRoot, totalMass)
        write(*,*) "Dust mass of envelope: ",totalMass/mSol, " solar masses"
	if (geometry == "shakara") then
        sigma0 = totalMass / (twoPi*(rOuter*1.e10-rInner*1.e10)*1.*autocm) ! defined at 1AU
        write(*,*) "Sigma0: ",sigma0
	endif
     endif


  if (lucyRadiativeEq) then

!$MPI     if (my_rank==0) &
     call tune(6, "LUCY Radiative Equilbrium")  ! start a stopwatch
 
     if (grid%cartesian .or. grid%polar) then
        call lucyRadiativeEquilibrium(grid, miePhase, nMuMie, nLambda, xArray, dble(teff), nLucy)
     else
        if (readLucy .and. .not. redoLucy) then
           continue
        else
           if (solveVerticalHydro) then
              call verticalHydrostatic(grid, mCore, sigma0, rInner, miePhase, nMuMie, nLambda, xArray, &
                   source, nSource, nLucy, massEnvelope, tThresh, twod, mDisc)
           else
              call lucyRadiativeEquilibriumAMR(grid, miePhase, nMuMie, & 
                   nLambda, xArray, source, nSource, nLucy, massEnvelope, tthresh, lucy_undersampled, twod)
           endif
        endif
        
!$MPI        if (my_rank==0) then
        if (writeLucy) call writeAMRgrid(lucyFilenameOut,writeFileFormatted,grid)
!$MPI        end if

     endif     

!$MPI     if (my_rank==0) &
     call tune(6, "LUCY Radiative Equilbrium")  ! stop a stopwatch


     if (grid%geometry(1:7) == "cluster") then
!$MPI        if (my_rank==0) then
        ! Finding apperant magnitudes and colors of the stars in cluster
        write (*,*) " "
        write (*,*) "Computing the magnitudes and colors of stars ..."
        ! -- note grid distance here is in [pc]
         call tune(6, "Color") ! start a stopwatch
         call analyze_cluster(young_cluster,s2o(outVec),dble(gridDistance),grid)
         call tune(6, "Color") ! stop a stopwatch

!$MPI        end if
!$MPI     ! Synchronizing everybody here.
!$MPI     call MPI_BARRIER(MPI_COMM_WORLD, ierr) 


        ! restricting the sed and images calculations to the star 
        ! with ID number = idx_restrict_star. 
        ! By default idx_restrict_star =0 which means all stars the cluster
        ! are included in the calculations.  Specifty a value in your
        ! parameter file to restrict to one star.  (10 AU cylinder
        ! zone is used to restrict the effective computational domain.
        call restrict(grid%octreeroot, idx_restrict_star, nsource, &
                      source,  s2o(outVec), 7.5d4) ! the last value is 50 AU (in 10^10cm)
	!                      source,  s2o(outVec), 1.5d4) ! the last value is 10 AU (in 10^10cm)

        call reassign_10K_temperature(grid%octreeroot)

        ! delete the cluster object since it won't be used any more.
        call kill_all(young_cluster)
     end if 



     ! Plotting the slices of planes
!$MPI        if (my_rank==0) then
     if (plot_maps) then
       call plot_AMR_planes(grid, "temperature", plane_for_plot, 3, "temperature", &
            .true., .false., nmarker, xmarker, ymarker, zmarker, show_value_3rd_dim)
       call plot_AMR_planes(grid, "etaCont", plane_for_plot, 3, "etaCont", .true., .false., &
            nmarker, xmarker, ymarker, zmarker, show_value_3rd_dim)
     end if
!$MPI        end if

!$MPI     ! Synchronizing everybody here.
!$MPI     call MPI_BARRIER(MPI_COMM_WORLD, ierr) 


  endif
  

     !
     ! Setting the emission bias.
     !
     if ((grid%geometry == "testamr").or.(geometry=="proto")) then
	write(*,*) "Setting bias..."
        call setBiasAMR(grid%octreeRoot, grid)
     elseif (grid%geometry == "cluster") then
        ! Computing the emission bias based on the optical depth at
        ! 2 microns. 
        call assign_emission_bias(grid%octreeroot, grid, 20000.0, xArray, nLambda)
!     elseif (grid%geometry == "shakara") then
!        call setBiasDisc(grid%octreeRoot,grid)
     end if


  
  ! initialize the blobs if required

    if (nBlobs > 0) then
  
       allocate(blobs(1:maxBlobs))
       if (freshBlobs) then
          do i = 1 , maxBlobs
             blobs(i)%inUse = .false.
          enddo
!$MPI     if (my_rank==0) &
          write(*,'(a)') "Running blobs for five days..."
   
          ! now we run a few of days worth of blobs
  
          t1 = 0.
          t2 = 240. * 60. * 60.
          dTime = (t2 - t1) / 100.
          do i = 1, 100
             call addNewBlobs(grid, maxBlobs, blobs, blobTime, dTime, &
                              nCurrent, blobContrast)
             call moveBlobs(maxBlobs, blobs, 0., dTime, grid)
!$MPI     if (my_rank==0) &
             write(*,*) i,nCurrent
          enddo
  
          j = 0 
          do i = 1, maxBlobs
             if (blobs(i)%inUse) j = j + 1
          enddo
  
!$MPI     if (my_rank==0) &
          write(*,'(a,i3)') "Number of blobs after 5 days: ",j
  
  
          dTime = 0.
          if (nPhase /= 1) then
             dTime = (timeEnd - timeStart) / real(nPhase-1)
          endif
  
          open(50,file="files.lis",status="unknown",form="formatted")
  
!$MPI     if (my_rank==0) &
          write(*,'(a)') "Running blobs and writing configuration files"
          do i = 1, nPhase
  
             thisTime = timeStart + (timeEnd-timeStart)*real(i-1)/real(nPhase-1)
!$MPI             if (my_rank==0) &
             write(specFile,'(a,i3.3,a)') trim(outfile),i,".dat"
!$MPI             if (my_rank==0) &
             write(50,*) specFile(1:30),thisTime
  
             call addNewBlobs(grid, maxBlobs, blobs, blobTime, dTime, nCurrent, blobContrast)
             call moveBlobs(maxBlobs, blobs, 0., dTime, grid)
!$MPI             if (my_rank==0) &
             write(filename,"(a,i3.3,a)") "run",i,".blob"
!$MPI             if (my_rank==0) &
             call writeBlobs(filename, maxBlobs, blobs)
  
          enddo
  
          close(50)
  
       endif
    endif
!    call writeBlobPgp(originalViewVec, timeStart, timeEnd, nphase, maxBlobs)


  if (plotVelocity) then
!$MPI             if (my_rank==0) &
     write(*,*) ' Plotting velocity vectors...'
!$MPI             if (my_rank==0) &
     call plotVelocityVectors(grid, device)
  endif



  if (nPhase /= 1) then
     dTime = (timeEnd - timeStart) / real(nPhase-1)
  endif

  if (doRaman) then
     ramanSourceVelocity = (ramVel/cSpeed)*VECTOR(0.,-1., 0.)
!$MPI             if (my_rank==0) &
     write(*,'(a,f7.1,a)') "Raman source speed: ",modulus(ramanSourceVelocity)*cSpeed/1.e5, " km/s"
  endif


  !
  ! Redefining the rotation axis here.
  !
  if (geometry == "ttauri") then
     rotationAxis = grid%diskNormal
!$MPI             if (my_rank==0) &
     write(*,*) "rotation axis",rotationAxis
  endif

  if (geometry == "donati") then
     rotationAxis = rotateX(rotationAxis, -dipoleOffset)
  endif

  if (geometry == "jets") then
     rotationAxis = VECTOR(1., 0., 0.)
  end if 

  if (distortionType == "spiral") then
     rotationAxis = rotateX(rotationAxis, dipoleOffset)
  endif




  normToRotation = rotationAxis .cross. yAxis
  call normalize(normToRotation)

  tempVec  = arbitraryRotate(rotationAxis, inclination, normToRotation)
  originalViewVec =  (-1.)*tempVec


  if (modulus(thermalElectronVelocity(10000.)) == 0.) then
!$MPI             if (my_rank==0) &
     write(*,'(a)') "THERMAL ELECTRON BROADENING IS OFF!!!!!!!!!!!!!!!!!!!!!!!!!!"
  endif

  ! default phase indecies
  iphase_beg = nStartPhase
  iphase_end = nEndPhase


!$MPI  !====================================================================================
!$MPI  ! From here we do multiple runs if required !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!$MPI  ! Splitting the phase loop for multiple processors.
!$MPI  if (my_rank == 0) then
!$MPI     print *, ' '
!$MPI     print *, 'iPhase Loops computed by ', np, ' processors.'
!$MPI     print *, ' Note: Ignoreing nStartPhase and nEndPhase parameters from your input file.'
!$MPI     print *, ' '
!$MPI
!$MPI  endif
!$MPI
!$MPI  mphase = nEndPhase - nStartPhase + 1
!$MPI
!$MPI  ! No need to use some processors if there are more processors
!$MPI  ! than the number of phases....
!$MPI  if (my_rank > mphase-1 )  goto 666
!$MPI    
!$MPI  ! Set the range of index for a photon loop used later.     
!$MPI  n_rmdr = MOD(mphase,n_proc)
!$MPI  m = mphase/n_proc
!$MPI
!$MPI  if (my_rank < n_rmdr ) then
!$MPI     iphase_beg = (m+1)*my_rank + 1
!$MPI     iphase_end = iphase_beg + m
!$MPI  else
!$MPI     iphase_beg = m*my_rank + 1 + n_rmdr
!$MPI     iphase_end = iphase_beg + m -1
!$MPI  end if
!$MPI
!$MPI  print *, '  '
!$MPI  print *, 'rank       = ', my_rank
!$MPI  print *, 'iphase_beg = ', iphase_beg
!$MPI  print *, 'iphase_end = ', iphase_end
!$MPI  
!$MPI  
!$MPI  !  Just for safety.
!$MPI  if (iphase_end .gt. mphase .or. iphase_beg < 1) then
!$MPI     print *, 'Index out of range: i_beg and i_end must be ' 
!$MPI     print *, ' 0< index < ', mphase , '    ... [torusMain]'
!$MPI     print *, 'iphase_beg = ', iphase_beg
!$MPI     print *, 'iphase_end = ', iphase_end
!$MPI     stop
!$MPI  end if
!$MPI  !====================================================================================


  do iPhase = iphase_beg, iphase_end
          

     call unixTimes(cpuTime, startTime)

     viewVec = originalViewVec
     outVec = (-1.)*viewVec
     thisVec = viewVec

     ! we rotate the view by an appropriate amount


     if (rotateView.and.(nPhase /= 1)) then
!$MPI        if (my_rank==0) &
        write(*,'(a)') "Rotating view..."
        phi = -rotateDirection * twoPi * real(iPhase-1)/real(nPhase-1)
        viewVec =  arbitraryRotate(thisVec, phi, rotationAxis)
        outVec = (-1.) * viewVec
!$MPI        if (my_rank==0) &
        write(*,'(a,f5.2,a,f5.2,a,f5.2,a)') "View vector: (",viewVec%x,",", &
             viewVec%y,",",viewVec%z,")"
     endif

     if (phaseOffset /= 0.) then
!$MPI        if (my_rank==0) &
        write(*,'(a,f5.2)') "Rotating by phase offset: ",phaseOffset
        phi = twoPi * phaseOffset
        viewVec =  arbitraryRotate(viewVec, phi, rotationAxis)
        outVec = (-1.) * viewVec
     endif


     if (tiltView.and.(nPhase /= 1)) then
        phi = -twoPi * real(iPhase-1)/real(nPhase-1)
        viewVec =  arbitraryRotate(thisVec, phi, xAxis)
        outVec = (-1.) * viewVec
     endif



     ! zero the output arrays

     yArray(1)%i = 0.
     yArray(1)%q = 0.
     yArray(1)%u = 0.
     yArray(1)%v = 0.
     do i = 2, nLambda
        yArray(i)%i = 0.
        yArray(i)%q = 0.
        yArray(i)%u = 0.
        yArray(i)%v = 0.
     enddo

     if (doRaman) then
        yArray(1:nLambda)%i = 1.e-20
     endif
     
     if (stokesimage) then
        
        imageCentre = OCTALVECTOR(0.d0,0.d0,0.d0)
        if (gridUsesAMR) imageCentre = grid%octreeRoot%centre

        ! bulid a filter to be used for imaging
        ! -- using a routine in filter_set_class
        call make_filter_set(filters, filter_set_name)
        
        ! number of images = number of filters
        nImage = get_nfilter(filters)

        ! Allocate the image array
        if (allocated(obsImageSet)) deallocate(obsImageSet)
        allocate(obsImageSet(nImage))
        
        ! Initializing the images ...

        if (setImageSize == 0.) then
           if (grid%adaptive) then
              if (amr2d) then
                 imageSize = 2.*grid%octreeRoot%subcellSize
              else
                 imageSize = grid%octreeRoot%subcellSize          
              endif
           else if (grid%cartesian) then
              imageSize = grid%xAxis(grid%nx)-grid%xAxis(1)
           else
              imagesize = 2.*grid%rAxis(grid%nr)
           endif
        else
           imageSize = setImageSize / 1.e10
        endif

        do i = 1, nImage           
           if (grid%cartesian) then     
              obsImageSet(i) = initImage(npix, imageSize, vmin, vmax)
              if (doRaman) then
                 o6image(1) = initImage(npix, imageSize, vmin, vmax)
              endif
           else if (grid%adaptive) then
              obsImageSet(i) = initImage(npix, imageSize, vmin, vmax)
           else   
              select case (geometry)
              case("disk")
                 obsImageSet(i) = initImage(npix, grid%rAxis(grid%nr), vMin, vMax)
              case("flared")
                 obsImageSet(i) = initImage(npix, 4.*grid%rAxis(1), vMin, vMax)
              case DEFAULT
                 obsImageSet(i) = initImage(npix, imageSize, vMin, vMax)
              end select
           endif
        end do
        
     endif


     if (dopvImage) then

        if (nSlit  > 1) then
           rHat = slitPosition2 - slitPosition1
           do iSlit = 1, nSlit
              slitPosition = slitPosition1 + (real(iSlit-1)/real(nSlit-1))*(slitPosition2 - slitPosition1)
              pvImage(iSlit) = initPVimage(nv, vMin, vMax, np, -slitLength/2., slitLength/2., &
                   slitPosition, slitPA, slitWidth, slitLength)
           enddo
        else
           slitPosition = slitPosition1
           pvImage(1) = initPVimage(200, vMin, vMax, 200, -slitLength/2., slitLength/2., &
                slitPosition, slitPA, slitWidth, slitLength)
        endif
           
     endif


     ! refill the grids 
     
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!              
     if (.not.plezModelOn .and. .not. gridUsesAMR) then
        select case(geometry)
        case("torus")
!           call fillGridTorus(grid, rho, rTorus, rOuter)
        case("sphere")
           call fillGridSpheriod(grid, rho, radius, kFac)
        case("ellipse")
           call fillGridEllipse(Grid,rho,  rMin, rMaj, rInner, teff)
        case("flared")
!           call fillGridFlaredDisk(grid)
        case("disk")
!           call fillGridDisk(grid, rho, rCore, rInner, rOuter, height, mCore, diskTemp)
        case("star")
           call fillGridStar(grid, radius, mdot, vel, kfac, scale)
        case("spiral")
           call fillGridSpiral(grid, radius, mdot, vel,  scale)
        case("shell")
           call fillGridShell(grid, radius, shellFrac, rho, kfac)
        case("stateq")
           call fillGridStateq(grid, opacityDataFile, kfac, scaleDensity)
        case("bipolar")
           call fillGridBipolar(grid, rho, 30.)
        case("collide")
           call fillGridCollide(grid, rho, momRatio, binarySep, mie, meanDustParticleMass, logMassLossRate)
        case("dustblob")
           call fillGridDustBlob(grid, dustBlobdistance, rho, phiDustBlob, &
                                 xDustBlobSize, yDustBlobSize, zDustBlobSize)
        case("raman")
           call  fillGridRaman(grid, 10.*rStar, mdot, vterm, rStar, coolStarPosition, beta)
        case("binary")
!           call fillGridBinary(grid, opacityDataFile, opacityDataFile2, momRatio, mass1, mass2, period, shockwidth, shockFac)
        case("rolf")
!           call fillGridRolf(grid, mdot, vterm)
        case("wr137")
           call fillGridWR137(grid, rCore, mDot, vTerm, beta, temp1)
        case("planet")
!           call fillGridPlanet(grid)
        case("hourglass")
!           call fillGridHourglass(grid)

        case("ttauri")
           if (enhance) then
              call fillGridMagneticAccretion(grid,contfluxfile, popFileName, &
                   readPops, writePops, lte,  lamLine, Laccretion, Taccretion, sAccretion, &
                   curtains, dipoleOffset, nLower, nUpper, theta1, theta2)
              call infallEnhancment(grid, distortionVec, nVec, dTime, .true.)
           endif
        !        call fillGridMagneticAccretion(grid)
        case("ttwind")
        
        case("betacep")
           !        call fillGridBetaCep(grid)
        case("donati")
!           call fillGridDonati(grid, resonanceLine)
        case("puls")
           if (nBlobs > 0) then
              write(filename,"(a,i3.3,a)") "run",iPhase,".blob"
              call readBlobs(filename, maxBlobs, blobs, .false.)
              call fillGridPuls(grid, mDot, rCore, tEff, v0, vterm, beta, xfac, blobs, maxBlobs, .true., vContrast)
        endif

        case("wind")
           if (nblobs > 0) then
              call fillGridWind(grid, mDot, rCore, tEff, v0, vterm, beta, &
                   lte, contFluxFile, writePops, readPops, popFilename, nLower, nUpper, vrot)
              call initgridstateq(grid, contfluxFile, " ", popFileName, &
                   readPops, writePops, lte, nLower, nUpper)

              grid%etaCont = 1.e-30
              grid%kappaAbs = 1.e-30
              grid%kappaSca = 1.e-30
           endif

        case("resonance")
!           call fillGridResonance(grid, rCore, mDot, vTerm, beta, temp)

        case("wr104")
           continue

        case("cluster")
           ! do nothing
           continue

        case("aksco")
           continue
           
        case DEFAULT
!$MPI        if (my_rank==0) &
           write(*,*) "! Unrecognised grid geometry: ",trim(geometry)
           goto 666
        end select
     endif

     if (.not. gridUsesAMR) then


        if (fillTio) then
           call fillGridTio(grid, scale)
        endif
   
        if (fillRayleighOpacity) then
           call fillGridRayleigh(grid,scale)
        endif
   
        if (fillThomson) then
           call fillGridThomson(grid)
        endif
   

        select case(distortionType)
        case("spiral")
!           call distortGridSpiral(grid, vRot, nSpiral)
        case("rotation")
!           call distortRotation(grid, vRot)
!           write(*,'(a,f5.1,a)') "Grid distorted by a rotational velocity of ",vRot/1.e5," km/s"
        case("test")
           call distortGridTest(grid)
!        case("raman")
!           call distortRaman(grid)
         case("raman")
            call  distortStrom(grid, secondSourcePosition, .true., .true., 0.5*rStar, coolStarPosition, ramanDist)
        case("wrdisk")
           call distortWRdisk(grid)
   
        case("windwind")
           call distortWindCollision(grid, momRatio, binarySep)
   
        end select
   
        ! we read in the blob configuration from a file

     end if ! (.not. gridUsesAMR)

     if (nBlobs > 0) then
!$MPI        if (my_rank==0) &
        write(filename,"(a,i3.3,a)") "run",iPhase,".blob"
        call readBlobs(filename, maxBlobs, blobs, .false.)
        call distortGridWithBlobs(grid, maxBlobs, blobs)
     endif

!     if (geometry == "melvin") then
!        write(*,*) "Bias centre volume..."
!        call biasCentreVolume(grid%octreeRoot, imageSize)
!        write(*,*) "done."
!     endif

     
     

     if (geometry .eq. "rolf") then
        if (gridUsesAMR) then
           !      is this correct vvvvvvvvvvvvvvvvvvvvvv ?
           secondSourcePosition = grid%octreeRoot%centre
        else
           secondSourcePosition = VECTOR(grid%xAxis(grid%nx/2), &
             grid%yAxis(grid%ny/2), &
             grid%zAxis(grid%nz/2))
        end if
     endif

     ! if we are producing a movie then plot this phase


     allocate(lambda(1:maxTau))
     allocate(tauExt(1:maxTau))
     allocate(tauAbs(1:maxTau))
     allocate(tauSca(1:maxTau))
     allocate(contTau(1:maxTau,1:maxLambda))
     allocate(contWeightArray(1:maxTau))



     additionalExtinction = .false.

     if ((tauExtra > 0.).or.(tauExtra2 > 0.)) then
        additionalExtinction = .true.
        allocate(foreGroundKappaAbs(1:nLambda))
        allocate(foreGroundKappaSca(1:nLambda))
        allocate(foreGroundKappaAbs2(1:nLambda))
        allocate(foreGroundKappaSca2(1:nLambda))
        call setKappa(foregroundKappaAbs, foregroundkappaSca, &
             xArray, nLambda, 0.005, 0.25, 1., 3.5, 0.,  "amc_zb")
        iLambda = findIlambda(lambdaTau, xArray,  nLambda, ok)
        testKappaAbs = foregroundKappaAbs(ilambda)
        testKappaSca = foregroundKappaSca(ilambda)
        call setKappa(foregroundKappaAbs2, foregroundkappaSca2, &
             xArray, nLambda, 0.005, 0.25, 1., 3.5, 0.,  "sil_dl")
        iLambda = findIlambda(lambdaTau, xArray,  nLambda, ok)
        testKappaAbs2 = foregroundKappaAbs2(ilambda)
        testKappaSca2 = foregroundKappaSca2(ilambda)
     endif



     if (movie) then
        if (device(2:3) == "xs") then
           call plotGrid(grid, viewVec,  opaqueCore, &
                device,contTau, foreground, background, coolStarPosition, firstPlot)
        endif
!
!! COMMENTED OUT FOR DEBUG
!!        write(filename,"(a,i3.3,a)") "frame",iPhase,".gif/gif"
!$MPI        if (my_rank==0) &
        write(filename,"(a,i3.3,a)") "frame",iPhase,".ps/vcps"
        call plotGrid(grid, viewVec,  opaqueCore, &
             filename, contTau, foreground, background, coolStarPosition, firstPlot)
     endif
       

     ! chuck out some useful information to the user

!$MPI        if (my_rank==0) then
     write(*,*) " "
     write(*,'(a)') "Some basic model parameters"
     write(*,'(a)') "---------------------------"
     write(*,*) " "
!$MPI        end if


     !
     ! Performs various optical depth tests here...
     !
!$MPI        if (my_rank==0) &
     call test_optical_depth(gridUsesAMR, octalvector(1.d-6,1.d-6,1.d-6), sphericityTest,  &
          outVec, lambdatau,  lambdatau, grid, opaqueCore, lamStart, lamEnd,  &
          thinLine, nUpper, nLower, sampleFreq, useinterp, grid%Rstar1, coolStarPosition)

!$MPI     ! Synchronizing everybody here.
!$MPI     call MPI_BARRIER(MPI_COMM_WORLD, ierr)



     weightLinePhoton = 0.
     weightContPhoton = 1.


     if (mie) then
        call computeProbDist(grid, totLineEmission, &
             totDustContinuumEmission,lamline, .false.)
        totDustContinuumEmission = totdustContinuumEmission 
        lcore = grid%lCore
        if (nSource > 0) then
           lCore = 0.
           do i = 1, nSource
              lCore = lCore + source(i)%luminosity
           enddo
        endif


        totEnvelopeEmission = totDustContinuumEmission
        chanceDust = totDustContinuumEmission/(totDustContinuumEmission+lCore/1.e30)
!$MPI        if (my_rank==0) &
        write(*,*) "totdustemission",totdustcontinuumemission
!$MPI        if (my_rank==0) &
        write(*,'(a,f7.2)') "Chance of continuum emission from dust: ",chanceDust

        weightDust = chanceDust / probDust
        weightPhoto = (1. - chanceDust) / (1. - probDust)


!$MPI        if (my_rank==0) &
        write(*,*) "core + envelope luminosity",lCore+totEnvelopeEmission*1.d30
        energyPerPhoton =  ((lCore + totEnvelopeEmission*1.d30) / dble(nPhotons))/1.d20
!$MPI        if (my_rank==0) &
        write(*,*) "Energy per photon: ", energyPerPhoton

     endif

     



     if (geometry == "hourglass") then
        call computeProbDist(grid, totLineEmission, &
             totWindContinuumEmission,lamline, .false.)
        weightLinePhoton = 1.
        weightContPhoton = 0.
        probLinePhoton = 1.
        probContPhoton = 0.
     endif

     if (doRaman) then
        call computeProbDist(grid, totLineEmission, &
             totWindContinuumEmission,lamline, .false.)
!$MPI        if (my_rank==0) &
        write(*,*) "Total Raman Line Emission: ",totLineEmission
        weightLinePhoton = 1.
        weightContPhoton = 0.
        probLinePhoton = 1.
        probContPhoton = 0.
     endif


     if (grid%lineEmission) then

        ! integrate the line and continuum emission and read the 
        ! intrinsic profile

        if (coreEmissionLine) then
           totLineEmission = 0.
           totWindContinuumEmission = 0.
        else
           if (.not.grid%resonanceLine) then
              call computeProbDist(grid, totLineEmission, &
                   totWindContinuumEmission,lamline, useBias)

              ! convert from per steradian
              
              totLineEmission = totLineEmission * fourPi
              totWindContinuumEmission = totwindContinuumEmission * fourPi
           endif
        endif

!        write(*,'(a)') "mu axis"
!        do i = 1, grid%nMu
!           write(*,*) i,acos(grid%muAxis(i))*radtodeg, &
!                             grid%muProbDistLine(grid%nr/2,i)
!        enddo
!        write(*,'(a)') "Phi axis"
!        do i = 1, grid%nPhi
!           write(*,*) i,grid%phiAxis(i)*radtodeg, grid%phiProbDistLine(grid%nr/2,grid%nmu/2,i)
!        enddo



        if (geometry == "donati") totWindContinuumEmission = 0.

        if (geometry == "binary") totWindContinuumEmission = 0.

        if (grid%resonanceLine) totWindContinuumEmission = 0.

        if (geometry == "ttauri") then
           totWindContinuumEmission = 0.
!$MPI        if (my_rank==0) &
           write(*,'(a)') "! Wind continuum emission switched off."
        endif

        if (lineOff) then
           totLineEmission = 0.
        endif

        nu = cSpeed / (lamLine * angstromtocm)
!$MPI        if (my_rank==0) &
        write(*,*) "Line emission: ",totLineEmission
!$MPI        if (my_rank==0) &
        print *, 'nu = ',nu

        select case(geometry)
           case("binary")
              call contread(contFluxFile, nu, totCoreContinuumEmission1)
              call contread(contFluxFile2, nu, totCoreContinuumEmission2)
           case("puls")
              totCoreContinuumEmission = pi * blackBody(0.77 * tEff, lamLine)
           case DEFAULT
              call contread(contFluxFile, nu, totCoreContinuumEmission)
        end select


        ! reads the intrinsic core absorption profile for core-halo models


        if (trim(intProFilename) /= "none") then
           call rdIntPro(intProFilename, intPro, lamIntPro, nIntPro)
           allocate(splineArray(1:nIntPro))
           call spline(lamIntPro, intPro, nIntPro, 0., 0., splineArray)
           do iSpline = 1 , nLambda
              if ((xArray(iSpline) < lamIntPro(1)) .or.  &
                   (xArray(iSpline) > lamIntPro(nIntPro))) then
                 sourceSpectrum(iSpline) = 1.
              else
                 call splint(lamIntPro, intPro, splineArray, nIntPro, &
                      xArray(iSpline), sourceSpectrum(iSpline))
              endif
           enddo
           deallocate(splineArray)
        endif

        if (geometry == "binary") then
           call rdIntPro(intProFilename2, intPro, lamIntPro, nIntPro)
           allocate(splineArray(1:nIntPro))
           call spline(lamIntPro, intPro, nIntPro, 0., 0., splineArray)
           do iSpline = 1 , nLambda
              if ((xArray(iSpline) < lamIntPro(1)) .or.  &
                   (xArray(iSpline) > lamIntPro(nIntPro))) then
                 sourceSpectrum2(iSpline) = 1.
              else
                 call splint(lamIntPro, intPro, splineArray, nIntPro, &
                      xArray(iSpline), sourceSpectrum2(iSpline))
              endif
           enddo
           deallocate(splineArray)
        endif

        ! the core can emit as a Gaussian emission line

        if (coreEmissionLine) then
           call computeCoreEmissionProfile(xArray, sourceSpectrum, nLambda, &
                lamLine, velWidthCoreEmissionLine, relIntCoreEmissionLine)
        endif


        nuStart = cSpeed / (lamStart * angstromtocm)
        nuEnd = cSpeed / (lamEnd * angstromtocm)

        totWindContinuumEmission = totWindContinuumEmission * (nuStart - nuEnd)

!$MPI        if (my_rank==0) &
        write(*,*) "Wind cont emission: ",totWindContinuumEmission


! factor of four pi taken out from below - input continuum files are expected
! to be in fluxes (erg/s/cm^2/hz) not Hnu's

        if (geometry /= "binary") then
           totCoreContinuumEmission = (totCoreContinuumEmission * &
                (nuStart - nuEnd))*fourPi*grid%rCore**2 
        else
           totCoreContinuumEmission1 = totCoreContinuumEmission1 * (nuStart-nuEnd) * fourPi * grid%rStar1**2
           totCoreContinuumEmission2 = totCoreContinuumEmission2 * (nuStart-nuEnd) * fourPi * grid%rStar2**2
           totCoreContinuumEmission = totCoreContinuumEmission1 + totCoreContinuumEmission2
           grid%lumRatio = totCoreContinuumEmission1 / totCoreContinuumEmission

           allocate(lambda(1:maxTau))
           allocate(tauExt(1:maxTau))
           allocate(tauAbs(1:maxTau))
           allocate(tauSca(1:maxTau))
           allocate(contTau(1:maxTau,1:maxLambda))
           allocate(contWeightArray(1:maxTau))

!$MPI        if (my_rank==0) &
           write(*,*) "Binary luminosity ratio (p/s): ",totCoreContinuumEmission1/totCoreContinuumEmission2
        endif
           
        if (geometry == "ttauri") then
              fAccretion =  blackBody(Taccretion, lamLine)*(nuStart-nuEnd)*sAccretion/1.e20
!$MPI        if (my_rank==0) &
              write(*,*) "laccretion/core",fAccretion/totCoreContinuumEmission
              totCoreContinuumEmission = totCoreContinuumEmission + &
                   fAccretion
              chanceHotRing = fAccretion/totCoreContinuumEmission
        endif
        
        chanceSpot = 0.
        if ((geometry == "disk").and.(nSpot > 0)) then
           chanceSpot = fSpot * blackBody(tSpot, 6562.8) / &
                ((1.-fSpot)*blackBody(tEff, 6562.8) + &
                (fSpot * blackBody(tSpot, 6562.8)))
!$MPI        if (my_rank==0) &
           write(*,'(a,f5.3)') "Spot chance at 6563A: ",chanceSpot
        endif



!$MPI        if (my_rank==0) &
        write(*,*) "Core Continuum Emission: ",totCorecontinuumEmission


        totContinuumEmission = totCoreContinuumEmission + totWindContinuumEmission

!$MPI        if (my_rank==0) &
        write(*,*) "Continuum emission: ", totContinuumEmission

        if ((totContinuumEmission + totLineEmission) /= 0.) then
           chanceLine = totLineEmission/(totContinuumEmission + totLineEmission)
           chanceContinuum = totContinuumEmission / &
                (totContinuumEmission + totLineEmission)
           grid%chanceWindOverTotalContinuum = totWindContinuumEmission &
                / max(1.d-30,totContinuumEmission)
        else
           chanceLine =0.
           chanceContinuum = 1.
           grid%chanceWindOverTotalContinuum = 0.
        endif


!$MPI        if (my_rank==0) &
        write(*,*) "Chance continuum emission in wind: ", grid%chanceWindOverTotalContinuum

        ! set up the line and continuum weights

        if ((probLinePhoton /= 0.).and.(probContphoton /= 0.)) then

           weightLinePhoton = chanceLine / probLinePhoton
           weightContPhoton = chanceContinuum / probContPhoton / real(nLambda)
        else
           if (probLinePhoton == 0.) then
              weightLinePhoton = 0.
              weightContPhoton = 1.
           else
              weightLinePhoton = 1.
              weightContPhoton = 0.
           endif
        endif


        energyPerPhoton =  (totLineEmission + totContinuumEmission) / dble(nPhotons)

        energyperphoton = 1.

!$MPI        if (my_rank==0) then
        write(*,*) "Energy per photon: ", energyPerPhoton


        write(*,*) "Line photon weight: ", weightLinePhoton
        write(*,*) "Continuum photon weight: ", weightContPhoton

        write(*,*) " "
        write(*,*) "Line photon prob: ", probLinePhoton
        write(*,*) "Continuum photon prob: ", probContPhoton


        write(*,*) "chance line",chanceline
!$MPI        end if


        ! compute the probability distributions


     endif

     deallocate(lambda)
     deallocate(tauSca)
     deallocate(tauExt)
     deallocate(tauAbs)
     deallocate(contTau)
     deallocate(contWeightArray)




     nContPhotons = nint(probContPhoton * real(nPhotons) / real(nOuterLoop))



!$MPI     if (my_rank==0) then
     write(*,*) " "
     write(*,'(a)') "Run-time messages"
     write(*,'(a)') "-----------------"
     write(*,*) " "
!$MPI     end if


     tot%i = 0.
     tot%q = 0.
     tot%u = 0.
     tot%v = 0.


     k = nPhotons/10

     ntot = 0

     ! now we loop 10 times over a tenth of the photons - this will be used
     ! to help compute the errors

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

     call unixTimes(cpuTime, startTime)


     if (grid%geometry == "donati") then
        junk1 = 0.
        rHat = VECTOR(0.,0.,0.)
        n = 0
        do i = 1, 100000
           call initPhoton(thisPhoton, grid, nLambda, xArray, sourceSpectrum, &
                lineEmission, lamLine, weightLinePhoton, &
                weightContPhoton, contPhoton, flatspec, vRot, pencilBeam, &
                secondSource, secondSourcePosition,  &
                ramanSourceVelocity, vo6, contWindPhoton, directionalWeight, useBias, theta1, theta2, &
                chanceHotRing, &
                nSpot, chanceSpot, thetaSpot, phiSpot, fSpot, spotPhoton, probDust, weightDust, weightPhoto,&
                narrowBandImage, vmin, vmax, source, nSource, rHatinStar, energyPerPhoton, filters, mie, &
                forcedWavelength, usePhotonWavelength)
           if (thisPhoton%linePhoton) then
              junk1 = junk1 + thisPhoton%position%z
              rHat = rHat + thisPhoton%velocity
              n = n + 1
           endif
           if (.not. gridUsesAMR) call getIndices(grid, thisPhoton%position, i1, i2, i3, t1, t2, t3)
        enddo
!$MPI     if (my_rank==0) &
        write(*,*) "Average z position",junk1/real(n)
!$MPI     if (my_rank==0) &
        write(*,*) "Average velocity",((cSpeed/1.d5)*(1.d0/dble(n)))*rHat
     endif

!$MPI     if (my_rank==0) &
     call tune(6, "All Photon Loops")  ! Start a stopwatch
     
     do iOuterLoop = 1, nOuterLoop

!$MPI     if (my_rank==0) &
        call tune(6, "One Outer Phone Loop") ! Start a stop watch

!$OMP PARALLEL DEFAULT(NONE) &
!$OMP PRIVATE(i, contPhoton, contWindPhoton, r, nScat) &
!$OMP PRIVATE(thisPhoton, directionalWeight) &
!$OMP PRIVATE( ilambda, sourceSpectrum, ok) &
!$OMP PRIVATE(hitCore, junk, thisLam, j, weight, thisVel) &
!$OMP PRIVATE(i1, i2, i3, t1, t2, t3, vray, vovercsqr, fac, observedLambda) &
!$OMP PRIVATE(t, rHat, islit, fac1, fac2, fac3, obsPhoton, r1, r2, thisTau) &
!$OMP PRIVATE(escaped, currentScat, absorbed, dlambda, thisChi, thisSca) &
!$OMP PRIVATE(albedo, tempPhoton, redRegion, thrustar, ramanWeight) &
!$OMP PRIVATE(outPhoton,intPathError) &
!$OMP PRIVATE(nTau, escProb, spotPhoton) &
!$OMP PRIVATE(lambda, tauExt, tauSca, tauAbs, contTau, contWeightArray) &
!$OMP PRIVATE(rHatinStar, positionOc) &

!$OMP SHARED(grid) &

!$OMP SHARED(meanr_Cont, wtot_cont,meanr_line,wtot_line, ntot) &
!$OMP SHARED(nContPhotons, nPhotons, lineEmission, lamLine, nLambda) &
!$OMP SHARED(weightLinePhoton, flatSpec, vRot, secondSource, secondSourcePosition) &
!$OMP SHARED(ramanSourceVelocity, vO6, doRaman) &
!$OMP SHARED(weightContPhoton, useBias, pencilBeam ,outVec)&
!$OMP SHARED(opaqueCore, lamStart, lamEnd, thinLine, rStar, coolStarPosition) &
!$OMP SHARED(viewVec, o6xArray,o6yArray, rotationAxis, o6image, screened) &
!$OMP SHARED(xArray, yArray, statArray, stokesImage, obsImageSet, doPvimage) &
!$OMP SHARED(nSlit, pvimage, gridDistance, meanr0_line, wtot0_line) &
!$OMP SHARED(sourceSpectrum2, meanr0_cont,wtot0_cont, maxScat, mie) &
!$OMP SHARED(miePhase, zeroVec, theta1, theta2, chanceHotRing) &
!$OMP SHARED(nSpot, chanceSpot, thetaSpot, phiSpot, fSpot, chanceDust) &
!$OMP SHARED(narrowBandImage, vMin, vMax, gridUsesAMR) &
!$OMP SHARED(sampleFreq, useInterp, photLine,tooFewSamples,boundaryProbs) &
!$OMP SHARED(probDust, WeightDust, WeightPhoto, source, nsource) &
!$OMP SHARED(energyPerPhoton, filters, nUpper, nLower, nImage)


!$OMP DO SCHEDULE(DYNAMIC)
        innerPhotonLoop: do i = 1, nPhotons/nOuterLoop
           allocate(lambda(1:maxTau))
           allocate(tauExt(1:maxTau))
           allocate(tauAbs(1:maxTau))
           allocate(tauSca(1:maxTau))
           allocate(contTau(1:maxTau,1:maxLambda))
           allocate(contWeightArray(1:maxTau))
           ! initlialize them to zero for safty
!           lambda(:) = 0.0; tauExt(:)=0.0; tauAbs(:)=0.0
!           tauSca(:) = 0.0; contTau(:,:) =0.0; contWeightArray(:) =0.0



           ! continuum or line photon?

           if (i <= nContPhotons) then
              contPhoton = .true.
           else
              contPhoton = .false.
           endif

           contWindPhoton = .false.

           ! there is a chance that this continuum photon is produced in the wind rather
           ! than at the core...

           if (lineEmission .and. contPhoton) then
              call random_number(r)
              if (r < grid%chanceWindOverTotalContinuum) then
                 contWindPhoton = .true.
              endif
           endif

           nScat = 0

           ! initialize the photon
           
           contWeightArray(1:maxLambda) = 1.

           select case(grid%geometry)
              case("planet")
                 call initPlanetPhoton(thisPhoton, grid, lamLine)
                 directionalWeight = 1.
                 contWindPhoton = .true.
              case DEFAULT
                 call initPhoton(thisPhoton, grid, nLambda, xArray, sourceSpectrum, &
                      lineEmission, lamLine, weightLinePhoton, &
                      weightContPhoton, contPhoton, flatspec, vRot, pencilBeam, &
                      secondSource, secondSourcePosition, &
                      ramanSourceVelocity, vo6, contWindPhoton, directionalWeight, useBias, &
                      theta1, theta2, chanceHotRing,  &
                      nSpot, chanceSpot, thetaSpot, phiSpot, fSpot, spotPhoton,  probDust, weightDust, weightPhoto,&
                      narrowBandImage, vMin, vMax, source, nSource, rHatinStar, energyPerPhoton, filters, mie, &
                      forcedWavelength, usePhotonWavelength)
                 if (thisPhoton%resonanceLine) then
                    r1 = real(i)/real(nPhotons/nOuterLoop)
                    thisPhoton%lambda = xArray(1) + r1*(xArray(nLambda)-xArray(1))
                 endif

           end select

           observedLambda = thisPhoton%lambda
           if (thisPhoton%contPhoton) then

              meanr_cont = meanr_cont + modulus(thisPhoton%position)*thisPhoton%stokes%i
              wtot_cont = wtot_cont + thisPhoton%stokes%i
           else
              meanr_line = meanr_line + modulus(thisPhoton%position)*thisPhoton%stokes%i
              wtot_line = wtot_line + thisPhoton%stokes%i
           endif



           iLambda = findIlambda(thisPhoton%lambda, xArray, nLambda, ok)

           ! now we fire the photon direct to the observer

           if (doRaman) then
              
              if (gridUsesAMR) then

                 if (grid%octreeroot%threeD) then
                    call IntegratePathAMR(thisPhoton%lambda, lamLine, &
                         s2o(thisPhoton%velocity), &
                         thisPhoton%position, s2o(outVec), grid, &
                         lambda, tauExt, tauAbs, tauSca, maxTau , nTau, opaqueCore, &
                         escProb, thisPhoton%contPhoton, lamStart, lamEnd, &
                         nLambda, contTau, hitCore, thinLine,.false., &
                         .false., nUpper, nLower, 0., 0., 0., junk,&
                         sampleFreq,intPathError)
                 else
                    call IntegratePathAMR(thisPhoton%lambda, lamLine, &
                         s2o(thisPhoton%velocity), &
                         thisPhoton%position, s2o(outVec), grid, &
                         lambda, tauExt, tauAbs, tauSca, maxTau , nTau, opaqueCore, &
                         escProb, thisPhoton%contPhoton, lamStart, lamEnd, &
                         nLambda, contTau, hitCore, thinLine,.false., &
                         .false., nUpper, nLower, 0., 0., 0., junk,&
                         sampleFreq,intPathError)
                 endif


                   if (intPathError == -10) then
                      tooFewSamples = tooFewSamples + 1  
!                      call quickDeallocate
                      deallocate(lambda); deallocate(tauSca); deallocate(tauExt)
                      deallocate(tauAbs); deallocate(contTau); deallocate(contWeightArray)
                      cycle innerPhotonLoop
                   endif
                   if (intPathError == -20) then
                      boundaryProbs = boundaryProbs + 1
!                      call quickDeallocate
                      deallocate(lambda); deallocate(tauSca); deallocate(tauExt)
                      deallocate(tauAbs); deallocate(contTau); deallocate(contWeightArray)
                      cycle innerPhotonLoop
                   endif
               else
                call integratePath(thisPhoton%lambda, lamLine, &
                   thisPhoton%velocity, &
                   o2s(thisPhoton%position), outVec, grid, &
                   lambda, tauExt, tauAbs, tauSca, maxTau , nTau, opaqueCore, &
                   escProb, thisPhoton%contPhoton, lamStart, lamEnd, &
                   nLambda, contTau, hitCore, thinLine,.false., rStar,&
                   coolStarPosition,.false., nUpper, nLower, 0., 0., 0., junk, useInterp)
              end if

              thisLam = thisPhoton%lambda + (thisPhoton%velocity .dot. viewVec) * 1031.928
              j = findIlambda(thisLam, o6xArray, no6pts, ok)
              if (ok) then
                 weight = oneOnFourPi * exp(-tauExt(nTau))
                 o6yArray(j) = o6yArray(j) + weight
                 thisVel = (thisLam-lamLine)/lamLine

                 call addPhotonToImage(viewVec, rotationAxis,o6Image(1), 1, &
                      thisPhoton, thisVel, weight, filters, imageCentre)
              endif
           endif

           if (.not. screened) then


              ! find optical depths to observer



              if (gridUsesAMR) then
                 if (grid%octreeRoot%threeD) then
                    call IntegratePathAMR(thisPhoton%lambda, lamLine, &
                         s2o(thisPhoton%velocity), &
                         thisPhoton%position, s2o(outVec), grid, &
                         lambda, tauExt, tauAbs, tauSca, maxTau, nTau, opaqueCore, &
                         escProb, thisPhoton%contPhoton, lamStart, lamEnd, &
                         nLambda, contTau, hitCore, thinLine,.false.,&
                         .false., nUpper, nLower, 0., 0., 0., junk,&
                         sampleFreq,intPathError)
                 else
                    call IntegratePathAMR(thisPhoton%lambda, lamLine, &
                         s2o(thisPhoton%velocity), &
                         thisPhoton%position, s2o(outVec), grid, &
                         lambda, tauExt, tauAbs, tauSca, maxTau, nTau, opaqueCore, &
                         escProb, thisPhoton%contPhoton, lamStart, lamEnd, &
                         nLambda, contTau, hitCore, thinLine,.false.,&
                         .false., nUpper, nLower, 0., 0., 0., junk,&
                         sampleFreq,intPathError)
                 endif
                    if (intPathError == -10) then
                       tooFewSamples = tooFewSamples + 1  
!                       call quickDeallocate
                       deallocate(lambda); deallocate(tauSca); deallocate(tauExt)
                       deallocate(tauAbs); deallocate(contTau); deallocate(contWeightArray)
                       cycle innerPhotonLoop
                    endif
                    if (intPathError == -20) then
                       boundaryProbs = boundaryProbs + 1
!                       call quickDeallocate 
                       deallocate(lambda); deallocate(tauSca); deallocate(tauExt)
                       deallocate(tauAbs); deallocate(contTau); deallocate(contWeightArray)
                       cycle innerPhotonLoop
                    endif
              else
                 call integratePath(thisPhoton%lambda, lamLine, &
                    thisPhoton%velocity, &
                    o2s(thisPhoton%position), outVec, grid, &
                    lambda, tauExt, tauAbs, tauSca, maxTau, nTau, opaqueCore, &
                    escProb, thisPhoton%contPhoton, lamStart, lamEnd, &
                    nLambda, contTau, hitCore, thinLine,.false., rStar,&
                    coolStarPosition,.false., nUpper, nLower, 0., 0., 0., junk,useInterp)

                 call getIndices(grid,thisPhoton%position,i1,i2,i3,t1,t2,t3)

              end if

              if (additionalExtinction) then
                 nTau = nTau + 1
                 iLambda = findIlambda(thisPhoton%lambda, xArray,  nLambda, ok)
                 tauAbs(nTau) = tauAbs(nTau-1) + tauExtra * foregroundKappaAbs(iLambda)/testKappaAbs
                 tauSca(nTau) = tauSca(nTau-1) + tauExtra * foregroundKappaSca(iLambda)/testKappaSca
                 tauExt(nTau) = tauSca(nTau) + tauAbs(nTau)
                 lambda(nTau) = lambda(nTau-1) + 1.e-20
                 nTau = nTau + 1
                 tauAbs(nTau) = tauAbs(nTau-1) + tauExtra2 * foregroundKappaAbs2(iLambda)/testKappaAbs2
                 tauSca(nTau) = tauSca(nTau-1) + tauExtra2 * foregroundKappaSca2(iLambda)/testKappaSca2
                 tauExt(nTau) = tauSca(nTau) + tauAbs(nTau)
                 lambda(nTau) = lambda(nTau-1) + 1.e-20
              endif


              if (thisPhoton%resonanceLine) escProb = 1.

              if (thisPhoton%linePhoton) then
                 vray = -(thisPhoton%velocity .dot. outVec)
                 vovercsqr = modulus(thisPhoton%velocity)**2
                 fac = (1.d0-0.5d0*vovercsqr*(1.d0-0.5d0*vovercsqr))/(1.d0+vray)
                 observedlambda = thisPhoton%lambda / fac
                 weight = oneOnFourPi * exp(-tauExt(nTau)) * escProb
              endif

              if (thisPhoton%contPhoton.and.(.not.contWindPhoton)) then
                 t = modulus(thisPhoton%position)
                 if (t /= 0.) then
                    rHat = thisPhoton%position / t
                 else
                    rHat = thisPhoton%direction
                 endif
                 t = rHat .dot. outVec

                 if (lineEmission) then
                    weight = abs(t)*exp(-tauExt(nTau)) / pi
                 else
                    weight = oneOnFourPi*abs(t)*exp(-tauExt(nTau))
                 endif
                 observedlambda = thisPhoton%lambda
              endif


              if (.not.flatSpec.and.(.not.hitCore)) then
                 if (contWindPhoton) then
                    weight = oneOnFourPi*exp(-tauExt(nTau))
                 else 
                    directionalWeight = (outVec.dot.rHatinStar)/pi
                    weight = directionalweight*exp(-tauExt(nTau))
                    if (weight < 0.) weight = 0.
                 endif
                 
                 iLambda = findIlambda(observedlambda, xArray,  nLambda, ok)
                 if (ok) then
                    yArray(iLambda) = yArray(iLambda) + &
                         (thisPhoton%stokes * weight)
                    statArray(iLambda) = statArray(iLambda) + 1.
                 endif
                 if (stokesImage) then
                    thisVel = observedLambda
                    call addPhotonToImage(viewVec, rotationAxis, obsImageSet, nImage, thisPhoton,&
                         thisVel, weight, filters, imageCentre)
                 endif
                 if (doPVimage) then
                    do iSlit = 1, nSlit
                       call addPhotontoPVimage(pvImage(iSlit), thisPhoton, viewVec, rotationAxis, thisVel, &
                                 weight, gridDistance)
                    enddo
                 endif
              endif
              
              if (flatSpec.and.(.not.hitCore)) then
                 if (thisPhoton%linePhoton) then
                    fac2 = 1.
!                    if (thisPHoton%resonanceline) fac2 = directionalWeight
                    iLambda = findIlambda(observedlambda, xArray, nLambda, ok)
                    if (ok) then
                       yArray(iLambda) = yArray(iLambda) + &
                            (thisPhoton%stokes * (fac2 * oneOnFourPi * escProb * exp(-tauExt(nTau))))
                       statArray(iLambda) = statArray(iLambda) + 1.
                    endif

                    weight = oneOnFourPi * escProb * exp(-tauExt(nTau))*fac2

                    meanr0_line = meanr0_line + modulus(thisPhoton%position) * &
                         (thisPhoton%stokes%i * weight)
                    wtot0_line = wtot0_line + (thisPhoton%stokes%i * weight)
                    

                    thisVel = (observedLambda-lamLine)/lamLine
                    if (stokesImage) then
                       call addPhotonToImage(viewVec, rotationAxis, obsImageSet, nImage, &
                            thisPhoton, thisVel, weight, filters, imageCentre)
                    endif
                    if (dopvImage) then
                       do iSlit = 1, nSlit
                          call addPhotontoPVimage(pvImage(iSlit), thisPhoton, viewVec,  rotationAxis,thisVel, &
                            weight, gridDistance)
                       enddo
                    endif

                 else
                    i1 = 0
                    do iLambda = 1, nLambda
                       fac1 = 1.
                       if (.not.contWindPhoton) then
                          fac1 = 2.*abs(thisPhoton%originalNormal.dot.outVec)/twoPi
                       else
                          fac1 = oneOnfourPi
                       endif

                       vray = -(thisPhoton%velocity .dot. outVec)
                       vovercsqr = modulus(thisPhoton%velocity)**2
                       fac = (1.d0-0.5d0*vovercsqr*(1.d0-0.5d0*vovercsqr))/(1.d0+vray)
                       observedlambda = thisPhoton%lambda / fac


                       thisLam = (lamLine-observedlambda) + xArray(iLambda)

                       call hunt(xArray,nLambda,thisLam,i1)
                       if (i1 ==0 ) i1 = 1
                       if (grid%geometry /= "binary") then
                          fac2 = sourceSpectrum(i1)

                          if ((grid%geometry == "disk").and.(.not.spotPhoton).and.(.not.photLine)) fac2 = 1.


                       else
                          if (thisPhoton%fromStar1) then
                             fac2 = sourceSpectrum(i1)
                          else
                             fac2 = sourceSpectrum2(i1)
                          endif
                       endif
                       fac3 = contTau(nTau,i1)
                       if (thinLine) fac3 = 0.
                       weight = (fac1 * exp(-(tauExt(ntau)+fac3)))*fac2
                       yArray(iLambda) = yArray(iLambda) + &
                                           (thisPhoton%stokes * weight)
                       statArray(iLambda) = statArray(iLambda) + 1.

                       meanr0_cont = meanr0_cont + modulus(thisPhoton%position) * thisPhoton%stokes%i*weight
                       wtot0_cont = wtot0_cont + thisPhoton%stokes%i*weight
                       thisVel = (observedLambda-lamLine)/lamLine
                       if (stokesImage) then
                          call addPhotonToImage(viewVec,  rotationAxis,obsImageSet, nImage, &
                               thisPhoton, thisVel, weight, filters, imageCentre)
                       endif
                       if (dopvImage) then
                          do iSlit = 1, nSlit
                             call addPhotontoPVimage(pvImage(islit), obsPhoton, viewVec,  rotationAxis, thisVel, &
                               weight, gridDistance)
                          enddo
                       endif

                    enddo
                 endif
              endif

           endif
           

           if (gridUsesAMR) then
              if (grid%octreeRoot%threeD) then
                 call IntegratePathAMR(thisPhoton%lambda, lamLine, &
                      s2o(thisPhoton%velocity), &
                      thisPhoton%position, &
                      thisPhoton%direction, grid, &
                      lambda, tauExt, tauAbs, tauSca, maxTau, nTau, opaqueCore, &
                      escProb, thisPhoton%contPhoton, lamStart, lamEnd, &
                      nLambda, contTau, hitCore, thinLine,.false.,  &
                      .false., nUpper, nLower, 0., 0., 0., &
                      junk,sampleFreq,intPathError)
              else
                 call IntegratePathAMR(thisPhoton%lambda, lamLine, &
                      s2o(thisPhoton%velocity), &
                      thisPhoton%position, &
                      thisPhoton%direction, grid, &
                      lambda, tauExt, tauAbs, tauSca, maxTau, nTau, opaqueCore, &
                      escProb, thisPhoton%contPhoton, lamStart, lamEnd, &
                      nLambda, contTau, hitCore, thinLine,.false.,  &
                      .false., nUpper, nLower, 0., 0., 0., &
                      junk,sampleFreq,intPathError)
              endif
                if (intPathError == -10) then 
                    tooFewSamples = tooFewSamples + 1  
!                               call quickDeallocate
                    deallocate(lambda); deallocate(tauSca); deallocate(tauExt)
                    deallocate(tauAbs); deallocate(contTau); deallocate(contWeightArray)
                    cycle innerPhotonLoop
                endif
                if (intPathError == -20) then
                    boundaryProbs = boundaryProbs + 1
!                               call quickDeallocate
                    deallocate(lambda); deallocate(tauSca); deallocate(tauExt)
                    deallocate(tauAbs); deallocate(contTau); deallocate(contWeightArray)
                    cycle innerPhotonLoop
                endif
           else
             call integratePath(thisPhoton%lambda, lamLine, &
                thisPhoton%velocity, &
                o2s(thisPhoton%position), &
                o2s(thisPhoton%direction), grid, &
                lambda, tauExt, tauAbs, tauSca, maxTau, nTau, opaqueCore, &
                escProb, thisPhoton%contPhoton, lamStart, lamEnd, &
                nLambda, contTau, hitCore, thinLine,.false., rStar, &
                coolStarPosition,.false., nUpper, nLower, 0., 0., 0., junk, useInterp)
           end if

           call random_number(r1)
           fac = (1.d0-exp(-dble(tauExt(nTau))))
           thisTau = min(-log(1.d0-r1*fac),dble(tauExt(nTau)))


           if (thisPhoton%contPhoton) escProb = 1.

           if (thisPhoton%resonanceLine) escProb = 1.


           thisPhoton%stokes = thisPhoton%stokes * (fac * escProb)


           currentScat = 0

           escaped = .false.


           absorbed = .false.
           if (doRaman) hitCore = .false.


! scattering loop !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!1

           do while (.not.escaped .and. .not.absorbed .and. &
                     (nScat < maxScat)   )


              nScat = nScat + 1

              currentScat = currentScat  + 1

              ! find position of next interaction

              call locate(tauExt, nTau, thisTau, j)


              if (j < nTau) then
                 t = 0.
                 if ((tauExt(j+1) - tauExt(j)) /= 0.) then
                    t = (thisTau - tauExt(j)) / (tauExt(j+1) - tauExt(j))
                 endif
                 dlambda = lambda(j) + (lambda(j+1)-lambda(j))*t
              else
                 dlambda = lambda(nTau)
              endif
                    


              thisPhoton%position = thisPhoton%position + real(dlambda,kind=octalkind)*thisPhoton%direction

              if (flatspec) then
                 contWeightArray(1:nLambda) = contWeightArray(1:nLambda) * &
                      exp(-(contTau(j,1:nLambda) + t*(contTau(j+1,1:nLambda)-contTau(j,1:nLambda))))
              endif

              if (grid%nLambda == 1) then
                 iLambda = 1
              else
                  iLambda = findIlambda(thisPhoton%lambda, xArray, nLambda, ok)
              endif

              if (grid%adaptive) then
                 positionOc = thisPhoton%position
                 call amrGridValues(grid%octreeRoot, positionOc, grid=grid, iLambda=iLambda, &
                      kappaAbs = thisChi, kappaSca = thisSca)
                 
!                 thisChi = amrGridKappaAbs(grid%octreeRoot,positionOc,1, &
!                           foundOctal=octalLocation,foundSubcell=subcellLocation)
!                 thisSca = amrGridKappaAbs(grid%octreeRoot,positionOc,1, &
!                           startOctal=octalLocation,actualSubcell=subcellLocation)
              else
                 call getIndices(grid, thisPhoton%position, i1, i2, i3, t1, t2, t3)
                 if (.not.grid%oneKappa) then
                    if (.not.flatspec) then
                       thisChi = interpGridKappaAbs(grid, i1, i2, i3, iLambda, real(t1), real(t2), real(t3))
                       thisSca = interpGridKappaSca(grid, i1, i2, i3, iLambda, real(t1), real(t2), real(t3))
                    else
                       thisChi = interpGridKappaAbs(grid, i1, i2, i3, 1,  real(t1), real(t2), real(t3))
                       thisSca = interpGridKappaSca(grid, i1, i2, i3, 1,  real(t1), real(t2), real(t3))
                    endif
                 else
                    r = interpGridScalar2(grid%rho,grid%na1,grid%na2,grid%na3,i1,i2,i3,real(t1),real(t2),real(t3))
                    thisChi = grid%oneKappaAbs(1,iLambda) * r
                    thisSca = grid%oneKappaSca(1,iLambda) * r
                 endif
              end if
              
              if ((thisChi+thisSca) > 0.) then
                 albedo = thisSca / (thisChi + thisSca)
              else
                 albedo = 0.
              endif

              if (grid%resonanceLine) albedo = 1.


              if (hitCore) then
                 if (grid%geometry /= "binary") then
                    r = modulus(thisPhoton%position)/grid%rCore
                    if (r < 1.01) then
                       absorbed = .true.
                       albedo = 0.
                    endif
                 else
                    r1 = modulus(o2s(thisPhoton%position) - grid%starpos1)/grid%rStar1
                    r2 = modulus(o2s(thisPhoton%position) - grid%starpos2)/grid%rStar2
                    r = min (r1, r2)
                    if (r < 1.01) then
                       albedo = 0.5
                    endif
                 endif
              endif
                 
!                 thisPhoton%stokes = thisPhoton%stokes * albedo

! tjh changed on 10/11/04. photons now are either absorbed or scattered without
! biasing
              
              call random_number(r) 
              if (r > albedo) then
                 absorbed = .true.
              endif


              if (thisPhoton%stokes%i < reallySmall) then
                 absorbed = .true.
!                 write(*,*) "! Small photon weight",thisPhoton%stokes%i
              endif


              ! towards observer

              if (.not.absorbed) then

                 tempPhoton = thisPhoton
                 

                 if (miePhase(1,1)%element(1,1) > 2.) then
                    write(*,*) "Mie phase changed in torus main"
                 endif
                 call scatterPhoton(grid, tempPhoton, outVec, obsPhoton, mie, &
                       miePhase, nLambda, nMumie)

                 ! the o6 photon might get scattered towards the observer by a rayleigh scattering

                 if (doRaman) then
                    if (gridUsesAMR) then     
                       if (grid%octreeRoot%threed) then
                          call IntegratePathAMR(obsPhoton%lambda, lamLine, s2o(obsPhoton%velocity), &
                               obsPhoton%position, obsPhoton%direction, grid, &
                               lambda, tauExt, tauAbs, tauSca, maxTau, nTau, opaqueCore, &
                               escProb, obsPhoton%contPhoton, lamStart, lamEnd, nLambda, contTau, hitCore, &
                               thinLine, .false., .false., nUpper, nLower, 0., 0., 0.,&
                               junk, sampleFreq,intPathError)
                       else
                          call IntegratePathAMR(obsPhoton%lambda, lamLine, s2o(obsPhoton%velocity), &
                               obsPhoton%position, obsPhoton%direction, grid, &
                               lambda, tauExt, tauAbs, tauSca, maxTau, nTau, opaqueCore, &
                               escProb, obsPhoton%contPhoton, lamStart, lamEnd, nLambda, contTau, hitCore, &
                               thinLine, .false., .false., nUpper, nLower, 0., 0., 0.,&
                               junk, sampleFreq,intPathError)
                       endif
                          if (intPathError == -10) then
                               tooFewSamples = tooFewSamples + 1  
!                               call quickDeallocate
                               deallocate(lambda); deallocate(tauSca); deallocate(tauExt)
                               deallocate(tauAbs); deallocate(contTau); deallocate(contWeightArray)
                               cycle innerPhotonLoop
                            endif
                            if (intPathError == -20) then
                               boundaryProbs = boundaryProbs + 1
!                               call quickDeallocate
                               deallocate(lambda); deallocate(tauSca); deallocate(tauExt)
                               deallocate(tauAbs); deallocate(contTau); deallocate(contWeightArray)
                               cycle innerPhotonLoop
                            endif
                    else
                       call integratePath(obsPhoton%lambda, lamLine, obsPhoton%velocity, &
                            o2s(obsPhoton%position), o2s(obsPhoton%direction), grid, &
                            lambda, tauExt, tauAbs, tauSca, maxTau, nTau, opaqueCore, &
                            escProb, obsPhoton%contPhoton, lamStart, lamEnd, nLambda, contTau, hitCore, &
                            thinLine, .false., rStar, coolStarPosition, .false., nUpper, nLower, 0., 0., 0., junk, useInterp)
                    end if
                    vray = -(obsPhoton%velocity .dot. outVec)
                    vovercsqr = modulus(thisPhoton%velocity)**2
                    fac = (1.d0-0.5d0*vovercsqr*(1.d0-0.5d0*vovercsqr))/(1.d0+vray)
                    observedlambda = obsPhoton%lambda / fac
                    
                    weight = oneOnFourPi*exp(-tauExt(nTau)) * 34./(6.6+34.)

                    j = findIlambda(observedLambda, o6xArray, no6pts, ok)
                    if (ok) then
                       o6yArray(j) = o6yArray(j) + weight
                    endif
                 endif




                 redRegion = .false.

                 if (doRaman) redRegion = .true.
                 
                 if (gridUsesAMR) then
                    if (grid%octreeRoot%threed) then
                       call IntegratePathAMR(obsPhoton%lambda, lamLine, &
                            s2o(obsPhoton%velocity), &
                            obsPhoton%position, obsPhoton%direction, grid, &
                            lambda, tauExt, tauAbs, tauSca, maxTau, nTau, opaqueCore, &
                            escProb, obsPhoton%contPhoton, lamStart, lamEnd, &
                            nLambda, contTau, hitCore, &
                            thinLine, redRegion, &
                            .false., nUpper, nLower, 0., 0., 0., junk,sampleFreq,intPathError)
                    else
                       call IntegratePathAMR(obsPhoton%lambda, lamLine, &
                            s2o(obsPhoton%velocity), &
                            obsPhoton%position, obsPhoton%direction, grid, &
                            lambda, tauExt, tauAbs, tauSca, maxTau, nTau, opaqueCore, &
                            escProb, obsPhoton%contPhoton, lamStart, lamEnd, &
                            nLambda, contTau, hitCore, &
                            thinLine, redRegion, &
                            .false., nUpper, nLower, 0., 0., 0., junk,sampleFreq,intPathError)
                    endif
                      if (intPathError == -10) then
                         tooFewSamples = tooFewSamples + 1  
!                         call quickDeallocate
                         deallocate(lambda); deallocate(tauSca); deallocate(tauExt)
                         deallocate(tauAbs); deallocate(contTau); deallocate(contWeightArray)
                         cycle innerPhotonLoop
                      endif
                      if (intPathError == -20) then
                         boundaryProbs = boundaryProbs + 1
!                         call quickDeallocate
                         deallocate(lambda); deallocate(tauSca); deallocate(tauExt)
                         deallocate(tauAbs); deallocate(contTau); deallocate(contWeightArray)
                         cycle innerPhotonLoop
                      endif
                 else
                    call integratePath(obsPhoton%lambda, lamLine, &
                      obsPhoton%velocity, &
                      o2s(obsPhoton%position), o2s(obsPhoton%direction), grid, &
                      lambda, tauExt, tauAbs, tauSca, maxTau, nTau, opaqueCore, &
                      escProb, obsPhoton%contPhoton, lamStart, lamEnd, &
                      nLambda, contTau, hitCore, &
                      thinLine, redRegion, rStar, coolStarPosition,&
                      .false., nUpper, nLower, 0., 0., 0., junk, useInterp)
                 end if

!                 if ((obsPhoton%lambda  < 1.e4).and.(obsPhoton%lambda > 5500.)) then
!                    write(*,*) "scattered towards observer",tauext(ntau),ntau
!                 endif
                 
                 if (additionalExtinction) then
                    nTau = nTau + 1
                    iLambda = findIlambda(thisPhoton%lambda, xArray,  nLambda, ok)
                    tauAbs(nTau) = tauAbs(nTau-1) + tauExtra * foregroundKappaAbs(iLambda)/testKappaAbs
                    tauSca(nTau) = tauSca(nTau-1) + tauExtra * foregroundKappaSca(iLambda)/testKappaSca
                    tauExt(nTau) = tauSca(nTau) + tauAbs(nTau)
                    lambda(nTau) = lambda(nTau-1) + 1.e-20
                    nTau = nTau + 1
                    tauAbs(nTau) = tauAbs(nTau-1) + tauExtra2 * foregroundKappaAbs2(iLambda)/testKappaAbs2
                    tauSca(nTau) = tauSca(nTau-1) + tauExtra2 * foregroundKappaSca2(iLambda)/testKappaSca2
                    tauExt(nTau) = tauSca(nTau) + tauAbs(nTau)
                    lambda(nTau) = lambda(nTau-1) + 1.e-20
                 endif


                 if (obsPhoton%linePhoton) then

                    
                    vray = -(obsPhoton%velocity .dot. outVec)
                    vovercsqr = modulus(obsPhoton%velocity)**2
                    fac = (1.d0-0.5d0*vovercsqr*(1.d0-0.5d0*vovercsqr))/(1.d0+vray)
                    if (.not.doRaman) then
                       observedlambda = obsPhoton%lambda / fac
                    else
                       observedlambda = obsPhoton%redlambda / fac
                    endif


                 else
                    observedLambda = obsPhoton%lambda
                 endif

                 thruStar = .false.

                 if (.not.flatSpec.and.(.not.hitCore).and.(.not.thruStar)) then

                    ramanWeight = 1.
                    if (doRaman) ramanWeight = 6.6 / (34.+6.6)

                    weight = oneOnFourPi*exp(-tauExt(nTau)) * ramanWeight

                    iLambda = findIlambda(observedlambda, xArray, nLambda, ok)
                      

                    if (ok) then
                       yArray(iLambda) = yArray(iLambda) + obsPhoton%stokes*weight
                       statArray(iLambda) = statArray(iLambda) + 1.
                    endif
                    if (doRaman) then
                       thisVel = (1./(1./observedLambda  + 1./1215.67))/1031.928-1.
                    else
                       thisVel = observedLambda
                    endif



                    if (stokesImage) then
                       tempPhoton = obsPhoton
                       if (doRaman) then
                          tempPhoton%lambda = observedLambda
                       endif
                       call addPhotonToImage(viewVec,  rotationAxis, obsImageSet, nImage,  &
                            tempPhoton, thisVel, weight, filters, imageCentre)
                    endif
                    if (dopvImage) then
                       do iSlit = 1, nSlit
                          call addPhotontoPVimage(pvImage(iSlit), obsPhoton, viewVec,  rotationAxis,thisVel, &
                            weight, gridDistance)
                       enddo
                    endif

                    if (doRaman) then
                       thisPhoton%stokes = thisPhoton%stokes*(1.-ramanWeight)
                    endif
                 endif



                 if (flatSpec.and.(.not.hitCore)) then



                    if (obsPhoton%linePhoton) then
                       iLambda = findIlambda(observedlambda, xArray, nLambda, ok)
                       weight = oneOnFourPi*exp(-tauExt(nTau))


                       if (obsPhoton%resonanceLine) weight = weight * directionalWeight

                       if (ok) then
                          yArray(iLambda) = yArray(iLambda) + obsPhoton%stokes*weight
                          statArray(iLambda) = statArray(iLambda) + 1.
                       endif

                       thisVel = observedLambda
                       thisVel = (observedLambda-lamLine)/lamLine
                       if (stokesImage) then
                          call addPhotonToImage(viewVec,  rotationAxis, obsImageSet, nImage, &
                               obsPhoton, thisVel, weight, filters, imageCentre)
                       endif
                       if (dopvImage) then
                          do iSlit = 1 , nSlit
                             call addPhotontoPVimage(pvImage(iSlit), obsPhoton, viewVec,  rotationAxis, thisVel, &
                               weight, gridDistance)
                          enddo
                       endif


                    else


                       vray = -(obsPhoton%velocity .dot. outVec)
                       vovercsqr = modulus(obsPhoton%velocity)**2
                       fac = (1.d0-0.5d0*vovercsqr*(1.d0-0.5d0*vovercsqr))/(1.d0+vray)
                       observedlambda = obsPhoton%lambda / fac

                       do iLambda = 1,nLambda

                          thisLam = (lamLine-observedLambda) + xArray(iLambda)

                          i1 = findILambda(thisLam, xArray, nLambda, ok)
                          if (grid%geometry /= "binary") then
                             fac2 = sourceSpectrum(i1)
                             if ((grid%geometry == "disk").and.(.not.spotPhoton).and.(.not.photLine)) fac2 = 1.
                          else
                             if (obsPhoton%fromStar1) then
                                fac2 = sourceSpectrum(i1)
                             else
                                fac2 = sourceSpectrum2(i1)
                             endif
                          endif

                          fac3 = contTau(nTau, i1)



                          if (thinLine) fac3 = 0.


                          weight = exp(-(tauExt(nTau)+fac3)) * oneOnFourpi & 
                          * fac2 * directionalWeight * contWeightArray(i1)

                          
                          if (ok) then
                             yArray(iLambda) = yArray(iLambda) + &
                                  (obsPhoton%stokes*weight)
                          else 
                             yarray(ilambda) = yArray(ilambda) + &
                                  obsPhoton%stokes*(oneOnFourpi* directionalweight * exp(-tauExt(ntau)))
                          endif


                          thisVel = (observedlambda-lamLine)/lamLine
                          if (stokesImage) then
                             call addPhotonToImage(viewVec,  rotationAxis, obsImageSet, nImage, &
                                  obsPhoton, thisVel, weight, filters, imageCentre)
                          endif
                          if (dopvImage) then
                             do iSlit = 1, nSlit
                                call addPhotontoPVimage(pvImage(iSlit), obsPhoton, viewVec,  rotationAxis, thisVel, &
                                  weight, gridDistance)
                             enddo
                          endif


                          statArray(iLambda) = statArray(iLambda) + 1.
                       enddo
                    endif
                 endif


                 call scatterPhoton(grid,thisPhoton, zeroVec, outPhoton, mie, &
                       miePhase, nLambda, nMuMie)
                 thisPhoton = outPhoton


                 if (gridUsesAMR) then
                    if (grid%octreeRoot%threed) then
                       call IntegratePathAMR(thisPhoton%lambda, lamLine, &
                            s2o(thisPhoton%velocity), thisPhoton%position, &
                            thisPhoton%direction, grid, lambda, tauExt, tauAbs, &
                            tauSca, maxTau, nTau, opaqueCore, &
                            escProb, thisPhoton%contPhoton, lamStart, lamEnd, &
                            nLambda, contTau, hitCore, thinLine, .false., &
                            .false., nUpper, nLower, 0.,&
                            0., 0., junk,sampleFreq,intPathError)
                    else
                       call IntegratePathAMR(thisPhoton%lambda, lamLine, &
                            s2o(thisPhoton%velocity), thisPhoton%position, &
                            thisPhoton%direction, grid, lambda, tauExt, tauAbs, &
                            tauSca, maxTau, nTau, opaqueCore, &
                            escProb, thisPhoton%contPhoton, lamStart, lamEnd, &
                            nLambda, contTau, hitCore, thinLine, .false., &
                            .false., nUpper, nLower, 0.,&
                            0., 0., junk,sampleFreq,intPathError)
                    endif

                      if (intPathError == -10) then
                         tooFewSamples = tooFewSamples + 1  
!                         call quickDeallocate
                         deallocate(lambda); deallocate(tauSca); deallocate(tauExt)
                         deallocate(tauAbs); deallocate(contTau); deallocate(contWeightArray)
                         cycle innerPhotonLoop
                      endif
                      if (intPathError == -20) then
                         boundaryProbs = boundaryProbs + 1
!                         call quickDeallocate
                         deallocate(lambda); deallocate(tauSca); deallocate(tauExt)
                         deallocate(tauAbs); deallocate(contTau); deallocate(contWeightArray)
                         cycle innerPhotonLoop
                      endif
                 else
                   call integratePath(thisPhoton%lambda, lamLine, &
                      thisPhoton%velocity, o2s(thisPhoton%position), &
                      o2s(thisPhoton%direction), grid, lambda, tauExt, tauAbs, &
                      tauSca, maxTau, nTau, opaqueCore, &
                      escProb, thisPhoton%contPhoton, lamStart, lamEnd, &
                      nLambda, contTau, hitCore, thinLine, .false., &
                      rStar, coolStarPosition, .false., nUpper, nLower, 0.,&
                      0., 0., junk,useInterp)
                 end if


                 if (maxScat == 1) then
                    call random_number(r1)
                    thistau = -log(max(1.e-10,(1. - r1)))
                    if (thistau .gt. tauExt(nTau)) then
                       escaped = .true.
                    else
                       nscat = 0
                    endif
                 else
                    call random_number(r1)
                    fac = 1.d0 - exp(-tauExt(nTau))
                    thisTau = -log(1.d0-r1*fac)
                    thisPhoton%stokes = thisPhoton%stokes * fac
                 endif


              endif


           enddo
           nTot = nTot + nScat

           deallocate(lambda)
           deallocate(tauSca)
           deallocate(tauExt)
           deallocate(tauAbs)
           deallocate(contTau)
           deallocate(contWeightArray)


        enddo innerPhotonLoop
!$OMP END DO
!$OMP END PARALLEL



!$MPI     if (my_rank==0) &
        write(*,'(i8,a,f7.3)') iOuterLoop*nPhotons/nOuterLoop," photons done"

        errorArray(iOuterLoop,1:nLambda) = yArray(1:nLambda)

!$MPI     if (my_rank==0) &
        call tune(6, "One Outer Phone Loop") ! Stop a stop watch
        
     enddo

!$MPI     if (my_rank==0) &
     call tune(6, "All Photon Loops")  ! Stop a stopwatch


     write(*,*) " "
     write(*,'(a)') "Model summary"
     write(*,'(a)') "-------------"
     write(*,*) " "

     call systemInfo(startTime,nPhotons)
     
     if (grid%adaptive) then
        print *, tooFewSamples, ' rays had 2 or less samples.'
        print *, BoundaryProbs, ' rays had numerical problems with octal boundaries.'
     end if

!     if (.not.grid%cartesian.and.(grid%rCore /= 0.)) then
!        if (wtot_line /= 0.) write(*,*) "Mean radius of line formation",meanr_line/wtot_line/grid%rCore
!        if (wtot0_line /= 0.) write(*,*) "Mean radius of line zero",meanr0_line/wtot0_line/grid%rCore
!        if (wtot_cont /= 0.) write(*,*) "Mean radius of cont formation",meanr_cont/wtot_cont/grid%rCore
!        if (wtot0_cont /=0.) write(*,*) "Mean radius of cont zero",meanr0_cont/wtot0_cont/grid%rCore
!     endif
     normalizeSpectrum = .false.
     if (.not.doRaman) then
        normalizeSpectrum = .true.
     endif

     if (flatspec) normalizeSpectrum = .true.


     if (mie) normalizeSpectrum = .false.


     if (nPhase == 1) then
        call  writeSpectrum(outFile,  nLambda, xArray, yArray,  errorArray, &
             nOuterLoop, normalizeSpectrum, useNdf, sed, objectDistance, jansky, SIsed, dustySED)
     else
        write(specFile,'(a,i3.3)') trim(outfile),iPhase
        call  writeSpectrum(specFile,  nLambda, xArray, yArray,  errorArray, &
             nOuterLoop, normalizeSpectrum, useNdf, sed, objectDistance, jansky, SIsed, dustySED)
        if (doRaman) then
           write(o6filename,'(a,a,i3.3,a)') trim(outfile),"_o6_",iPhase,".dat"
           open(20,file=o6filename,status="unknown",form="formatted")
           do i = 1, no6pts
              t1 = 1./(o6xArray(2)-o6xArray(1))
              write(20,*) o6xarray(i),o6yarray(i)*t1,1.e-20,1.e-30,1.e-20,1.e-30
           enddo
           close(20)
        endif
     endif


     if (stokesimage) then
        do i = 1, nImage
           name_filter = get_filter_name(filters, i)
           bandwidth = 0.5*FWHM_filters(filters, i)  ! 1/2 of FWHM  [A]
           lambda_eff = lambda_eff_filters(filters, i) ! Effective wavelength of filter in [A]   
           write(specFile,'(a,a,a,i3.3)') trim(outfile),"_"//trim(name_filter),"_image",iPhase
           call writeImage(obsImageSet(i), specfile, objectDistance, inArcsec, lambda_eff, bandwidth)
        end do
        if (doRaman) then
           write(specFile,'(a,a,i3.3)') trim(outfile),"_o6image",iPhase
           !+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
           ! Check the the effectieve wavelength and the 
           ! bandwith of O6 image here later and replace 5000 and 1.0d0 below!
           !+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
           call writeImage(o6Image(1), specfile, objectDistance, inArcsec, 5000d0, 1.0d0)
        endif

     endif

     if (doPvimage) then
        do iSlit = 1, nSlit
           write(specFile,'(a,a,i3.3,a,i2.2)') trim(outfile),"_pvimage",iPhase,"_slit_",iSlit

           call smoothPVimage(pvImage(iSlit), vfwhm/2.35, pfwhm/2.35)

           call writePVimage(pvImage(iSlit), specfile, vSys)
           if (device /= "/xs") then
              write(plotfile,'(a,i3.3,a,i2.2,a,a)') "slitplot",iPhase,"_slit_",iSlit,".gif",trim(device)
           else
              plotfile = device
           endif
           ! doing this only for the first image in obsImageSet
           call plotSlitOnImage(obsImageSet(1), PVimage(iSlit), plotfile, gridDistance)
        enddo
     endif

     if (stokesImage) then
        do i = 1, nImage
           call freeImage(obsImageSet(i))
        end do
     end if

     if (doPVimage) then
        do iSlit = 1, nSlit
           call freePVimage(pvImage(iSlit))
        enddo
     endif

  enddo




666 continue

!  call freeGrid(grid)

!$MPI     if (my_rank==0)&
call tune(6, "Torus Main") ! stop a stopwatch  


!$MPI  call MPI_BARRIER(MPI_COMM_WORLD, ierr) 
!$MPI  call MPI_FINALIZE(ierr)


contains
    
  subroutine quickDeallocate() 
    ! deallocates some variables so that we can CYCLE the innerPhotonLoop
    deallocate(lambda)
    deallocate(tauSca)
    deallocate(tauExt)
    deallocate(tauAbs)
    deallocate(contTau)
    deallocate(contWeightArray)
  end subroutine quickDeallocate
    

end program torus









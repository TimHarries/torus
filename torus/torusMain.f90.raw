!
!             T   O   R   U  S
!
! torus is a general purpose monte-carlo radiative transfer code used to
! produce polarized spectra of hot and cool stellar winds
!

! written by tjh

! v1.0 on 16/09/99

! raman scattering stuff added 3/3/2000

! OMP parallelization calls added 1/7/2001

! TJH: 19/7/02  Jorick's spotty star stuff added
! NHS: 02/9/02  adaptive mesh code merged
! RK : 12/02/03 Parallelized major loops in lucyStateEquilibriumAMR, stateqAMR, torusMain.


program torus

  use constants_mod          ! physical constants
  use kind_mod               ! variable type KIND parameters
  use vector_mod             ! vector math
  use photon_mod             ! photon manipulation
  use gridtype_mod           ! type definition for the 3-d grid
  use grid_mod               ! opacity grid routines
  use phasematrix_mod        ! phase matrices and stokes vectors
  use math_mod               ! misc maths subroutines
  use blob_mod               ! clumps initialization and movement
  use distortion_mod         ! for distorting opacity grid
  use image_mod              ! stokes image
  use utils_mod
  use stateq_mod
  use inputs_mod
  use TTauri_mod
  use luc_cir3d_class
  use cmfgen_class
  use unix_mod
  use path_integral
  use puls_mod
  use input_variables         ! variables filled by inputs subroutine
  use lucy_mod
  use amr_mod
  use jets_mod
  use dust_mod
  use source_mod
  use spectrum_mod
  use wr104_mod
  use sph_data_class
  use cluster_class
  use timing
  use isochrone_class
  use filter_set_class
  use cluster_utils
  use surface_mod
  use disc_hydro_mod
  use disc_class
  use discwind_class
  use jet_class
  use gas_opacity_mod
!$mpi   use parallel_mod
!$MPI   !use MPI__INCLUDE   
!$MPI   !use MPI

  implicit none
!$MPI   include 'mpif.h'  

  integer, parameter :: nOuterLoop = 10
  integer :: iOuterLoop
  integer :: nScat
  integer :: cpuTime, startTime
  integer :: nSource
  type(SOURCETYPE), allocatable :: source(:)
  type(SOURCETYPE) a_star
  real(double) :: lCore
  real ::  weightDust=1.0, weightPhoto=1.0
  real :: inclination, cos_inc, cos_inc_first, cos_inc_last, d_cos_inc
  integer :: iInclination  

  real(double) :: energyPerPhoton
  real(double) :: objectDistance

  ! variables for the grid

  type(GRIDTYPE) :: grid

  integer :: iPhase
  real(double) :: totLineEmission
  real(double) :: totContinuumEmission
  real(double) :: totCoreContinuumEmission
  real(double) :: cOrecontinuumflux
  real(double) :: totCoreContinuumEmission1
  real(double) :: totCoreContinuumEmission2
  real(double) :: totWindContinuumEmission
  real :: probLinePhoton 
  real :: weightContPhoton, weightLinePhoton
  real :: chanceLine, chanceContinuum
  real :: sTot

  integer :: iseed(4)

  ! optical depth variables

  integer, parameter :: maxTau = 1000000, maxLambda = 500
  integer :: nTau
  real, allocatable :: contTau(:,:)


  real :: scaleFac

!  real :: tauExt(maxTau)
!  real :: tauAbs(maxTau)
!  real :: tauSca(maxTau)
!  real :: lambda(maxTau)
  real, allocatable :: tauExt(:)
  real, allocatable :: tauAbs(:)
  real, allocatable :: tauSca(:)
  real, allocatable :: linePhotonAlbedo(:)
  real, allocatable :: lambda(:)

  real, allocatable :: mReal(:), mImg(:)          ! size = nlambda
  real, allocatable :: mReal2D(:,:), mImg2D(:,:)  ! size = ngrain x nlambda
  real :: total_dust_abundance


  real, allocatable :: kappaAbs(:), kappaSca(:), kappaExt(:)
  real  :: sigmaExt0, sigmaAbs0, sigmaSca0  ! cross section at the line centre
  real :: dlambda, thisTau

  ! variables to do with dust

  integer :: itestlam, ismoothlam
  real :: xMin, xMax
  integer, parameter :: nXmie = 20, nMuMie = 20
  type(PHASEMATRIX),allocatable :: miePhase(:, :)
  real :: particleMass, abundance

  ! torus images

  type(IMAGETYPE) :: o6image(1)

  type(IMAGETYPE), allocatable :: obsImageSet(:)
  integer           :: nImage  ! number of images in obsImageSet
  type(filter_set)  :: filters ! a set of filters used for imaging
  character(LEN=30) :: name_filter
  real(double) :: bandwidth   ! Band width of a filter[A]
  real(double) :: lambda_eff  ! Effective wavelength of a filter[A]

  type(PVIMAGETYPE), allocatable :: pvimage(:)
  real :: imageSize
  integer :: iSlit
  type(VECTOR) :: slitPosition

  ! intrinsic profile variables

  integer, parameter :: maxIntPro = 1000
  integer :: nIntPro, iSpline
  real :: lamIntPro(maxIntPro), intPro(maxIntPro)
  real, allocatable :: splineArray(:)

  real, allocatable :: lamArray(:)
  real, allocatable :: statArray(:)
  real, allocatable :: sourceSpectrum(:)
  real, allocatable :: sourceSpectrum2(:)

!  logical :: resonanceLine


  ! variables for clumped wind models
  

  integer, parameter :: maxBlobs = 10000
  integer :: nCurrent
    type(BLOBTYPE), allocatable :: blobs(:)
  real, parameter :: blobTime = 1000.
  real :: timeEnd = 24.*60.*60.
  real :: timeStart = 0.
  real :: dTime

  ! filenames

  character(len=80) :: filename, specFile
  character(len=80) :: originalOutFile
  character(len=80) :: phasePopFilename

  ! photons

  type(PHOTON) :: thisPhoton
  type(PHOTON) :: outPhoton
  type(PHOTON) :: obsPhoton
  type(PHOTON) :: tempPhoton

  ! vectors

  type(VECTOR), parameter :: zAxis = VECTOR(0.,0.,1.)
  type(VECTOR), parameter :: yAxis = VECTOR(0.,1.,0.)
  type(VECTOR), parameter :: xAxis = VECTOR(1.,0.,0.)
  type(VECTOR) :: viewVec, outVec, thisVec, originalViewVec
  type(VECTOR) :: rotationAxis, normToRotation
  type(VECTOR) :: zeroVec, tempVec
  type(OCTALVECTOR) :: rHat, rVec, rHatinStar


  ! output arrays

  integer :: iLambda
  type(STOKESVECTOR), allocatable :: yArray(:)
  type(STOKESVECTOR), allocatable :: errorArray(:,:)
  real, allocatable :: xArray(:), dx(:)
  real, allocatable :: contWeightArray(:)
!  real :: contWeightArray(maxTau)
  type(STOKESVECTOR) :: tot

  ! model flags

  logical :: escaped, absorbed
  logical :: rotateView
  logical :: tiltView = .false.
  logical :: flatSpec
  logical :: ok
  logical :: greyContinuum
  logical :: hitCore
  logical :: firstPlot

  ! model parameters

  real :: vel
  real :: nuStart, nuEnd

  ! single dust blob parameters (WR137 type model)

  real :: meanDustParticleMass, getMeanMass2


  real :: foreground = 0., background = 0.  ! plotting intensities
  real :: mu
  real(oct) :: t1, t2, t3
  real :: junk1


  logical :: velocitySpace

  ! raman scattering model parameters

  logical :: thruStar
  type(VECTOR) :: hotSourcePosition, coolStarPosition
  type(VECTOR) :: ramanSourceVelocity

  ! O VI spectrum stuff

  character(len=80) :: o6filename
  integer, parameter :: no6pts = 100
  real, parameter :: o6start = 1031.5, o6end=1032.8
  real :: o6xarray(no6pts), o6yarray(no6pts)


  ! misc

  real :: rotateDirection
  real :: meanr_line = 0., meanr_cont = 0.
  real :: wtot_line =0., wtot_cont = 0.
  real :: meanr0_line = 0., meanr0_cont = 0.
  real :: wtot0_line =0., wtot0_cont = 0.
  real :: junk
  character(len=80) :: plotFile

  real :: thisChi, thisSca, albedo
  logical :: normalizeSpectrum
  integer :: currentScat
  logical :: redRegion
  real :: r
  logical :: contWindPhoton
  real :: ramanWeight
  real :: thisVel
  real :: fac1, fac2, fac3
  real(double) :: vRay, vOverCsqr
  real :: directionalWeight
  real :: obs_weight
  real :: r1, r2
  real(oct) :: t
  integer :: i, j, k, n
  integer :: i1,i2,i3
  integer :: nTot  
  real :: observedLambda
  real :: thisLam
  real :: nu
!  real :: fac
  real(double) :: fac
  real(double) :: tau_bnd
  real :: escProb
  logical :: contPhoton
  integer :: nContPhotons
  real :: phi
  real :: deltaLambda
  real :: rStar
  character(len=80) :: tempChar
  logical :: lineResAbs    ! T if you want to include absorption
  !                        !   of line by line resonance zones.


  !
  real(double) :: totalMass
  real(double) :: T_ave   ! average temperature of cluster
  real(double) :: T_mass  ! mass weighted temperature
  real(double) :: tau_max, tau_min, tau_ave

  real(double) :: Laccretion
  real :: Taccretion, fAccretion, sAccretion
  real :: theta1, theta2, chanceHotRing
  type(SURFACETYPE) :: starSurface

  ! Spot stuff
  
  real :: chanceSpot                     ! chance of spot
  logical :: spotPhoton                  ! photon from spot?

  real :: loglamStart, logLamEnd

  real :: chanceDust = 0.
  real(double) :: totDustContinuumEmission, totEnvelopeEmission

  ! binary parameters

  type(VECTOR) :: starPos1, starPos2
  integer :: nVec
  type(VECTOR), allocatable :: distortionVec(:)

  ! adaptive grid stuff

  type(OCTALVECTOR) :: amrGridCentre ! central coordinates of grid
  type(OCTALVECTOR) :: octVec
  real :: meant, treal, ang, meaneta, eta, kabs
  integer, parameter :: nrGrid = 1000
  real :: rGrid(nrGrid), drGrid(nrgrid),prGrid(nrGrid)
  integer :: nt
  integer           :: nOctals       ! number of octals in grid
  integer           :: nVoxels       ! number of unique voxels in grid
                                     !   (i.e. the number of childless subcells)
  logical :: gridConverged           ! true when adaptive grid structure has 
                                     !   been finalised
  integer :: intPathError            ! error code from integratePathAMR
  type(OCTALVECTOR) :: positionOc    ! photon position position
!  type(octal),pointer :: octalLocation! octal located by search routine 
!  integer           :: subcellLocation! subcell located by search routine
  integer           :: tooFewSamples ! number of errors from integratePathAMR
  integer           :: boundaryProbs ! number of errors from integratePathAMR
  integer           :: negativeOpacity ! number of errors from integratePathAMR

  real(double)           :: Ne         ! for testing
  real,dimension(statEqMAxLevels) :: meanDepart ! for testing
  real(double),dimension(statEqMAxLevels) :: levelPops  ! for testing
  integer                         :: level      ! for testing
  character(len=80) :: newContFluxFile ! modified flux file (i.e. with accretion)
  real :: infallParticleMass         ! for T Tauri infall models
  logical :: alreadyDoneInfall = .false. ! whether we have already done an infall calculation
  type(alpha_disc)  :: ttauri_disc       ! parameters for ttauri disc
  type(discwind)    :: ttauri_discwind   ! parameters for ttauri disc wind
  type(jet)         :: ttauri_jet        ! parameters for ttauri jets

!  ! For luc_cir3d geometry case
!  type(luc_cir3d) :: cir3d ! parameters and data for luc_cir3d geometry


  !
  ! SPH data of Matthew
  type(sph_data) :: sphData

  ! Used for multiple sources (when geometry=cluster)
  integer :: nstar
  type(cluster)   :: young_cluster
  type(isochrone) :: isochrone_data

  ! Used in "plot_AMR_planes" and "plot_AMR_values"
  integer :: nmarker           ! number of markers
  real, allocatable    :: xmarker(:)  ! position of x
  real, allocatable    :: ymarker(:)  ! position of y
  real, allocatable    :: zmarker(:)  ! position of z
  real    :: width_3rd_dim         ! Use this to restrict the markers to be plotted..  
  real val_3rd_dim

  real    :: tmp
  type(octalvector) :: vec_offset

! gas opacity stuff


  
  integer :: iInner_beg, iInner_end ! beginning and end of the innerPhotonLoop index.
!  integer ::   iphase_beg, iphase_end  ! the beginning and the end of the phase index.

!$MPI  ! For MPI implementations =====================================================
!$MPI  integer ::   my_rank        ! my processor rank
!$MPI  integer ::   n_proc         ! The number of processes
!$MPI  integer ::   ierr           ! error flag
!$MPI  integer ::   n_rmdr, m      !
!$MPI  integer ::   mphotons       ! number of photons (actual) 
!$MPI  integer ::   tempInt        !
!$MPI  real, dimension(:), allocatable :: tempRealArray
!$MPI  real, dimension(:), allocatable :: tempRealArray2
!$MPI  integer, dimension(:), allocatable :: photonBelongsRank
!$MPI  integer, parameter :: tag = 0
!$MPI  logical :: rankComplete
!$MPI
!$MPI  ! FOR MPI IMPLEMENTATION=======================================================
!$MPI  !  initialize the system for running MPI
!$MPI  call MPI_INIT(ierr) 
!$MPI
!$MPI  !  Get my process rank # 
!$MPI  call MPI_COMM_RANK(MPI_COMM_WORLD, my_rank, ierr)
!$MPI  
!$MPI  ! Find the total # of precessor being used in this run
!$MPI  call MPI_COMM_SIZE(MPI_COMM_WORLD, n_proc, ierr)
!$MPI  
!$MPI  call unixGetHostname(tempChar, tempInt) 
!$MPI  print *, 'Process ', my_rank,' running on host ',TRIM(ADJUSTL(tempChar))
!$MPI  
!$MPI  !===============================================================================


  !
  ! For time statistics
!$MPI  if (my_rank==1) &
  call tune(6, "Torus Main") ! start a stopwatch  

  ! initialize

  useNdf = .true.
  sed = .false.
  jansky = .false.
  SIsed = .false.
  velocitySpace = .false.
  movie = .false.
  thinLine = .false.
  rotateView = .false.
  flatspec = .false.
  greyContinuum = .false.
  secondSource = .false.
  firstplot = .true.
  doRaman = .false.
  enhance = .false.
  rotateDirection = -1.
  lineResAbs = .false.  

  contFluxFile = "none"
  intProFilename = "none"

  inputKappaSca = 0.
  inputKappaAbs = 0.

  zeroVec = VECTOR(0.,0.,0.)
  vec_offset = OCTALVECTOR(1.0_oc, 1.0_oc , 1.0_oc) ! used in a optical depth test.

  starPos1 = VECTOR(-400.,0.,0.)
  starPos2 = VECTOR(+400.,0.,0.)

  tooFewSamples = 0 
  boundaryProbs = 0 
  negativeOpacity = 0 
  lucyRadiativeEq = .false. ! this has to be initialized here

  ! for plot_AMR_value and plot_AMR_plane (initialization)
  nmarker = 0;
  ALLOCATE(xmarker(nmarker), ymarker(nmarker), zmarker(nmarker))
  width_3rd_dim = amrGridSize


  ! hardwired stuff

  abundance = 1.e-8
  particleMass = 15.9994*mHydrogen + 47.867*mHydrogen

  do i = 1, no6pts
     o6xArray(i) = o6start + (o6end-o6start)*real(i-1)/real(no6pts-1)
     o6yarray(i) = 1.d-10
  enddo

  ! get the model parameters

  call  inputs() ! variables are passed using the input_variables module


  objectDistance = griddistance * pctocm


  ! time elipsed since the beginning of the model
  grid%timeNow = phaseTime * REAL(nStartPhase-1)
  

  grid%resonanceLine = resonanceLine



  
  ! For plotting routines used later in this program
  if (plane_for_plot == "x-y") then
     val_3rd_dim = amrGridCentre%z
  else if (plane_for_plot == "y-z") then
     val_3rd_dim = amrGridCentre%x
  else if (plane_for_plot == "z-x") then
     val_3rd_dim = amrGridCentre%y
  else if (plane_for_plot == "x-z") then
     val_3rd_dim = amrGridCentre%y
  else
     val_3rd_dim = 0.0d0        
  end if

  !
  if (nLambda > maxLambda) then
     write(*,'(a,i3.3,a)') "nlambda is greater than the maximum value (",&
          maxLambda,")"
     stop
  endif

  !

  if (geometry.eq."raman") then
     hotSourcePosition = 0.75*secondSourcePosition
     coolStarPosition = (-0.25)*secondSourcePosition
     secondSourcePosition = hotSourcePosition
     write(*,*) "hot",hotSourcePosition
  endif

  if (doRaman) screened = .true.

  if (.not.inputOK) goto 666

  if (dopvimage) then
     allocate(pvimage(1:nSlit))
  endif

  if (mie .or. (geometry == "ttauri" .and. ttau_disc_on)) then
     meanDustParticleMass = getMeanMass2(amin, amax, a0, qDist, pdist, graintype)
     write(*,*) "mean dust particle mass: ",meanDustParticleMass
     if (meanDustParticleMass <=0.0) then 
        write(*,*) "Error: meanDustParticleMass <=0 in torusMain."
        stop
     end if
  endif

  probLinePhoton = 1. - probContPhoton
  inclination = firstInclination
  scale = scale * rSol

  rStar = 100.*rSol

  ! if we are computing spiral models then we rotate the view

  if ((nPhase /= 1).and.(distortionType .eq. "spiral")) rotateview = .true.

  ! we also rotate for the test model

  if (distortionType .eq. "test") rotateView = .true.

  ! we rotate wind-wind collision models


  if (distortionType .eq. "windwind") rotateView = .true.


  ! rotate for colliding winds too

  if (trim(geometry) .eq. "collide") rotateView = .true.

  if (geometry == "binary") rotateView = .true.

  ! rotate for raman

  if (geometry == "raman") rotateView = .true.


  if (geometry == "planet") rotateView = .true.

  if (geometry == "betacep") rotateView = .true.

  if (geometry == "donati") rotateView = .true.

  if ((geometry == "ttauri")) rotateView = .true.

  if ((geometry == "luc_cir3d")) rotateView = .true.

  if ((geometry == "cmfgen")) rotateView = .true.

  if ((geometry(1:4) == "jets")) then
     rotateView = .true.
     tiltView = .true.
  end if

  if (doRaman) then
        rotateView = .true.
        rotateDirection = 1.
  endif

  if (geometry == "rolf") rotateView = .true.

  if (geometry == "disk") rotateView = .true.

  if (geometry == "wr104") then
     rotateView = .true.
     rotateDirection = 1.
  endif

  if (geometry(1:7) == "cluster") then
     rotateView = .true.
!     tiltView = .true.
  end if
  
  ! switches for line emission

  if (lineEmission) then
     flatspec = .true.
     greyContinuum = .true.
     velocitySpace = .true.
  endif

  if (geometry == "planet") then
     flatspec = .true.
     greyContinuum = .true.
  endif

  if (geometry == "rolf") then
!     flatspec = .true.
     greyContinuum = .true.
  endif
     
  

  ! the observer's viewing direction

  rotationAxis = VECTOR(0., 0., 1.)

  normToRotation = rotationAxis .cross. yAxis
  call normalize(normToRotation)

  originalViewVec%x = 0.
  originalViewVec%y = -sin(firstInclination)
  originalViewVec%z = -cos(firstInclination)
  viewVec = originalViewVec

  !=====================================================================
  ! INIIALIZATIONS BEFORE CALLING INITAMR ROUTINE SHOUDL BE HERE
  !=====================================================================
  if (geometry == "cluster") then
     ! read in the sph data from a file
     call read_sph_data(sphData, "sph.dat")
     call read_stellar_disc_data(sphData, "stellar_disc.dat")

     ! Writing basic info of this data
!$MPI  if (my_rank==0) then
     call info(sphData, "*")
     call info(sphData, "info_sph.dat")
!$MPI  end if ! (my_rank==0) 
     ! reading in the isochrone data needed to build an cluster object.
     call new(isochrone_data, "dam98_0225")   
     call read_isochrone_data(isochrone_data)

     ! making a cluster object
     call new(young_cluster, sphData, dble(amrGridSize), disc_on)
     call build_cluster(young_cluster, sphData, dble(lamstart), dble(lamend), isochrone_data)

     ! Wrting the stellar catalog readble for a human
!$MPI  if (my_rank==0) &
     call write_catalog(young_cluster, sphData)
     ! Finding the inclinations of discs seen from +z directions...
!$MPI  if (my_rank==0) &
     call find_inclinations(sphData, 0.0d0, 0.0d0, 1.0d0, "inclinations_z.dat")

  elseif (geometry == "wr104") then
     if (.not.(readPops.or.readlucy)) then
        call readWR104Particles("harries_wr104.txt", sphData, objectDistance)
        call info(sphData,"*")
     endif

  elseif (geometry == "ttauri") then
     onekappa=.false.
     if (ttau_disc_on)  &
          call new(ttauri_disc, dble(TTauriRouter/1.0e10), 1.5d3*100.d0, &
          dble(TTauriMstar/100.0), 0.0d0, 0.0d0, 0.0d0, 0.0d0, 0.0d0, 1.0d0, dble(TTauriMstar/mSol))
     if (ttau_discwind_on) &
          call new(ttauri_discwind, DW_d, DW_Rmin, DW_Rmax, DW_Tmax, DW_gamma, &
          DW_Mdot, DW_alpha, DW_beta, DW_Rs, DW_f, DW_Twind, &
          dble(TTauriMstar/mSol),  dble(TTauriDiskHeight/1.0e10) )
     if (ttau_jet_on) &
          call new(ttauri_jet,  dble(TTauriRouter/1.0e10), dble(amrgridsize), &
          JET_theta_j, dble(TTauriMstar/mSol), JET_Mdot, JET_a_param, JET_b_param,  &
          JET_Vbase, JET_Vinf, JET_beta, JET_gamma, limitscalar, JET_T)

  elseif (geometry == "luc_cir3d") then
     onekappa=.false.
     !                    Rmin [10^10cm]         
     call new(CIR_Rstar*Rsol*1.0e-10, CIR_Twind, CIR_Mdot_scale,  &
     "zeus_rgrid.dat", "zeus_rho_vel.dat")     

  elseif (geometry == "cmfgen") then
     onekappa=.false.
     call read_cmfgen_data("OPACITY_DATA")
     call put_cmfgen_Rmin(CMFGEN_Rmin)  ! in [10^10cm]
  end if
  !==========================================================================
  !==========================================================================


  ! allocate the grid - this might crash out through memory problems

  if (gridUsesAMR) then
     ! any AMR allocation stuff goes here
     call initAMRGrid(greyContinuum, &
                        newContFluxFile,flatspec,grid,ok,theta1,theta2)
        if (.not.ok) goto 666

  else
     if (gridcoords /= "polar") then
        if ((.not.doRaman).and.(geometry /= "binary"))  then
           grid = initCartesianGrid(nx, ny, nz, nLambda, lamStart, lamEnd, &
                greyContinuum, ok)
           else
           grid = initCartesianGrid(nx, ny, nz, 1, lamStart, lamEnd, &
                greyContinuum, ok)
        endif
         if (.not.ok) goto 666
     else   if (plezModelOn) then
        grid = plezModel("model.plez", lamStart, lamEnd, nLambda, kfac)
     else
        grid = initPolarGrid(nr, nmu, nphi, nlambda, lamStart, &
                             lamEnd, greyContinuum, ok)
        if (.not.ok) goto 666
     endif
  end if

  ! a few dynamic arrays

!  if (mie) sed = .true.

  grid%resonanceLine = resonanceLine
  grid%lambda2 = lamline


  allocate(miePhase(1:nLambda,1:nMumie))
  allocate(kappaExt(1:nLambda))
  allocate(kappaAbs(1:nLambda))
  allocate(kappaSca(1:nLambda))
  allocate(lamArray(1:nLambda))
  allocate(statArray(1:nLambda))
  allocate(sourceSpectrum(1:nLambda))
  allocate(sourceSpectrum2(1:nLambda))

  grid%doRaman = doRaman

  statArray = 0.
  sourceSpectrum = 1.
  sourceSpectrum2 = 1.

  ! set up the wavelength array

  do i = 1, nLambda
     lamArray(i) = lamStart+(lamEnd-lamStart)*real(i-1)/real(nLambda-1)
  enddo

  if (plezModelOn) then
     call readTioCrossSection(lamArray, nLambda, kappaExt, kappaAbs, kappaSca)
  endif


  ! allocate the output arrays

  allocate(xArray(1:nLambda))
  allocate(dx(1:nLambda))
  allocate(yArray(1:nLambda))
  allocate(errorArray(1:nOuterLoop,1:nLambda))




  if (lamLinear) then
     deltaLambda = (lamEnd - lamStart) / real(nLambda)
     
     xArray(1) = lamStart + deltaLambda/2.
     yArray(1)%i = 0.
     yArray(1)%q = 0.
     yArray(1)%u = 0.
     yArray(1)%v = 0.
     do i = 2, nLambda
        xArray(i) = xArray(i-1) + deltaLambda
        yArray(i)%i = 0.
        yArray(i)%q = 0.
        yArray(i)%u = 0.
        yArray(i)%v = 0.
     enddo
     dx = deltaLambda
  else


     logLamStart = log10(lamStart)
     logLamEnd = log10(lamEnd)

     do i = 1, nLambda
        xArray(i) = logLamStart + real(i-1)/real(nLambda-1)*(logLamEnd - logLamStart)
        xArray(i) = 10.**xArray(i)
        yArray(i) = STOKESVECTOR(0.,0.,0.,0.)
     enddo
     if (mie) then
        call locate(xArray, nLambda, lambdaTau, i)
        t1 = (lambdaTau - xArray(i))/(xArray(i+1)-xArray(i))
        if (t1 > 0.5) then
           write(*,*) "Replacing ",xArray(i+1), " wavelength step with ",lambdaTau
           xArray(i+1) = lambdaTau
        else
           write(*,*) "Replacing ",xArray(i), " wavelength step with ",lambdaTau
           xArray(i) = lambdaTau
        endif
     endif

     dx(1) = xarray(2)-xarray(1)
     dx(nLambda) = xarray(nlambda)-xarray(nLambda-1)
     do i = 2, nLambda-1
        dx(i) = 0.5*((xarray(i+1)+xarray(i))-(xarray(i)+xarray(i-1)))
     enddo
  endif

  !
  ! Copying the wavelength array to the grid
  do i = 1, nLambda
     grid%lamArray(i) = xArray(i)
  enddo
  grid%nLambda = nLambda

  !
  ! Setting the number of opacity (kappa) arrays in grid.
  !
  if (flatspec) then
     grid%nopacity = 1
  else
     grid%nopacity = nLambda
  end if

  
  errorArray(1:nOuterLoop,1:nLambda) = STOKESVECTOR(0.,0.,0.,0.)

  if (doRaman) then
     yarray(1:nLambda)%i = 1.e-20
     errorArray(1:nOuterLoop,1:nLambda)%i = 1.e-20
  endif

  if (mie .and. .not.dustfile) then
     write(*,*) "fill grid mie",nLambda,grid%nlambda
     call fillGridMie(grid, scale, aMin, aMax, a0, qDist, pDist, grainType, &
          ngrain, X_grain, grainname)
     write(*,'(a,f5.2)') "!!!! Multiplying the opacities by the dust-to-gas ratio of: ",dusttogas
     do i = 1, nDustType
        grid%oneKappaAbs(i,1:grid%nLambda) =  grid%oneKappaAbs(i,1:grid%nLambda) * dustToGas
        grid%oneKappaSca(i,1:grid%nLambda) =  grid%oneKappaSca(i,1:grid%nLambda) * dustToGas
     enddo
  else
     do i = 1, nDustType
        call dustPropertiesfromFile(dustfilename(i), grid%nlambda, xArray, grid%onekappaAbs(i,1:grid%nlambda), &
             grid%onekappaSca(i,1:grid%nLambda))
     enddo
  endif

  call createTioGrid(20, 1.e-6, 20000., grid%nLambda, xArray)


  ! if the grid uses an adaptive mesh, create it
     


!  if (gridUsesAMR) then
!     if ((mie) .or. (geometry == "ttauri" .and. ttau_disc_on)) then 
!        call setKappaTest(grid, scale, aMin, aMax, a0, qDist, pDist, grainType, &
!             ngrain, X_grain, grainname, lambdaTau)
!     end if
!  end if


  if (mie) then
     call locate(grid%lamArray, nLambda,lambdaTau,itestlam)
     call locate(grid%lamArray, nLambda,lambdasmooth,ismoothlam)
     write(*,*) "Test wavelength index: ",itestlam,ismoothlam
     write(*,*) "Test Kappa Abs",grid%oneKappaAbs(1,itestLam)
  end if

  !===============================================================
  if (gridUsesAMR) then  !========================================
  !===============================================================

!$MPI  if (my_rank==1) &
     call tune(6, "AMR grid construction.")  ! start a stopwatch



     if (readPops .or. readPhasePops .or. readLucy) then 

        if (readLucy) call readAMRgrid(lucyFilenameIn,readFileFormatted,grid)

        if (readPhasePops) then ! need to get the right file for the phase
          write(tempChar,'(i3.3)') nStartPhase
          phasePopFilename = trim(popFilename)//'_phase'//TRIM(tempChar)
          call readAMRgrid(phasePopFilename,readFileFormatted,grid)
        else ! just read the normal pops file
          if (readpops) call readAMRgrid(popFilename,readFileFormatted,grid)
        end if 
        if (forceLineChange) then
           write (*,'(A,I1,A,I1,A)') 'Recalculating for n =',nUpper,' /',nLower,'levels...'
           call generateOpacitiesAMR(grid, nLower, nUpper)
           print *, '...level change done.'
        end if

        ! for some geometries, it is valid to alter the 'dipoleOffset parameter
        !   for a grid we've already created. 
        if (geometry(1:6) == "ttauri") then 
          if (ABS(grid%dipoleOffset/dipoleoffset-1.0) > 0.01) then 
            write(*,'(a,f5.2,a)') 'Using new dipole offset value (',&
                                     dipoleOffset*radToDeg,'deg)'
            grid%dipoleOffset = dipoleOffset                         
            grid%diskNormal = VECTOR(0.,0.,1.)
            grid%diskNormal = rotateX(grid%diskNormal,grid%dipoleOffSet)
            
          end if
        end if

        ! In case, a user is using a new nlambda (number of wavelength bins)
        ! we have to update the wavelength array in the grid.
        ! This may not work for dust calculation...
        ! Copying the wavelength array to the grid
        if (grid%nlambda /= nlambda) then
           if (mie .or. (grid%geometry == "ttauri" .and. ttau_disc_on)) then              
              write(*,*) "Error:: The number of the wavelength bins in the data file "
              write(*,*) "        does not macth with that specifed in your parameter file."
              write(*,*) "nlambda(old) = ", grid%nlambda
              write(*,*) "nlambda(new) = ", nlambda
              write(*,*) " "
              write(*,*) "Make the new nlambda same as the old one, otherwise you cannot use"
              write(*,*) "this data file. This should be changed in future...."
              stop
           else 
              ! update the wavelength array.
              ! It over writes whatever the wavelength you had in your file!
              deallocate(grid%lamArray)
              allocate(grid%lamArray(nlambda))
              do i = 1, nLambda
                 grid%lamArray(i) = xArray(i)
              enddo
              grid%nLambda = nLambda
           end if
        end if

        !
        ! If the grid read from file contains ttauri disc, you can turn it
        ! off by setting ttau_trun_off_disc = .true. in your parameter file.
        if (grid%geometry=="ttauri" .and. ttau_turn_off_disc) then
           write(*,*) " "
           write(*,*) "Turning off the alpha disc read in from file, but keeping"
           write(*,*) "the magnetorsphere alive."
           call turn_off_disc(grid%octreeroot, grid, ttauri_disc)
        end if


!$MPI if (my_rank == 0) then   !-----------------------------------------------
        if (writePhasePops) then
          write(tempChar,'(i3.3)') nStartPhase
          phasePopFilename = trim(popFilename)//'_phase'//TRIM(tempChar)
          call writeAMRgrid(phasePopFilename,writeFileFormatted,grid)
        else if (writePops) then
          call writeAMRgrid(popFilename,writeFileFormatted,grid)
        end if


        ! Plotting the slices of planes
        call plot_AMR_values(grid, "rho", plane_for_plot, val_3rd_dim, &
             "rho_grid.ps/vcps",.true., .true.,&
             nmarker, xmarker, ymarker, zmarker, width_3rd_dim, show_value_3rd_dim)
        call plot_AMR_values(grid, "rho", plane_for_plot, val_3rd_dim, &
             "rho_zoom.ps/vcps",.true., .false.,&
             nmarker, xmarker, ymarker, zmarker, width_3rd_dim, show_value_3rd_dim, BOXFAC=0.01)
        call plot_AMR_planes(grid, "rho", plane_for_plot, 3, "rho", .true., .false., &
             nmarker, xmarker, ymarker, zmarker, show_value_3rd_dim)
        call plot_AMR_values(grid, "Vx", plane_for_plot, val_3rd_dim,  &
             "Vx.ps/vcps", .false., .false.,  &
             nmarker, xmarker, ymarker, zmarker, width_3rd_dim, show_value_3rd_dim)
        call plot_AMR_values(grid, "Vy", plane_for_plot, val_3rd_dim, &
             "Vy.ps/vcps", .false., .false., &
             nmarker, xmarker, ymarker, zmarker, width_3rd_dim, show_value_3rd_dim)
        call plot_AMR_values(grid, "Vz", plane_for_plot, val_3rd_dim, &
             "Vz.ps/vcps", .false., .false., &
             nmarker, xmarker, ymarker, zmarker, width_3rd_dim, show_value_3rd_dim)
!$MPI end if  ! (my_rank==0)--------------------------------------------------------
!$MPI  call MPI_BARRIER(MPI_COMM_WORLD, ierr)  ! 


     else  ! not reading a population file

!$MPI  !  Let the rank 0 node to create a grid, then write out to a file.
!$MPI  !  Later the other nodes reads in the same file.
!$MPI if (my_rank == 0) then ! ----------------------------------------------------
        amrGridCentre = octalVector(amrGridCentreX,amrGridCentreY,amrGridCentreZ)
        write(*,*) "Starting initial set up of adaptive grid..."

        select case (geometry)
        case("cluster")
           call initFirstOctal(grid,amrGridCentre,amrGridSize, amr2d, sphData, young_cluster, nDustType)
           call splitGrid(grid%octreeRoot,limitScalar,limitScalar2,grid, sphData, young_cluster)
           write(*,*) "...initial adaptive grid configuration complete"
           call fill_in_empty_octals(young_cluster,grid%octreeRoot,sphData)

           !Removing the cells within 10^14 cm from the stars.
           call remove_too_close_cells(young_cluster,grid%octreeRoot,1.0d4)

        case("wr104")
           call initFirstOctal(grid,amrGridCentre,amrGridSize, amr2d, sphData, young_cluster, nDustType)
           call splitGrid(grid%octreeRoot,limitScalar,limitScalar2,grid, sphData)
           write(*,*) "...initial adaptive grid configuration complete"

        case DEFAULT
           call initFirstOctal(grid,amrGridCentre,amrGridSize, amr2d, sphData, young_cluster, nDustType)
           call splitGrid(grid%octreeRoot,limitScalar,limitScalar2,grid)
           write(*,*) "...initial adaptive grid configuration complete"
           if (geometry=="ttauri") then
              if (ttau_discwind_on) then
                 write(*,*) " "
                 write(*,*) "Adding TTauri disc wind to magnetosphere model... "
                 call add_discwind(grid%octreeRoot, grid, ttauri_discwind, limitscalar2)
                 write(*,*) " "
              elseif (ttau_jet_on) then
                 write(*,*) " "
                 write(*,*) "Adding TTauri jets to magnetosphere model... "
                 call add_jet(grid%octreeRoot, grid, ttauri_jet)
                 call finish_grid_jet(grid%octreeroot, ttauri_jet)
                 write(*,*) " "
              end if
           end if
           if (doSmoothGrid) then
              write(*,*) "Smoothing adaptive grid structure..."
              gridConverged = .false.
              do
                 call smoothAMRgrid(grid%octreeRoot,grid,smoothFactor,gridConverged,inheritprops=.false.)
                 if (gridConverged) exit
              end do
              write(*,*) "...grid smoothing complete"
           end if
           ! chris (26/05/04)
           ! Smooth the grid with respect to optical depth, if requested
           if (doSmoothGridTau) then
              write(*,*) "Smoothing adaptive grid structure for optical depth..."
              do j = iSmoothLam, nLambda
                 do
                    gridConverged = .true.
                    call smoothAMRgridTau(grid%octreeRoot,grid,gridConverged,j,inheritprops = .false.)
                    if (gridConverged) exit
                 end do
              enddo
              write(*,*) "...grid smoothing complete"
              ! The tau smoothing may result in large differences in the size
              ! of neighbouring octals, so we smooth the grid again.
              if (doSmoothGrid) then
                write(*,*) "Smoothing adaptive grid structure (again)..."
                gridConverged = .false.
                do
                   call smoothAMRgrid(grid%octreeRoot,grid,smoothFactor,gridConverged,inheritprops = .false.)
                   if (gridConverged) exit
                end do
                write(*,*) "...grid smoothing complete"
              end if
           end if

        end select
   
        nOctals = 0
        nVoxels = 0
        call countVoxels(grid%octreeRoot,nOctals,nVoxels)
        write(*,*) "Adaptive grid contains: ",nOctals," octals"
        write(*,*) "                      : ",nVoxels," unique voxels"
        grid%nOctals = nOctals

        write(*,*) "Calling routines to finalize the grid variables..."
        gridConverged = .false.
     
        do
           call finishGrid(grid%octreeRoot,grid,gridConverged)
           if (gridConverged) exit
        end do        

        write(*,*) "...final adaptive grid configuration complete"

        call grid_info(grid, "*")
        call grid_info(grid, "info_grid.dat")


        if (writePhasePops) then
          write(tempChar,'(i3.3)') nStartPhase
          phasePopFilename = trim(popFilename)//'_phase'//TRIM(tempChar)
          call writeAMRgrid(phasePopFilename,writeFileFormatted,grid)
        else if (writePops) then
          call writeAMRgrid(popFilename,writeFileFormatted,grid)
        end if

        ! Plotting the slices of planes
        call plot_AMR_values(grid, "rho", plane_for_plot, val_3rd_dim, &
             "rho_grid.ps/vcps",.true., .true.,&
             nmarker, xmarker, ymarker, zmarker, width_3rd_dim, show_value_3rd_dim)
        call plot_AMR_values(grid, "rho", plane_for_plot, val_3rd_dim, &
             "rho_zoom.ps/vcps",.true., .false.,&
             nmarker, xmarker, ymarker, zmarker, width_3rd_dim, show_value_3rd_dim, BOXFAC=0.01)
        call plot_AMR_planes(grid, "rho", plane_for_plot, 3, "rho", .true., .false., &
             nmarker, xmarker, ymarker, zmarker, show_value_3rd_dim)
        call plot_AMR_values(grid, "Vx", plane_for_plot, val_3rd_dim,  &
             "Vx.ps/vcps", .false., .false.,  &
             nmarker, xmarker, ymarker, zmarker, width_3rd_dim, show_value_3rd_dim)
        call plot_AMR_values(grid, "Vy", plane_for_plot, val_3rd_dim, &
             "Vy.ps/vcps", .false., .false., &
             nmarker, xmarker, ymarker, zmarker, width_3rd_dim, show_value_3rd_dim)
        call plot_AMR_values(grid, "Vz", plane_for_plot, val_3rd_dim, &
             "Vz.ps/vcps", .false., .false., &
             nmarker, xmarker, ymarker, zmarker, width_3rd_dim, show_value_3rd_dim)
        call plot_AMR_values(grid, "temperature", plane_for_plot, val_3rd_dim, &
             "temperature.ps/vcps", .true., .false., &
             nmarker, xmarker, ymarker, zmarker, width_3rd_dim, show_value_3rd_dim)
        call plot_AMR_values(grid, "temperature", "x-y", 0., &
             "temperature2.ps/vcps", .true., .false., &
             nmarker, xmarker, ymarker, zmarker, width_3rd_dim, show_value_3rd_dim)


!     ! plotting column density (new routine in grid_mod.f90)
!     if (grid%geometry == "luc_cir3d") then 
!        call plot_column_density(grid, plane_for_plot,  "column_density.ps/vcps", &
!            nmarker, xmarker, ymarker, zmarker, &
!            width_3rd_dim, show_value_3rd_dim,val_3rd_dim)
!     end if


!$MPI       call writeAMRgrid(popFilename,writeFileFormatted,grid)
!$MPI      
!$MPI     ! now we can signal to the other processes (waiting above) that 
!$MPI     !   they can read in the grid.
!$MPI     print *,'Process ',my_rank,' signalling grid has become available...' 
!$MPI
!$MPI  end if ! (my_rank == 0) ---------------------------------------------
!$MPI 
!$MPI  call MPI_BARRIER(MPI_COMM_WORLD, ierr)   
!$MPI ! we hold all the non-root processes here until the grid has been
!$MPI !  written (below) 
!$MPI
!$MPI if(my_rank /= 0) then        
!$MPI   print *,'Process ',my_rank,' waiting for grid to become available...' 
!$MPI   call readAMRgrid(popFilename,readFileFormatted,grid)
!$MPI  end if
!$MPI  ! Wait until everybody reads in the grid 
!$MPI   call MPI_BARRIER(MPI_COMM_WORLD, ierr) 

        if (geometry == "ttauri" .or. geometry == "luc_cir3d" .or. geometry == "cmfgen") then
           nu = cSpeed / (lamLine * angstromtocm)
           call contread(contFluxFile, nu, coreContinuumFlux)
           call buildSphere(grid%starPos1, grid%rCore, starSurface, 400, contFluxFile)
           if (geometry == "ttauri") then
              call createTTauriSurface(starSurface, grid, nu, coreContinuumFlux,fAccretion) 
           else
              call createSurface(starSurface, grid, nu, coreContinuumFlux,fAccretion) 
           end if
           call testSurface(starSurface)
        endif

        if (lineEmission) then
           !  calculate the statistical equilibrium (and hence the emissivities 
           !  and the opacities) for all of the subcells in an
           !  adaptive octal grid.
           !  Using a routine in stateq_mod module.
           write(*,*) "Calling statistical equilibrium routines..."
!$MPI  if (my_rank==1) &
           call tune(6, "amrStateq") ! start a stopwatch  
           if (grid%geometry=="ttauri" .or.  &
                grid%geometry(1:8)=="windtest" .or. grid%geometry(1:9)=="luc_cir3d") then
              call amrStateq(grid, newContFluxFile,lte, nLower, nUpper, &
                             starSurface, recalcPrevious=.false.)

!$MPI   print *,'Process ',my_rank,' waiting for other amrStatEq calls to return...' 
!$MPI   call MPI_BARRIER(MPI_COMM_WORLD, ierr) ! wait for all the processes
              ! the 'lte' setting is intended so that a model with infall
              ! enhancement is first set up with LTE values. Only after we have 
              ! done the first time-dependent change so we calculate non-LTE 
              ! values.

              
              ! RK added the followings ------------------------------------------
              !  adding alpha disc to the grid
              if (ttau_disc_on) then
                 write(*,*) "Adding an acreation disc ... "
                 call add_alpha_disc(grid%octreeroot, grid, ttauri_disc)
                 ! finding the photon-dust interaction x-secions
                 call mieCrossSection(sigmaExt0, sigmaAbs0, sigmaSca0,  &
                      aMin, aMax, a0, qDist, pDist, grainType, &
                      ngrain, X_grain, grainname, lamLine)
                 write(*,*) " "
                 write(*,*) "Photon-dust cross section at lambda = ", lamLine, " [A]"
                 write(*,*) "    sigma(tot) = ", sigmaExt0, " [cm^2]"
                 write(*,*) "    sigma(abs) = ", sigmaAbs0, " [cm^2]"
                 write(*,*) "    sigma(sca) = ", sigmaSca0, " [cm^2]"
                 write(*,*) " "
                 call finish_grid(grid%octreeroot, grid, ttauri_disc, 1.0, &
                      sigmaAbs0, sigmaSca0, meanDustParticleMass)
                 !
                 !
                 allocate(lambda(1:maxTau),tauExt(1:maxTau),tauAbs(1:maxTau),tauSca(1:maxTau),&
                          contTau(1:maxTau,1:nLambda), linePhotonalbedo(1:maxtau))
                 call integratePath(gridUsesAMR, VoigtProf, &
                      lambdatau,  lamLine, OCTALVECTOR(1.,1.,1.), OCTALVECTOR(150.0,0,-200.), &
                      OCTALVECTOR(0.,0.,1.), grid, lambda, tauExt, tauAbs, &
                      tauSca, linePhotonAlbedo, maxTau, nTau, thin_disc_on, opaqueCore, escProb, .false. , &
                      lamStart, lamEnd, nLambda, contTau, hitCore, thinLine, lineResAbs, .false., &
                      .false., nUpper, nLower, 0., 0., 0., junk,&
                      sampleFreq,intPathError, useInterp, grid%Rstar1, coolStarPosition)              
                 write(*,*) " ----  Vertical optical depth at r = 0.1 AU is ", tauExt(ntau)
                 write(*,*) " ----                           at lambda =  ", lambdatau
!                 write(*,*) "Rescaling scattering and absorption coefficients ... "
!                 call finish_grid(grid%octreeroot, grid, ttauri_disc, tauExt(ntau)/100.0)
!                 call integratePath(gridUsesAMR, VoigtProf, &
!                      lambdatau,  lamLine, OCTALVECTOR(1.,1.,1.), OCTALVECTOR(75.0,0,-50.), &
!                      OCTALVECTOR(0.,0.,1.), grid, lambda, tauExt, tauAbs, &
!                      tauSca, maxTau, nTau, thin_disc_on, opaqueCore, escProb, .false. , &
!                      lamStart, lamEnd, nLambda, contTau, hitCore, thinLine, lineResAbs, .false., &
!                      .false., nUpper, nLower, 0., 0., 0., junk,&
!                      sampleFreq,intPathError, useInterp, grid%Rstar1, coolStarPosition)              
!                 write(*,*) " ---- New Optical depth  at r = 0.05 AU    is ", tauExt(ntau)
!                 write(*,*) " ----                           at lambda =  ", lambdatau
                 deallocate(lambda,tauExt,tauAbs,tauSca,contTau,linePhotonalbedo)
!                 write(*,*) ".. Finished rescaling scattering and absorption coefficients ... "
                 write(*,*) ".. Finished adding an acreation disc ... "
              end if
              !-------------------------------------------------------------------

           elseif (geometry == "cmfgen") then
              ! simply map CMFGEN opacity data to the AMR grid
              call map_cmfgen_opacities(grid)

           else

              call amrStateq(grid, newContFluxFile, lte, nLower, nUpper, &
                      starSurface, recalcPrevious=.false., ion_name=ion_name, ion_frac=ion_frac)
!              if (ttau_disc_on) then
!                 ! amrStateq will have messed up the disc, so we reset those cells
!                 call finish_grid(grid%octreeroot, grid, ttauri_disc, 1.0, sigmaAbs0, sigmaSca0)
!              end if

!$MPI   print *,'Process ',my_rank,' waiting for other amrStatEq calls to return...' 
!$MPI   call MPI_BARRIER(MPI_COMM_WORLD, ierr) ! wait for all the processes

           end if ! (grid%geometry=="ttaur" .or. ...)

!$MPI  if (my_rank==1) &
           call tune(6, "amrStateq") ! stop a stopwatch  
           write(*,*) "... statistical equilibrium routines complete"



        end if ! (lineEmission)

        !
        ! cleaning up unused memory here ....
        if ((geometry(1:7) == "cluster").or.(geometry(1:5)=="wr104")) then
           ! using the routine in sph_data_class
           call kill(sphData)
           ! using the routine in amr_mod.f90
!$MPI if  (my_rank ==0) &
           call delete_particle_lists(grid%octreeRoot)

        elseif (geometry == "luc_cir3d") then
           call deallocate_zeus_data()
        end if


     end if ! (readPops .or. readPhasePops)


             
!$MPI  if (my_rank==0)  then
     ! writing pop files after statEq routines
     if (writePhasePops) then
        write(tempChar,'(i3.3)') nStartPhase
        phasePopFilename = trim(popFilename)//'_phase'//TRIM(tempChar)
        call writeAMRgrid(phasePopFilename,writeFileFormatted,grid)
     end if
     if (writePops) then
        call writeAMRgrid(popFilename,writeFileFormatted,grid)
     end if
!$MPI  end if
!$MPI   call MPI_BARRIER(MPI_COMM_WORLD, ierr) ! sync here

!$MPI  if (my_rank==1) &
   call tune(6, "AMR grid construction.") ! stop a stopwatch


!     if (geometry == "ttauri".and.VoigtProf) then
!        write(*,*) "Setting biases for stark broadening..."
!        call setBiasChil(grid%octreeroot)
!        write(*,*) "done..."
!     endif

     if (geometry(1:6) == "ttauri") then
!$MPI if (my_rank==0) then
        call writeHartmannValues(grid,'hartmann_logNH')
        call writeHartmannValues(grid,'hartmann_logNe')
        call writeHartmannValues(grid,'hartmann_temperature')
        call writeHartmannValues(grid,'hartmann_velPol')
        call writeHartmannValues(grid,'hartmann_velAz')
        call writeHartmannValues(grid,'hartmann_line')
        !call writeHartmannValues(grid,'hartmann_Nelectron')
        call writeHartmannValues(grid,'hartmann_Nlevel2')
        call writeHartmannValues(grid,'hartmann_NH')
        !call writeHartmannValues(grid,'hartmann_departCoeff')
        call writeHartmannValues(grid,'hartmann_N')
!$MPI end if
     end if

  !=================================================================
  else ! grid is not adaptive ======================================     
  !=================================================================

     ! fill up the grid with the appropriate opacities
 
     if (.not.plezModelOn) then
        select case(geometry)
        case("torus")
           call fillGridTorus(grid, rho, rTorus, rOuter)
        case("sphere")
           call fillGridSpheriod(grid, rho, radius, kFac)
        case("flared")
           call fillGridFlaredDisk(grid, meanDustParticleMass)
        case("ellipse")
           call fillGridEllipse(Grid,rho, rMin, rMaj, rinner, teff)
        case("disk")
           call fillGridDisk(grid, rho, rCore, rInner, rOuter, height, mCore, diskTemp)
        case("star")
           call fillGridStar(grid, radius, mdot, vel, kfac, scale)
        case("spiral")
           call fillGridSpiral(grid, radius, mdot, vel, scale)
        case("shell")
           call fillGridShell(grid, radius, shellFrac, rho, kfac)
        case("stateq")
           call fillGridStateq(grid, opacityDataFile, kfac, scaleDensity)
        case("bipolar")
           call fillGridBipolar(grid, rho,  30.)
        case("collide")
           call fillGridCollide(grid, rho, momRatio, binarySep, mie, meanDustParticleMass, logMassLossRate)
        case("dustblob")
           call fillGridDustBlob(grid, dustBlobdistance, rho, phiDustBlob, &
                xDustBlobSize, yDustBlobSize, zDustBlobSize)
        case("raman")
           call  fillGridRaman(grid, 10.*rStar, mdot, vterm, rStar, coolStarPosition, beta)
        case("binary")
           call fillGridBinary(grid, radius1, radius2, mass1, mass2, &
           temp1, temp2, vNought1, vNought2, vTerm1, vTerm2, beta1, beta2, period, &
           mdot1, mdot2, deflectionAngle, shockWidth, shockFac)
        
           call initGridStateq(grid, contFluxFile, contFluxFile2, &
                popFilename, readPops, writePops, lte, nLower, nUpper)
        
        case("rolf")
           call fillGridRolf(grid, mdot, vterm, o6width)
        case("wr137")
           call fillGridWR137(grid, rCore, mDot, vTerm, beta, temp1)
        case("planet")
           call fillGridPlanet(grid)
        case("hourglass")
           call fillGridHourglass(grid)
        case("ttauri")
           call fillGridMagneticAccretion(grid,contfluxfile, popFileName, &
              readPops, writePops, lte,  lamLine, Laccretion, Taccretion, sAccretion, &
              curtains, dipoleOffset, nLower, nUpper, theta1, theta2)
        case("ttwind")
           call fillGridTTauriWind(grid,contfluxfile, popFileName, &
                readPops, writePops, lte, nLower, nUpper)
        case("betacep")
            call fillGridBetaCep(grid)
        case("donati")
           resonanceLine = .false.
           if (lamLine < 2000.) resonanceLine = .true.
           call fillGridDonati2(grid, resonanceLine, misc)
           if (.not.resonanceLine) then
              call initGridStateq(grid, contFluxFile, contFluxFile2, popFilename, &
                   readPops, writePops, lte, nLower, nUpper)
           endif
           grid%kappaAbs = 1.e-30


        case("puls")
           call fillGridPuls(grid, mDot, rcore, tEff, v0, vterm, beta, xfac, blobs, maxBlobs, .false., vContrast)
   !        call initGridStateq(grid, contFluxFile, contFluxFile2, popFilename, &
   !                            readPops, writePops, lte, nLower, nUpper)
        case("wind")
!           call fillGridWind(grid, mDot, rStar, tEff, v0, vterm, beta, &
!           lte, contFluxFile, writePops, readPops, popFilename, nLower, nUpper)

        call initgridstateq(grid, contfluxFile, " ", popFileName, &
           readPops, writePops, lte, nLower, nUpper)
           grid%etaCont = 1.e-30
           grid%kappaAbs = 1.e-30

        
        case("resonance")
           call fillGridResonance(grid, rCore, mDot, vTerm, beta, temp1)

        case DEFAULT
           write(*,*) "! Unrecognised grid geometry: ",trim(geometry)
           goto 666
        end select
     endif ! (.not.plezModelOn)

     if (fillTio) then
        call fillGridTio(grid, scale)
     endif

     if (fillRayleighOpacity) then
        call fillGridRayleigh(grid,scale)
     endif 

     if (fillThomson) then
        call fillGridThomson(grid)
     endif

  ! the distortion types

     select case(distortionType)
     case("spiral")
        call distortGridSpiral(grid, vRot, nSpiral)
     case("rotation")
        call distortRotation(grid, vRot)
        write(*,'(a,f5.1,a)') "Grid distorted by a rotational velocity of ", &
                               vRot/1.e5," km/s"
     case("test")
        call distortGridTest(grid)
!     case("raman")
!        call distortRaman(grid)
     case("raman")
        call  distortStrom(grid, secondSourcePosition, .true., .true., 0.5*rStar, coolStarPosition, ramanDist)

     case("wrdisk")
        call distortWRdisk(grid)
     case("windwind")
        call distortWindCollision(grid, momRatio, binarySep)

     end select

  endif ! (grid%usesAMR)
  
  if (enhance .and. .not. grid%adaptive) then
     nVec = 100
     nPhi = 360
     allocate(distortionVec(nVec))
     timeStart = 0.
     timeEnd = 12.*3600.
     dTime = (timeEnd - timeStart)/real(nPhase)
     call initInfallEnhancement(distortionVec, nVec, nPhi, infallParticleMass)
     do i = 1, nStartPhase-1
        call infallEnhancment(grid, distortionVec, nVec, nPhi, dTime, &
                              .false., infallParticleMass, alreadyDoneInfall)
     enddo
  endif


  if (geometry(1:7) .eq. "testamr") then


    do i = 1, 1000
       meant = 0.
       meaneta =0.
       nt = 0
       r = log10(grid%rInner) + (log10(grid%rOuter)-log10(grid%rInner))* real(i-1)/999.
       r = 10.**r
       r1 = log10(grid%rInner) + (log10(grid%rOuter)-log10(grid%rInner))* real(i)/999.
       r1 = 10.**r1
       rGrid(i) = r
       drGrid(i) = r1 - r
    enddo



    open(21,file="r.dat",status="unknown",form="formatted")
    call locate(xarray, nLambda, 10.e4, ilambda)

    prGrid = 0.
    do i = 1, 1000
       meant = 0.
       meaneta =0.
       nt = 0
       outVec = VECTOR(1., 0., 0.)
       rVec = rGrid(i) * outVec 
       r = rgrid(i)
!       call integratePathAMR(10.e4,  lamLine, VECTOR(1.,1.,1.), &
!            rVec, outVec, grid, lambda, &
!            tauExt, tauAbs, tauSca, maxTau, nTau, opaqueCore, escProb, &
!            .false., lamStart, lamEnd, nLambda, contTau, &
!            hitCore, thinLine,.false.,  &
!            .false., nUpper, nLower, 0., 0., 0., junk,sampleFreq,intPathError)



       do j = 1, 100
          ang = twoPi * real(j-1)/100.
          octVec = OCTALVECTOR(r*cos(ang), r*sin(ang),0.)
          call amrGridValues(grid%octreeRoot, octVec, temperature=treal, &
              ilambda=1, grid=grid ,etacont = eta, kappaAbs=kabs)
          if (treal > 1.) then
             t1 = dble(treal)
             meant = meant + t1
             meaneta = meaneta + eta
             nt = nt + 1
          endif
       enddo
       if (nt > 0) then
          write(21,*) r/grid%rInner,meant/real(nt), meaneta * r**2 * drgrid(i)/ real(nt)
       endif
    Enddo
    close(21)
 endif

  if (grid%geometry(1:8) == 'windtest') then
     do i = 1, 1000
       r = log10(grid%rInner) + (log10(grid%rOuter)-log10(grid%rInner))* real(i-1)/999.
       r = 10.**r
       r1 = log10(grid%rInner) + (log10(grid%rOuter)-log10(grid%rInner))* real(i)/999.
       r1 = 10.**r1
       rGrid(i) = r
       drGrid(i) = r1 - r
    enddo
    
    open(21,file="rDepart.dat",status="unknown",form="formatted")

    prGrid = 0.
    do i = 1, 1000
       meanDepart = 0.
       nt = 0
       outVec = VECTOR(1., 0., 0.)
       rVec = rGrid(i) * outVec 
       r = rgrid(i)
!       call integratePathAMR(10.e4,  lamLine, VECTOR(1.,1.,1.), &
!            rVec, outVec, grid, lambda, &
!            tauExt, tauAbs, tauSca, maxTau, nTau, opaqueCore, escProb, &
!            .false., lamStart, lamEnd, nLambda, contTau, &
!            hitCore, thinLine,.false.,  &
!            .false., nUpper, nLower, 0., 0., 0., junk,sampleFreq,intPathError)



       do j = 1, 100
          ang = twoPi * real(j-1)/100.
          octVec = OCTALVECTOR(r*cos(ang), r*sin(ang),0.)
          call amrGridValues(grid%octreeRoot, octVec, temperature=tReal, &
              ilambda=1, N=levelPops, Ne=Ne)
          t1 = dble(treal)
          do level = 1, statEqMaxLevels, 1
             meanDepart(level) = meanDepart(level) + real(levelPops(level))/boltzSaha(level,Ne,dble(treal))
          end do
          nt = nt + 1
       enddo
       if (nt > 0) then
          write(21,*) r/grid%rInner,meanDepart/real(nt)
       endif
    Enddo
    close(21)
  end if ! windtest

 
  ! Print the infomation on the grid to the standard ouput.
  ! -- using a routine in grid_mod.f90
!$MPI  if(my_rank == 0)  then  
  call grid_info(grid, "*")
  call grid_info(grid, "info_grid.dat")
!$MPI  end if


  if (mie) then
  
     endif


  !
  ! Plotting the various values stored in the AMR grid.
  !

!$MPI   if (my_rank==0) then

  if(gridUsesAMR .and. plot_maps) then

     !
!     if (grid%geometry == "jets"  .or. &
!          grid%geometry == "ttauri"  .or.  grid%geometry == "testamr" ) then
!        call draw_cells_on_density(grid, plane_for_plot, "cells_on_density.ps/vcps")
!        !     call draw_cells_on_density(grid, plane_for_plot, device)
!     end if
     

     ! Do some preparation for the arrays used in plot_AMR_* which will be used later
     if (grid%geometry(1:7) == "cluster") then
        nmarker = get_nstar(young_cluster)
        do i = 1, nmarker
           a_star = get_a_star(young_cluster, i)
           xmarker(i)= a_star%position%x
           ymarker(i)= a_star%position%y
           zmarker(i)= a_star%position%z
        end do
        width_3rd_dim = amrGridSize
     end if


     !  call fancyAmrPlot(grid, device)
     
     ! Plot desired AMR grid value here... This is more generalized
     ! version of fancyAmrPlot.
     !
     ! See grid_mod.f90 for details.
     !
   
     ! Plotting some grid values
     call plot_AMR_values(grid, "rho", plane_for_plot, val_3rd_dim, &
          "rho_grid.ps/vcps",.true., .true.,&
          nmarker, xmarker, ymarker, zmarker, width_3rd_dim, show_value_3rd_dim)
     call plot_AMR_values(grid, "rho", plane_for_plot, val_3rd_dim, &
          "rho_zoom.ps/vcps",.true., .false.,&
          nmarker, xmarker, ymarker, zmarker, width_3rd_dim, show_value_3rd_dim, BOXFAC=0.005)
     call plot_AMR_planes(grid, "rho", plane_for_plot, 3, "rho", .true., .false., &
          nmarker, xmarker, ymarker, zmarker, show_value_3rd_dim)
     call plot_AMR_values(grid, "Vx", plane_for_plot, val_3rd_dim,  &
          "Vx.ps/vcps", .false., .false.,  &
          nmarker, xmarker, ymarker, zmarker, width_3rd_dim, show_value_3rd_dim)
     call plot_AMR_values(grid, "Vy", plane_for_plot, val_3rd_dim, &
          "Vy.ps/vcps", .false., .false., &
          nmarker, xmarker, ymarker, zmarker, width_3rd_dim, show_value_3rd_dim)
     call plot_AMR_values(grid, "Vz", plane_for_plot, val_3rd_dim, &
          "Vz.ps/vcps", .false., .false., &
          nmarker, xmarker, ymarker, zmarker, width_3rd_dim, show_value_3rd_dim)
     call plot_AMR_values(grid, "etaCont", plane_for_plot, val_3rd_dim,  &
          "etacont.ps/vcps", .true., .false.,  &
          nmarker, xmarker, ymarker, zmarker, width_3rd_dim, show_value_3rd_dim)
     call plot_AMR_values(grid, "etaCont", plane_for_plot, val_3rd_dim,  &
          "etacont_zoom.ps/vcps", .true., .false.,  &
          nmarker, xmarker, ymarker, zmarker, width_3rd_dim, &
     show_value_3rd_dim, boxfac = 0.0004)
     call plot_AMR_values(grid, "temperature", plane_for_plot, val_3rd_dim, &
          "temperature.ps/vcps", .true., .false., &
          nmarker, xmarker, ymarker, zmarker, width_3rd_dim, show_value_3rd_dim)
     call plot_AMR_values(grid, "temperature", "x-y", 0., &
          "temperature2.ps/vcps", .true., .false., &
          nmarker, xmarker, ymarker, zmarker, width_3rd_dim, show_value_3rd_dim)
     if (lineEmission) then
        call plot_AMR_values(grid, "etaLine", plane_for_plot, val_3rd_dim,  &
             "etaline.ps/vcps", .true., .false., & 
             nmarker, xmarker, ymarker, zmarker, width_3rd_dim, show_value_3rd_dim)
        call plot_AMR_values(grid, "chiLine", plane_for_plot, val_3rd_dim,  &
             "chiline.ps/vcps", .true., .false., &
           nmarker, xmarker, ymarker, zmarker, width_3rd_dim, show_value_3rd_dim)
     end if

!     ! plotting column density (new routine in grid_mod.f90)
!     if (grid%geometry(1:7) == "cluster") then 
!       call plot_column_density(grid, plane_for_plot,  "column_density.ps/vcps", &
!             nmarker, xmarker, ymarker, zmarker, width_3rd_dim, show_value_3rd_dim,val_3rd_dim)
!     end if
     
  end if

!$MPI  end if  ! if (my_rank ==0)
  
  ! The source spectrum is normally a black body

  if (.not.grid%lineEmission) then
     stot = 0.
     do i = 1, nLambda
        sourceSpectrum(i) = bLambda(dble(xArray(i)), dble(teff))
        stot = stot + sourceSpectrum(i)
     enddo
     sourceSpectrum  = sourceSpectrum / stot
  endif



  ! set up a random seed
  
  call random_seed

!  iseed(1:4) = 1
!  call random_seed(PUT=iseed)
!  do i = 1,100
!     write(*,*) "random seed off."
!  enddo
  outVec = (-1.)* originalViewVec


  ! compute the mie scattering phase matrices if necessary

  xMin =  2.*pi*grainSize/(lamEnd*angstromToCm)
  xMax =  2.*pi*grainSize/(lamStart*angstromToCm)

  if (mie .or.  (grid%geometry == "ttauri" .and. ttau_disc_on)) then
     ! construct the mie phase matrix
     write(*,'(a)') "Computing Mie phase grid..."

     allocate(mReal(1:nLambda))
     allocate(mImg(1:nLambda))

     if (graintype(1:5) == "mixed") then
        ! Synthetic grains
         
        ! quick test for zero total dust abundance.
        total_dust_abundance = SUM(X_grain)
        if ( total_dust_abundance <= 0.0 ) then
!$MPI     if (my_rank==0) &
           write(*,*) "Error:: total_dust_abundance <= 0.0 in torusMain."
!$MPI     if (my_rank==0) &
           write(*,*) "  ==> You probably forgot to assign dust abundance in your "// &
                & "parameter file!"
!$MPI     if (my_rank==0) &
           write(*,*) "  ==> Exiting the prograim ... "
            stop 
         end if

         ! allocate mem for temp arrays
         allocate(mReal2D(1:ngrain, 1:nLambda))
         allocate(mImg2D(1:ngrain, 1:nLambda))
         ! initializing the values
         mReal2D(:,:) = 0.0; mImg2D(:,:) = 0.0
         
         ! Find the index of refractions for all types of grains available
         do j = 1, ngrain
            call getRefractiveIndex(xArray, nLambda, grainname(j), mReal, mImg)
            mReal2D(j,:) = mReal(:)  ! copying the values to a 2D maxtrix
            mImg2D(j,:)  = mImg(:)   ! copying the values to a 2D maxtrix            
         end do

         ! Finding the weighted average of the refractive index.
         mReal(:) = 0.0; mImg(:) = 0.0
         do i = 1, nLambda
            do j = 1, ngrain
               mReal(i) = mReal2D(j,i)*X_grain(j) + mReal(i)
               mImg(i)  = mImg2D(j,i) *X_grain(j) + mImg(i)
            end do
            mReal(i) = mReal(i) / total_dust_abundance
            mImg(i)  = mImg(i)  / total_dust_abundance
         end do


         deallocate(mReal2D)
         deallocate(mImg2D)

      else 
         ! Do a single grain calculations... 

         call getRefractiveIndex(xArray, nLambda, graintype, mReal, mImg)
         
      end if


      do i = 1, nLambda
         do j = 1, nMumie
            mu = 2.*real(j-1)/real(nMumie-1)-1.
            if (.not.isotropicScattering) then
               call mieDistPhaseMatrix(aMin, aMax, a0, qDist, pDist, xArray(i), &
                    mu, miePhase(i,j), mReal(i), mImg(i))               
               else
                  miePhase(i,j) = fillIsotropic(mu)
               endif
            !           miePhase(i,j) = fillRayleigh(mu)
         end do
      end do


     deallocate(mReal)
     deallocate(mImg)
     write(*,'(a)') "Completed."


  endif

  ! set up the sources

  nSource = 0

  select case(geometry)
    case("testamr","benchmark")
       nSource = 1
       allocate(source(1:1))
       source(1)%luminosity = grid%lCore
       source(1)%radius = grid%rCore
       source(1)%teff = teff
       source(1)%position = VECTOR(0.,0.,0.)
       call fillSpectrumBB(source(1)%spectrum, dble(teff),  dble(lamStart), dble(lamEnd),nLambda)
       call normalizedSpectrum(source(1)%spectrum)
    case("melvin")
       nSource = 1
       teff = 30000.
       allocate(source(1:1))
       source(1)%luminosity = fourPi * (10.*rsol)*(10.*rsol) * stefanBoltz * teff**4
       source(1)%radius = 10.*rSol / 1.e10
       source(1)%teff = teff
       source(1)%position = VECTOR(0.,0.,0.)
       call fillSpectrumBB(source(1)%spectrum, dble(teff),  dble(lamStart), dble(lamEnd),nLambda)
       call normalizedSpectrum(source(1)%spectrum)
       rstar = source(1)%radius
    case("wr104")
       nSource = 2

       allocate(source(1:nSource)) 
       source(1)%teff = 30000.  ! o star
       source(1)%radius = 20. * rSol / 1.e10
       source(1)%position = (VECTOR(0.,0.,1.)*autocm)/1.e10
       source(1)%luminosity = fourPi * stefanBoltz * (20.*rSol)**2.0 * (source(1)%teff)**4
       call readSpectrum(source(1)%spectrum, "ostar.flx")
       call normalizedSpectrum(source(1)%spectrum)

       source(2)%teff = 40000.             ! wr star 
       source(2)%radius = 20. * rSol / 1.e10
       source(2)%position = (VECTOR(0.,0.,-1)*autocm)/1.e10
       source(2)%luminosity = 0.5 * source(1)%luminosity
       call readSpectrum(source(2)%spectrum, "wr.flx")
       call normalizedSpectrum(source(2)%spectrum)

    case ("cluster")
       ! Extract some info from cluster object.
       nstar = get_nstar(young_cluster)  ! number of stars in the cluster
       nSource =  n_stars_in_octal(young_cluster, grid%octreeRoot)
       
       ! copy the star over in the array.
       ! This is ugly. Maybe lucyRadiativeEquilibriumAMR should be changed to take
       ! an cluster_class object as an input variable in future.
       ALLOCATE(source(nSource))
       
       ! Restricting the source to be within the root cell (in case the root cell is 
       ! is smaller than the sph model space!
       j = 0 
       do i = 1, nstar
          a_star = get_a_star(young_cluster, i)
          ! using a function in source_mod
          if ( source_within_octal(a_star, grid%octreeRoot) ) then
             j = j+1
             source(j) = a_star
          end if
       end do

    case("shakara","clumpydisc")
       nSource = 1
       allocate(source(1:1))
       source(1)%radius = grid%rCore
       source(1)%teff = teff   
       source(1)%position = VECTOR(0.,0.,0.)
       tmp = source(1)%radius * 1.e10  ! [cm]
       source(1)%luminosity = fourPi * stefanBoltz * (tmp*tmp) * (source(1)%teff)**4
       call fillSpectrumBB(source(1)%spectrum, dble(teff), &
            dble(lamStart), dble(lamEnd),nLambda)
!       call readSpectrum(source(1)%spectrum, "kurucz.dat")
       call normalizedSpectrum(source(1)%spectrum)


    case default
       ! Allocating the source array with size =0 to avoid, non-allocated array passed problem
       ! in subroutine initPhoton...
       if (.not. allocated(source)) ALLOCATE(source(0))
       nSource = 0  ! This must be zero!
       
  end select

  

     if (geometry == "wr104") then
!        call IntegratePathAMR(lambdatau,  lamLine, VECTOR(1.,1.,1.), zeroVec, &
!             VECTOR(0.,0.,1.), grid, lambda, tauExt, tauAbs, &
!             tauSca, maxTau, nTau, opaqueCore, escProb, .false. , &
!             lamStart, lamEnd, nLambda, contTau, hitCore, thinLine, .false., &
!             .false., nUpper, nLower, 0., 0., 0., junk,&
!             sampleFreq,intPathError)
!        if (intPathError < 0) then
!           write(*,*) '   Error encountered in cross-sections!!! (error = ',intPathError,')'
!        end if
        totalMass = 0.d0
        call findTotalMass(grid%octreeRoot, totalMass)
        scaleFac = massEnvelope / totalMass
        write(*,'(a,1pe12.5)') "Density scale factor: ",scaleFac
        call scaleDensityAMR(grid%octreeRoot, scaleFac)

     else if (geometry == "cluster") then
        call find_average_temperature(grid, T_ave, T_mass, totalMass)
        write(*,*) " "
        write(*,'(a,1pe12.4, a5)') "Total dust mass in cluster  : ", TotalMass, " [g]"
        write(*,'(a,1pe12.4, a5)') "Ave. temperature of cluster : ", T_ave,    " [K]"
        write(*,'(a,1pe12.4, a5)') "Mass weighted ave. temperature of cluster : ",T_mass,  " [K]"
        write(*,*) " "
        ! computing the max, min and average tau at 2 micron (of all
        ! active cells)
        ilambda = findIlambda(20000.0, xArray, nLambda, ok)
        call find_max_min_ave_tau(grid, ilambda, tau_max, tau_min,  tau_ave)
        write(*,*) " "
        write(*,'(a,1pe12.4, a11)') "Max tau(1 micron) = ", tau_max, " [contiuum]"
        write(*,'(a,1pe12.4, a11)') "Min tau(1 micron) = ", tau_min, " [contiuum]"
        write(*,'(a,1pe12.4, a11)') "Ave tau(1 micron) = ", tau_ave, " [contiuum]"
        write(*,*) " "
     end if


     if (mie) then
        totalMass =0.d0
        call findTotalMass(grid%octreeRoot, totalMass)
        write(*,*) "Mass of envelope: ",totalMass/mSol, " solar masses"
	if (geometry == "shakara") then
        sigma0 = totalMass / (twoPi*(rOuter*1.e10-rInner*1.e10)*1.*autocm) ! defined at 1AU
        write(*,*) "Sigma0: ",sigma0
	endif
     endif


!$MPI   call MPI_BARRIER(MPI_COMM_WORLD, ierr)



  if (lucyRadiativeEq) then
!$MPI  if (my_rank==1) &
     call tune(6, "LUCY Radiative Equilbrium")  ! start a stopwatch
 
     if (grid%cartesian .or. grid%polar) then
        call lucyRadiativeEquilibrium(grid, miePhase, nMuMie, nLambda, xArray, dble(teff), nLucy)
     else
        if (readLucy .and. .not. redoLucy) then
           continue
        else

           if (solveVerticalHydro) then
              call verticalHydrostatic(grid, mCore, sigma0, rInner, miePhase, nMuMie, nLambda, xArray, &
                   source, nSource, nLucy, massEnvelope, tThresh, twod, mDisc)
           else
              call lucyRadiativeEquilibriumAMR(grid, miePhase, nMuMie, & 
                   nLambda, xArray, source, nSource, nLucy, massEnvelope, tthresh, lucy_undersampled, twod, 10)
           endif

        endif
        
!$MPI        if (my_rank==0) then
        if (writeLucy) call writeAMRgrid(lucyFilenameOut,writeFileFormatted,grid)
!$MPI        end if

     endif     
!     if (grid%geometry == "testamr") call setBiasAMR(grid%octreeRoot, grid)
! ==== LINE ABOVE WAS MOVED TO LATER FOR CLEARITY ========================
!$MPI     if (my_rank==1) &
     call tune(6, "LUCY Radiative Equilbrium")  ! stop a stopwatch


     if (grid%geometry(1:7) == "cluster") then
!$MPI        if (my_rank==0) then
        ! Finding apperant magnitudes and colors of the stars in cluster
        write (*,*) " "
        write (*,*) "Computing the magnitudes and colors of stars ..."
        ! -- note grid distance here is in [pc]
         call analyze_cluster(young_cluster,s2o(outVec),dble(gridDistance),grid)

!$MPI        end if
!$MPI     ! Synchronizing everybody here.
!$MPI     call MPI_BARRIER(MPI_COMM_WORLD, ierr) 


        ! restricting the sed and images calculations to the star 
        ! with ID number = idx_restrict_star. 
        ! By default idx_restrict_star =0 which means all stars the cluster
        ! are included in the calculations.  Specifty a value in your
        ! parameter file to restrict to one star.  (10 AU cylinder
        ! zone is used to restrict the effective computational domain.
        call restrict(grid%octreeroot, idx_restrict_star, nsource, &
                      source,  s2o(outVec), 7.5d4) ! the last value is 50 AU (in 10^10cm)
	!                      source,  s2o(outVec), 1.5d4) ! the last value is 10 AU (in 10^10cm)

        call reassign_10K_temperature(grid%octreeroot)

        ! delete the cluster object since it won't be used any more.
        call kill_all(young_cluster)
     end if 


! THESE LINES ARE MOVED TO OUTSIDE OF IF (LUCY..) BLOCK
!      !
!      ! Setting the emission bias.
!      !
!      if (grid%geometry == "testamr") then
!         call setBiasAMR(grid%octreeRoot, grid)
!      elseif (grid%geometry == "cluster") then
!         ! Computing the emission bias based on the optical depth at
!         ! 2 microns. 
!         call assign_emission_bias(grid%octreeroot, grid, 20000.0, xArray, nLambda)
!      elseif (grid%geometry == "ttauri") then
!         ! --using a routine in amr_mod
!         call set_bias_ttauri(grid%octreeRoot, grid)
!      end if


     ! Plotting the slices of planes
!$MPI        if (my_rank==0) then
     if (plot_maps) then
       call plot_AMR_planes(grid, "temperature", plane_for_plot, 3, "temperature", &
            .true., .false., nmarker, xmarker, ymarker, zmarker, show_value_3rd_dim)
       call plot_AMR_planes(grid, "etaCont", plane_for_plot, 3, "etaCont", .true., .false., &
            nmarker, xmarker, ymarker, zmarker, show_value_3rd_dim)
     end if
!$MPI        end if

!$MPI     ! Synchronizing everybody here.
!$MPI     call MPI_BARRIER(MPI_COMM_WORLD, ierr) 


  endif


  
  !
  ! Setting the emission bias.
  !
  if (grid%geometry == "testamr") then
     call setBiasAMR(grid%octreeRoot, grid)
  elseif (grid%geometry == "cluster") then
     ! Computing the emission bias based on the optical depth at
     ! 2 microns. 
     call assign_emission_bias(grid%octreeroot, grid, 20000.0, xArray, nLambda)
  end if
  
!$MPI        if (my_rank==0) then
  if (geometry == "shakara") call polardump(grid)
!$MPI        endif


  
  ! initialize the blobs if required

    if (nBlobs > 0) then
  
       allocate(blobs(1:maxBlobs))
       if (freshBlobs) then
          do i = 1 , maxBlobs
             blobs(i)%inUse = .false.
          enddo
          write(*,'(a)') "Running blobs for five days..."
   
          ! now we run a few of days worth of blobs
  
          t1 = 0.
          t2 = 240. * 60. * 60.
          dTime = (t2 - t1) / 100.
          do i = 1, 100
             call addNewBlobs(grid, maxBlobs, blobs, blobTime, dTime, &
                              nCurrent, blobContrast)
             call moveBlobs(maxBlobs, blobs, 0., dTime, grid)
             write(*,*) i,nCurrent
          enddo
  
          j = 0 
          do i = 1, maxBlobs
             if (blobs(i)%inUse) j = j + 1
          enddo
  
          write(*,'(a,i3)') "Number of blobs after 5 days: ",j
  
  
          dTime = 0.
          if (nPhase /= 1) then
             dTime = (timeEnd - timeStart) / real(nPhase-1)
          endif
  
          open(50,file="files.lis",status="unknown",form="formatted")
  
          write(*,'(a)') "Running blobs and writing configuration files"
          do i = 1, nPhase
  
             grid%timeNow = timeStart + (timeEnd-timeStart)*real(i-1)/real(nPhase-1)	    
             write(specFile,'(a,i3.3,a)') trim(outfile),i,".dat"
             write(50,*) specFile(1:30), grid%timeNow
  
             call addNewBlobs(grid, maxBlobs, blobs, blobTime, dTime, nCurrent, blobContrast)
             call moveBlobs(maxBlobs, blobs, 0., dTime, grid)
             write(filename,"(a,i3.3,a)") "run",i,".blob"
             call writeBlobs(filename, maxBlobs, blobs)
  
          enddo
  
          close(50)
  
       endif
    endif


  if (plotVelocity) then
!$MPI if (my_rank==0) then
     write(*,*) ' Plotting velocity vectors...'
     call plotVelocityVectors(grid, "1.gif/GIF")
!$MPI end if
  endif




  if (nPhase /= 1) then
     dTime = (timeEnd - timeStart) / real(nPhase-1)
  endif

  if (doRaman) then
     ramanSourceVelocity = (ramVel/cSpeed)*VECTOR(0.,-1., 0.)
     write(*,'(a,f7.1,a)') "Raman source speed: ",modulus(ramanSourceVelocity)*cSpeed/1.e5, " km/s"
  endif


  !
  ! Redefining the rotation axis here.
  !
  if (geometry == "ttauri") then
     rotationAxis = grid%diskNormal
     write(*,*) "rotation axis",rotationAxis
  endif

  if (geometry == "luc_cir3d" .or. geometry == "cmfgen") then
     rotationAxis = VECTOR(0.,0.,1.)
     write(*,*) "rotation axis",rotationAxis
  endif

  if (geometry == "donati") then
     rotationAxis = rotateX(rotationAxis, -dipoleOffset)
  endif

  if (geometry == "jets") then
     rotationAxis = VECTOR(1., 0., 0.)
  end if 

  if (distortionType == "spiral") then
     rotationAxis = rotateX(rotationAxis, dipoleOffset)
  endif




  normToRotation = rotationAxis .cross. yAxis
  call normalize(normToRotation)

  tempVec  = arbitraryRotate(rotationAxis, firstInclination, normToRotation)
  originalViewVec =  (-1.)*tempVec


  if (modulus(thermalElectronVelocity(10000.)) == 0.) then
     write(*,'(a)') "THERMAL ELECTRON BROADENING IS OFF!!!!!!!!!!!!!!!!!!!!!!!!!!"
  endif


  
  if (geometry(1:6) == "ttauri" .or. geometry(1:9) == "luc_cir3d" .or. geometry == "cmfgen") then
    call emptySurface(starSurface)
  end if

!  ! default phase indecies
!  iphase_beg = nStartPhase
!  iphase_end = nEndPhase

  if (forceRotate)   rotateView = .true.
  if (forceNoRotate) rotateView = .false.
  

! From here we do multiple runs if required !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

  tiltView = .false.

  phaseLoop: do iPhase = nStartPhase, nEndPhase
          
     grid%timeNow = phaseTime * real(iPhase-1)

     call unixTimes(cpuTime, startTime)

     viewVec = originalViewVec
     outVec = (-1.)*viewVec
     thisVec = viewVec


     ! we rotate the view by an appropriate amount


     if (rotateView.and.(nPhase /= 1)) then
        write(*,'(a)') "Rotating view..."
        phi = -rotateDirection * twoPi * real(iPhase-1)/real(nPhase-1)
        viewVec =  arbitraryRotate(thisVec, phi, rotationAxis)
        outVec = (-1.) * viewVec
        write(*,'(a,f5.2,a,f5.2,a,f5.2,a)') "View vector: (",viewVec%x,",", &
             viewVec%y,",",viewVec%z,")"
     endif

     if (phaseOffset /= 0.) then
        write(*,'(a,f5.2)') "Rotating by phase offset: ",phaseOffset
        phi = twoPi * phaseOffset
        viewVec =  arbitraryRotate(viewVec, phi, rotationAxis)
        outVec = (-1.) * viewVec
     endif


     if (tiltView.and.(nPhase /= 1)) then
        phi = -twoPi * real(iPhase-1)/real(nPhase-1)
        viewVec =  arbitraryRotate(thisVec, phi, xAxis)
        outVec = (-1.) * viewVec
     endif


     ! refill the grids 
     
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!              
     if (.not.plezModelOn .and. .not. gridUsesAMR) then
        select case(geometry)
        case("torus")
!           call fillGridTorus(grid, rho, rTorus, rOuter)
        case("sphere")
           call fillGridSpheriod(grid, rho, radius, kFac)
        case("ellipse")
           call fillGridEllipse(Grid,rho,  rMin, rMaj, rInner, teff)
        case("flared")
!           call fillGridFlaredDisk(grid)
        case("disk")
!           call fillGridDisk(grid, rho, rCore, rInner, rOuter, height, mCore, diskTemp)
        case("star")
           call fillGridStar(grid, radius, mdot, vel, kfac, scale)
        case("spiral")
           call fillGridSpiral(grid, radius, mdot, vel,  scale)
        case("shell")
           call fillGridShell(grid, radius, shellFrac, rho, kfac)
        case("stateq")
           call fillGridStateq(grid, opacityDataFile, kfac, scaleDensity)
        case("bipolar")
           call fillGridBipolar(grid, rho, 30.)
        case("collide")
           call fillGridCollide(grid, rho, momRatio, binarySep, mie, meanDustParticleMass, logMassLossRate)
        case("dustblob")
           call fillGridDustBlob(grid, dustBlobdistance, rho, phiDustBlob, &
                                 xDustBlobSize, yDustBlobSize, zDustBlobSize)
        case("raman")
           call  fillGridRaman(grid, 10.*rStar, mdot, vterm, rStar, coolStarPosition, beta)
        case("binary")
!           call fillGridBinary(grid, opacityDataFile, opacityDataFile2, momRatio, mass1, mass2, period, shockwidth, shockFac)
        case("rolf")
!           call fillGridRolf(grid, mdot, vterm)
        case("wr137")
           call fillGridWR137(grid, rCore, mDot, vTerm, beta, temp1)
        case("planet")
!           call fillGridPlanet(grid)
        case("hourglass")
!           call fillGridHourglass(grid)

        !        call fillGridMagneticAccretion(grid)
        case("ttwind")
        
        case("betacep")
           !        call fillGridBetaCep(grid)
        case("donati")
!           call fillGridDonati(grid, resonanceLine)
        case("puls")
        !        call fillGridPuls(grid, mDot, rStar, tEff, v0, vterm, beta, xfac)
           case("wind")
           
        case ("ttauri")
            call fillGridMagneticAccretion(grid,contfluxfile, popFileName, &
                     readPops, writePops, lte,  lamLine, Laccretion, Taccretion, sAccretion, &
                     curtains, dipoleOffset, nLower, nUpper, theta1, theta2)
                     
!       call fillGridWind(grid, mDot, rStar, tEff, v0, vterm, beta, &
!       lte, contFluxFile, writePops, readPops, popFilename, nLower, nUpper)

        case("resonance")
!           call fillGridResonance(grid, rCore, mDot, vTerm, beta, temp)

        case("wr104")
           continue

        case("cluster")
           ! do nothing
           continue
           
        case DEFAULT
           write(*,*) "! Unrecognised grid geometry: ",trim(geometry)
           goto 666
        end select
     endif


     if (geometry(1:6) == "ttauri" .or. geometry(1:9) == "luc_cir3d" .or. geometry =="cmfgen") then      
        ! Nu must be set again here since it is not assigned when the population/grid 
        ! file is read from a file!  (RK changed here.)
        nu = cSpeed / (lamLine * angstromtocm)
        call contread(contFluxFile, nu, coreContinuumFlux)
        call buildSphere(grid%starPos1, grid%rCore, starSurface, 400, contFluxFile)
        if (geometry == "ttauri") then
           call createTTauriSurface(starSurface, grid, nu, coreContinuumFlux,fAccretion) 
        else
           call createSurface(starSurface, grid, nu, coreContinuumFlux,fAccretion) 
        end if           
        call testSurface(starSurface)

       if (grid%adaptive) then
         !call infallEnhancment(grid, distortionVec, nVec, nPhi, dTime, .true., &

         !                    infallParticleMass, alreadyDoneInfall)
          if (.not. noPhaseUpdate .and. iPhase /= nStartPhase) then
!$MPI if (my_rank == 0) then
             write(*,*) "Modifying grid for new phase"
             call amrUpdateGrid(limitScalar,limitScalar2,grid) 
             call countVoxels(grid%octreeRoot,nOctals,nVoxels)
             write(*,*) "Adaptive grid contains: ",nOctals," octals"
             write(*,*) "                      : ",nVoxels," unique voxels"
             grid%nOctals = nOctals

!$MPI    if (writePhasePops) then
!$MPI        write(tempChar,'(i3.3)') iPhase
!$MPI        phasePopFilename = trim(popFilename)//'_phase'//TRIM(tempChar)
!$MPI        call writeAMRgrid(phasePopFilename,writeFileFormatted,grid)
!$MPI        print *,'Process ',my_rank,' finished writing phase pop grid...' 
!$MPI        print *,'Process ',my_rank,' signalling grid has become available...' 
!$MPI    end if
!$MPI    call MPI_BARRIER(MPI_COMM_WORLD, ierr)  ! XXX --> sync with XXX below
!$MPI else ! my_rank /=0
!$MPI    print *,'Process ',my_rank,' waiting for grid to become available...' 
!$MPI    call MPI_BARRIER(MPI_COMM_WORLD, ierr)  ! XXX --> synch with XXX above
!$MPI    if (writePhasePops) then  ! then file should should be avialable
!$MPI       write(tempChar,'(i3.3)') iPhase
!$MPI       phasePopFilename = trim(popFilename)//'_phase'//TRIM(tempChar)
!$MPI       call readAMRgrid(phasePopFilename,readFileFormatted,grid)
!$MPI     end if
!$MPI end if
!$MPI call MPI_BARRIER(MPI_COMM_WORLD, ierr)    ! sync everybody here

             write(*,*) "Recalculating statistical equilibrium after changing grid" 
             call amrStateq(grid, newContFluxFile, lte, nLower, nUpper,  &
                   starSurface, recalcPrevious=.true.)
!$MPI         print *,'Process ',my_rank,' returned from amrStatEq. Waiting to sync...' 
!$MPI         call MPI_BARRIER(MPI_COMM_WORLD, ierr) ! wait for all processes
             if (ttau_disc_on) then
                ! amrStateq will have messed up the disc, so we reset those cells
                call finish_grid(grid%octreeroot, grid, ttauri_disc, 1.0, &
                     sigmaAbs0, sigmaSca0, meanDustParticleMass)
             end if
!$MPI if (my_rank == 0) then
             if (writePhasePops) then
                write(tempChar,'(i3.3)') iPhase
                phasePopFilename = trim(popFilename)//'_phase'//TRIM(tempChar)
                call writeAMRgrid(phasePopFilename,writeFileFormatted,grid)
             end if
!$MPI end if
!$MPI         call MPI_BARRIER(MPI_COMM_WORLD, ierr) ! wait for all processes

             
          end if ! (.not. noPhaseUpdate .and. iPhase /= nStartPhase) 

       else
         call infallEnhancment(grid, distortionVec, nVec, nPhi, dTime, .true., &
                             infallParticleMass, alreadyDoneInfall)
      end if !(adaptive)

   end if




     if (.not. gridUsesAMR) then


        if (fillTio) then
           call fillGridTio(grid, scale)
        endif
   
        if (fillRayleighOpacity) then
           call fillGridRayleigh(grid,scale)
        endif
   
        if (fillThomson) then
           call fillGridThomson(grid)
        endif
   

        select case(distortionType)
        case("spiral")
!           call distortGridSpiral(grid, vRot, nSpiral)
        case("rotation")
!           call distortRotation(grid, vRot)
!           write(*,'(a,f5.1,a)') "Grid distorted by a rotational velocity of ",vRot/1.e5," km/s"
        case("test")
           call distortGridTest(grid)
!        case("raman")
!           call distortRaman(grid)
         case("raman")
            call  distortStrom(grid, secondSourcePosition, .true., .true., 0.5*rStar, coolStarPosition, ramanDist)
        case("wrdisk")
           call distortWRdisk(grid)
   
        case("windwind")
           call distortWindCollision(grid, momRatio, binarySep)
   
        end select
   
        ! we read in the blob configuration from a file

     end if ! (.not. gridUsesAMR)

     if (nBlobs > 0) then
        write(filename,"(a,i3.3,a)") "run",iPhase,".blob"
        call readBlobs(filename, maxBlobs, blobs, .false.)
        call distortGridWithBlobs(grid, maxBlobs, blobs)
     endif

     

     if (geometry .eq. "rolf") then
        if (gridUsesAMR) then
           !      is this correct vvvvvvvvvvvvvvvvvvvvvv ?
           secondSourcePosition = grid%octreeRoot%centre
        else
           secondSourcePosition = VECTOR(grid%xAxis(grid%nx/2), &
             grid%yAxis(grid%ny/2), &
             grid%zAxis(grid%nz/2))
        end if
     endif

     ! if we are producing a movie then plot this phase


     allocate(lambda(1:maxTau))
     allocate(tauExt(1:maxTau))
     allocate(tauAbs(1:maxTau))
     allocate(tauSca(1:maxTau))
     allocate(linePhotonalbedo(1:maxTau))
     allocate(contTau(1:maxTau,1:nLambda))
     allocate(contWeightArray(1:nLambda))




!$MPI if (my_rank == 0) then
     if (movie) then
        if (device(2:3) == "xs") then
           call plotGrid(grid, viewVec,  opaqueCore, &
                device,contTau, foreground, background, coolStarPosition, firstPlot)
        endif
!
!! COMMENTED OUT FOR DEBUG
!!        write(filename,"(a,i3.3,a)") "frame",iPhase,".gif/gif"
        write(filename,"(a,i3.3,a)") "frame",iPhase,".ps/vcps"
        call plotGrid(grid, viewVec,  opaqueCore, &
             filename, contTau, foreground, background, coolStarPosition, firstPlot)
     endif
!$MPI end if

     write(*,*) " "
     write(*,'(a)') "Some basic model parameters"
     write(*,'(a)') "---------------------------"
     write(*,*) " "
       
     ! THE FOLLOWING STATEMENT IS DANGEROUS. ACCORDING TO INPUT_MOD.F90 
     ! NOT ALL THE GEOMETRY HAS RCORE VALUES, AND SAME UNITS!
     ! THIS SHOULD BE DONE IN INITAMRGRID ROUTINE AS SOME GEOMETRY HAS
     ! DONE SO.
     if (geometry /= "cmfgen") then	
        grid%rStar1 = rcore       
     end if
     !
     ! Performs various optical depth tests here...
     !
!$MPI        if (my_rank==0) &
     call test_optical_depth(gridUsesAMR, VoigtProf, &
          amrGridCentre, sphericityTest,  &
          outVec, lambdatau,  lambdatau, grid, thin_disc_on, opaqueCore, lamStart, lamEnd,  &
          thinLine, lineResAbs, nUpper, nLower, sampleFreq, useinterp, grid%Rstar1, coolStarPosition, maxTau)

!$MPI     ! Synchronizing everybody here.
!$MPI     call MPI_BARRIER(MPI_COMM_WORLD, ierr)



     weightLinePhoton = 0.
     weightContPhoton = 1.
     weightPhoto = 1.

     if (mie) then
        call computeProbDist(grid, totLineEmission, &
             totDustContinuumEmission,lamline, .false.)
        totDustContinuumEmission = totdustContinuumEmission 
        lcore = grid%lCore
        if (nSource > 0) then
           lCore = 0.
           do i = 1, nSource
              lCore = lCore + source(i)%luminosity
           enddo
        endif


        totEnvelopeEmission = totDustContinuumEmission
        chanceDust = totDustContinuumEmission/(totDustContinuumEmission+lCore/1.e30)
        write(*,*) "totdustemission",totdustcontinuumemission
        write(*,'(a,f7.2)') "Chance of continuum emission from dust: ",chanceDust

        weightDust = chanceDust / probDust
        weightPhoto = (1. - chanceDust) / (1. - probDust)

        write(*,*) "WeightDust",weightDust
        write(*,*) "WeightPhoto",weightPhoto
        write(*,*) "core + envelope luminosity",lCore+totEnvelopeEmission*1.d30
        energyPerPhoton =  ((lCore + totEnvelopeEmission*1.d30) / dble(nPhotons))/1.d20
        write(*,*) "Energy per photon: ", energyPerPhoton

     endif

     



     if (geometry == "hourglass") then
        call computeProbDist(grid, totLineEmission, &
             totWindContinuumEmission,lamline, .false.)
        weightLinePhoton = 1.
        weightContPhoton = 0.
        probLinePhoton = 1.
        probContPhoton = 0.
     endif

     if (doRaman) then
        call computeProbDist(grid, totLineEmission, &
             totWindContinuumEmission,lamline, .false.)
        write(*,*) "Total Raman Line Emission: ",totLineEmission
        weightLinePhoton = 1.
        weightContPhoton = 0.
        probLinePhoton = 1.
        probContPhoton = 0.
     endif



     if (grid%lineEmission) then

        ! integrate the line and continuum emission and read the 
        ! intrinsic profile

        if (coreEmissionLine) then
           totLineEmission = 0.
           totWindContinuumEmission = 0.
        else
           if (.not.grid%resonanceLine) then
              call computeProbDist(grid, totLineEmission, &
                   totWindContinuumEmission,lamline, useBias)

              ! convert from per steradian              
              totLineEmission = totLineEmission * fourPi
              totWindContinuumEmission = totwindContinuumEmission * fourPi
           endif
        endif


!        write(*,'(a)') "mu axis"
!        do i = 1, grid%nMu
!           write(*,*) i,acos(grid%muAxis(i))*radtodeg, &
!                             grid%muProbDistLine(grid%nr/2,i)
!        enddo
!        write(*,'(a)') "Phi axis"
!        do i = 1, grid%nPhi
!           write(*,*) i,grid%phiAxis(i)*radtodeg, grid%phiProbDistLine(grid%nr/2,grid%nmu/2,i)
!        enddo



        if (geometry == "donati") totWindContinuumEmission = 0.

        if (geometry == "binary") totWindContinuumEmission = 0.

        if (grid%resonanceLine) totWindContinuumEmission = 0.

        !if (geometry == "ttauri" .or. geometry == "windtest") then
        if (geometry == "windtest") then
           totWindContinuumEmission = 0.
           write(*,'(a)') "! Wind continuum emission switched off."
        endif

        if (lineOff) then
           totLineEmission = 0.
        endif

        nu = cSpeed / (lamLine * angstromtocm)
        write(*,'(a,e12.3)') "Line emission: ",totLineEmission
        select case(geometry)
           case("binary")
              call contread(contFluxFile, nu, totCoreContinuumEmission1)
              call contread(contFluxFile2, nu, totCoreContinuumEmission2)
           case("puls")
              totCoreContinuumEmission = pi * blackBody(0.77 * tEff, lamLine)
           case DEFAULT
              call contread(contFluxFile, nu, coreContinuumFlux)
              totCoreContinuumEmission = coreContinuumFlux
        end select


        ! reads the intrinsic core absorption profile for core-halo models
        ! Note: The profile should be normaised (to contiuum) and the x axis shoudl be in Angstrome.

        if (trim(intProFilename) /= "none") then
           call rdIntPro(intProFilename, intPro, lamIntPro, nIntPro)
           allocate(splineArray(1:nIntPro))
           call spline(lamIntPro, intPro, nIntPro, 0., 0., splineArray)
           do iSpline = 1 , nLambda
              if ((xArray(iSpline) < lamIntPro(1)) .or.  &
                   (xArray(iSpline) > lamIntPro(nIntPro))) then
                 sourceSpectrum(iSpline) = 1.
              else
                 call splint(lamIntPro, intPro, splineArray, nIntPro, &
                      xArray(iSpline), sourceSpectrum(iSpline))
              endif
           enddo
           deallocate(splineArray)
        endif

        if (geometry == "binary") then
           call rdIntPro(intProFilename2, intPro, lamIntPro, nIntPro)
           allocate(splineArray(1:nIntPro))
           call spline(lamIntPro, intPro, nIntPro, 0., 0., splineArray)
           do iSpline = 1 , nLambda
              if ((xArray(iSpline) < lamIntPro(1)) .or.  &
                   (xArray(iSpline) > lamIntPro(nIntPro))) then
                 sourceSpectrum2(iSpline) = 1.
              else
                 call splint(lamIntPro, intPro, splineArray, nIntPro, &
                      xArray(iSpline), sourceSpectrum2(iSpline))
              endif
           enddo
           deallocate(splineArray)
        endif

        ! the core can emit as a Gaussian emission line

        if (coreEmissionLine) then
           call computeCoreEmissionProfile(xArray, sourceSpectrum, nLambda, &
                lamLine, velWidthCoreEmissionLine, relIntCoreEmissionLine)
        endif


        nuStart = cSpeed / (lamStart * angstromtocm)
        nuEnd = cSpeed / (lamEnd * angstromtocm)

        totWindContinuumEmission = totWindContinuumEmission * (nuStart - nuEnd)
        write(*,'(a,e12.3)') "Wind cont emission: ",totWindContinuumEmission


! factor of four pi taken out from below - input continuum files are expected
! to be in fluxes (erg/s/cm^2/hz) not Hnu's

        if (geometry /= "binary") then
           totCoreContinuumEmission = (totCoreContinuumEmission * &
                (nuStart - nuEnd))*fourPi*grid%rCore**2
        else
           totCoreContinuumEmission1 = totCoreContinuumEmission1 * (nuStart-nuEnd) * fourPi * grid%rStar1**2
           totCoreContinuumEmission2 = totCoreContinuumEmission2 * (nuStart-nuEnd) * fourPi * grid%rStar2**2
           totCoreContinuumEmission = totCoreContinuumEmission1 + totCoreContinuumEmission2
           grid%lumRatio = totCoreContinuumEmission1 / totCoreContinuumEmission

           write(*,*) "Binary luminosity ratio (p/s): ",totCoreContinuumEmission1/totCoreContinuumEmission2
        endif
           
        if (geometry == "ttauri") then
           write (*,'(a,e12.3)') 'T Tauri star: continuum emission: ',totCoreContinuumEmission
           fAccretion = fAccretion * (nuStart-nuEnd)
           write (*,'(a,e12.3)') 'T Tauri accretion: continuum emission: ',fAccretion
           write (*,'(a,f12.3)') 'Accretion continuum / stellar continuum: ',fAccretion/totCoreContinuumEmission
           totCoreContinuumEmission = totCoreContinuumEmission + fAccretion
           write (*,'(a,e12.3)') 'T Tauri total core continuum emission: ',totCoreContinuumEmission
           ! chanceHotRing = fAccretion/totCoreContinuumEmission ! no longer used
        endif

        if (geometry == "luc_cir3d" .or. geometry == "cmfgen") then
           write (*,'(a,e12.3)') 'Star: continuum emission: ',totCoreContinuumEmission
           fAccretion = fAccretion * (nuStart-nuEnd)
           write (*,'(a,e12.3)') 'Accretion: continuum emission: ',fAccretion
           write (*,'(a,f12.3)') 'Accretion continuum / stellar continuum: ',fAccretion/totCoreContinuumEmission
           totCoreContinuumEmission = totCoreContinuumEmission + fAccretion
        endif


        
        chanceSpot = 0.
        if ((geometry == "disk").and.(nSpot > 0)) then
           chanceSpot = fSpot * blackBody(tSpot, 6562.8) / &
                ((1.-fSpot)*blackBody(tEff, 6562.8) + &
                (fSpot * blackBody(tSpot, 6562.8)))
           write(*,'(a,f5.3)') "Spot chance at 6563A: ",chanceSpot
        endif




        write(*,'(a,e12.3)') "Total Core Continuum Emission: ",totCorecontinuumEmission


        totContinuumEmission = totCoreContinuumEmission + totWindContinuumEmission

        write(*,'(a,e12.3)') "Total Continuum emission: ", totContinuumEmission


        if ((totContinuumEmission + totLineEmission) /= 0.) then
           chanceLine = totLineEmission/(totContinuumEmission + totLineEmission)
           chanceContinuum = totContinuumEmission / &
                (totContinuumEmission + totLineEmission)
           grid%chanceWindOverTotalContinuum = totWindContinuumEmission &
                / max(1.d-30,totContinuumEmission)
        else
           chanceLine =0.
           chanceContinuum = 1.
           grid%chanceWindOverTotalContinuum = 0.
        endif



        write(*,'(a,e12.3)') "Chance continuum emission in wind: ", grid%chanceWindOverTotalContinuum

        ! set up the line and continuum weights

        if ((probLinePhoton /= 0.).and.(probContphoton /= 0.)) then

           weightLinePhoton = chanceLine / probLinePhoton
           weightContPhoton = chanceContinuum / probContPhoton / real(nLambda)
        else
           if (probLinePhoton == 0.) then
              weightLinePhoton = 0.
              weightContPhoton = 1.
           else
              weightLinePhoton = 1.
              weightContPhoton = 0.
           endif
        endif


        write(*,*) "Line photon weight: ", weightLinePhoton
        write(*,*) "Continuum photon weight: ", weightContPhoton

        write(*,*) " "
        write(*,*) "Line photon prob: ", probLinePhoton
        write(*,*) "Continuum photon prob: ", probContPhoton


        energyPerPhoton =  (totLineEmission + totContinuumEmission) / dble(nPhotons)

        write(*,*) "Energy per photon: ", energyPerPhoton


        write(*,*) "chance line",chanceline


        ! compute the probability distributions


     endif

     deallocate(lambda)
     deallocate(tauSca)
     deallocate(tauExt)
     deallocate(tauAbs)
     deallocate(contTau)
     deallocate(linePhotonAlbedo)
     deallocate(contWeightArray)




     nContPhotons = nint(probContPhoton * real(nPhotons) / real(nOuterLoop))

     !
     ! here we may loop over different inclinations
     !
     
  incLoop: do iInclination = 1, nInclination, 1 
       ! NB This loop is not indented in the code!
     
     if (nInclination > 1) then  
        ! Now the inclinations are equally spaced in  cos(incination).
        ! Asuuming that firstInclination < lastInclination <= pi/2
        cos_inc_first = COS(firstInclination)
        cos_inc_last = COS(lastInclination)
        d_cos_inc = (cos_inc_first - cos_inc_last)/ REAL(nInclination-1)
        cos_inc = cos_inc_first - d_cos_inc * REAL(iInclination-1)
        inclination = max(ACOS(cos_inc),1.e-6)


!       inclination = firstInclination + REAL(iInclination-1) * &
!                       (lastInclination-firstInclination)/REAL(nInclination-1)


       write(*,*) " "
       write(*,*) "Inclination = ",inclination*radToDeg,' degrees'
       write(*,*) " "

       if (iPhase == nStartPhase .and. iInclination == 1) originalOutFile = outFile
         
       write(tempChar,'(i3.3)') NINT(inclination*radToDeg)
       outFile = trim(originalOutFile)//'_inc'//TRIM(tempChar)
       
       viewVec%x = 0.
       viewVec%y = -sin(inclination)
       viewVec%z = -cos(inclination)
       outVec = (-1.)*viewVec
       thisVec = viewVec

       if (rotateView.and.(nPhase /= 1)) then
         write(*,'(a)') "Rotating view..."
         phi = -rotateDirection * twoPi * real(iPhase-1)/real(nPhase-1)
         viewVec =  arbitraryRotate(thisVec, phi, rotationAxis)
         outVec = (-1.) * viewVec
         write(*,'(a,f5.2,a,f5.2,a,f5.2,a)') "View vector: (",viewVec%x,",", &
         viewVec%y,",",viewVec%z,")"
       endif

       if (phaseOffset /= 0.) then
         write(*,'(a,f5.2)') "Rotating by phase offset: ",phaseOffset
         phi = twoPi * phaseOffset
         viewVec =  arbitraryRotate(viewVec, phi, rotationAxis)
         outVec = (-1.) * viewVec
       endif

       if (tiltView.and.(nPhase /= 1)) then
         phi = -twoPi * real(iPhase-1)/real(nPhase-1)
         viewVec =  arbitraryRotate(thisVec, phi, xAxis)
         outVec = (-1.) * viewVec
       endif

     end if

     ! Change bias for this viewing angle
     if ( (grid%geometry == "ttauri" .or. grid%geometry == "cmfgen" ) &
          .and. (useBias .and. iInclination==1) ) then

        ! BIAS not working for iInclination /=1 case.
        ! THIS SHOULD BE FIXED LATER. MEANWHILE USING THE BIAS FOR THE FIRST INCLINATION
        ! FOR ALL INCLINATION IS NOT SO.... (RK)
        ! --using a routine in amr_mod
        write(*,*) "Setting emissin bias for ttauri geometry ..."
        if (grid%geometry == "ttauri") &
             call set_bias_ttauri(grid%octreeRoot, grid, lamline, outVec)
        if (grid%geometry == "cmfgen") &
             call set_bias_cmfgen(grid%octreeRoot, grid, lamline, outVec)
        ! recompute the cummulitive probability distribution
        call computeProbDist(grid, totLineEmission, &
             totWindContinuumEmission,lamline, useBias)
        ! convert from per steradian
        totLineEmission = totLineEmission * fourPi
        totWindContinuumEmission = totwindContinuumEmission * fourPi
        totWindContinuumEmission = totWindContinuumEmission * (nuStart - nuEnd)

        !updating same info
        totContinuumEmission = totCoreContinuumEmission + totWindContinuumEmission

        write(*,'(a,e12.3)') "Continuum emission: ", totContinuumEmission

        if ((totContinuumEmission + totLineEmission) /= 0.) then
           chanceLine = totLineEmission/(totContinuumEmission + totLineEmission)
           chanceContinuum = totContinuumEmission / &
                (totContinuumEmission + totLineEmission)
           grid%chanceWindOverTotalContinuum = totWindContinuumEmission &
                / max(1.d-30,totContinuumEmission)
        else
           chanceLine =0.
           chanceContinuum = 1.
           grid%chanceWindOverTotalContinuum = 0.
        endif
        
        write(*,'(a,e12.3)') "Chance continuum emission in wind: ", grid%chanceWindOverTotalContinuum

        ! set up the line and continuum weights
        if ((probLinePhoton /= 0.).and.(probContphoton /= 0.)) then
           weightLinePhoton = chanceLine / probLinePhoton
           weightContPhoton = chanceContinuum / probContPhoton / real(nLambda)
        else
           if (probLinePhoton == 0.) then
              weightLinePhoton = 0.
              weightContPhoton = 1.
           else
              weightLinePhoton = 1.
              weightContPhoton = 0.
           endif
        endif

        write(*,*) "Line photon weight: ", weightLinePhoton
        write(*,*) "Continuum photon weight: ", weightContPhoton
        write(*,*) " "
        write(*,*) "Line photon prob: ", probLinePhoton
        write(*,*) "Continuum photon prob: ", probContPhoton

        energyPerPhoton =  (totLineEmission + totContinuumEmission) / dble(nPhotons)

        write(*,*) "Energy per photon: ", energyPerPhoton
        write(*,*) "chance line",chanceline

     end if


          ! zero the output arrays

     yArray(1)%i = 0.
     yArray(1)%q = 0.
     yArray(1)%u = 0.
     yArray(1)%v = 0.
     do i = 2, nLambda
        yArray(i)%i = 0.
        yArray(i)%q = 0.
        yArray(i)%u = 0.
        yArray(i)%v = 0.
     enddo

     if (doRaman) then
        yArray(1:nLambda)%i = 1.e-20
     endif
     
     if (stokesimage) then
        
        ! bulid a filter to be used for imaging
        ! -- using a routine in filter_set_class
        call make_filter_set(filters, filter_set_name)

        ! write filter info to standard output and to a file
!$MPI     if (my_rank==0) then
        call info_filter_set(filters, "*") 
        call info_filter_set(filters, "info_filter_set.dat")
!$MPI     endif 

        ! number of images = number of filters
        nImage = get_nfilter(filters)

        ! Allocate the image array
        if (allocated(obsImageSet)) deallocate(obsImageSet)
        allocate(obsImageSet(nImage))
        

        ! Initializing the images ...

        if (setImageSize == 0.) then
           if (grid%adaptive) then
              if (amr2d) then
                 imageSize = 2.*grid%octreeRoot%subcellSize
              else
                 imageSize = grid%octreeRoot%subcellSize          
              endif
           else if (grid%cartesian) then
              imageSize = grid%xAxis(grid%nx)-grid%xAxis(1)
           else
              imagesize = 2.*grid%rAxis(grid%nr)
           endif
        else
           imageSize = setImageSize / 1.e10
        endif


        ! Initializing the images ...
        do i = 1, nImage           
           if (grid%cartesian) then
              obsImageSet(i) = initImage(npix, imageSize, vmin, vmax)
              if (doRaman) then
                 o6image(1) = initImage(npix, imageSize, vmin, vmax)
              endif
           else if (grid%adaptive) then
              obsImageSet(i) = initImage(npix, imageSize, vmin, vmax)
           else   
              select case (geometry)
              case("disk")
                 obsImageSet(i) = initImage(npix, grid%rAxis(grid%nr), vMin, vMax)
              case("flared")
                 obsImageSet(i) = initImage(npix, 4.*grid%rAxis(1), vMin, vMax)
              case DEFAULT
                 obsImageSet(i) = initImage(npix, min(5.*grid%rAxis(1),grid%rAxis(grid%nr)), vMin, vMax)
              end select
           endif
        end do
        
     endif


     if (dopvImage) then

        if (nSlit  > 1) then
           rHat = slitPosition2 - slitPosition1
           do iSlit = 1, nSlit
              slitPosition = slitPosition1 + (real(iSlit-1)/real(nSlit-1))*(slitPosition2 - slitPosition1)
              pvImage(iSlit) = initPVimage(nv, vMin, vMax, np, -slitLength/2., slitLength/2., &
                   slitPosition, slitPA, slitWidth, slitLength)
           enddo
        else
           slitPosition = slitPosition1
           pvImage(1) = initPVimage(200, vMin, vMax, 200, -slitLength/2., slitLength/2., &
                slitPosition, slitPA, slitWidth, slitLength)
        endif
           
     endif

     write(*,*) " "
     write(*,'(a)') "Run-time messages"
     write(*,'(a)') "-----------------"
     write(*,*) " "
     

     tot%i = 0.
     tot%q = 0.
     tot%u = 0.
     tot%v = 0.


     k = nPhotons/10

     ntot = 0

     ! now we loop 10 times over a tenth of the photons - this will be used
     ! to help compute the errors

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

     call unixTimes(cpuTime, startTime)


     if (grid%geometry == "donati") then
        junk1 = 0.
        rHat = VECTOR(0.,0.,0.)
        n = 0
        do i = 1, 100000
           call initPhoton(thisPhoton, grid, nLambda, xArray, sourceSpectrum, &
                lineEmission, lamLine, weightLinePhoton, &
                weightContPhoton, contPhoton, flatspec, vRot, pencilBeam, &
                secondSource, secondSourcePosition,  &
                ramanSourceVelocity, vo6, contWindPhoton, directionalWeight, useBias, theta1, theta2, &
                chanceHotRing, &
                nSpot, chanceSpot, thetaSpot, phiSpot, fSpot, spotPhoton, probDust, weightDust, weightPhoto,&
                narrowBandImage, vmin, vmax, source, nSource, rHatinStar, energyPerPhoton, filters, mie, &
                curtains, starSurface, forcedWavelength, usePhotonWavelength, VoigtProf)
           if (thisPhoton%linePhoton) then
              junk1 = junk1 + thisPhoton%position%z
              rHat = rHat + thisPhoton%velocity
              n = n + 1
           endif
           if (.not. gridUsesAMR) call getIndices(grid, thisPhoton%position, i1, i2, i3, t1, t2, t3)
        enddo
        write(*,*) "Average z position",junk1/real(n)
        write(*,*) "Average velocity",((cSpeed/1.e5)*(1./real(n)))*o2s(rHat)
     endif


!$MPI  if (my_rank==1) &
     call tune(6, "All Photon Loops")  ! Start a stopwatch
     
     outerPhotonLoop: do iOuterLoop = 1, nOuterLoop

!$OMP PARALLEL DEFAULT(NONE) &
!$OMP PRIVATE(i, contPhoton, contWindPhoton, r, nScat) &
!$OMP PRIVATE(thisPhoton, directionalWeight) &
!$OMP PRIVATE( ilambda, sourceSpectrum, ok) &
!$OMP PRIVATE(hitCore, junk, thisLam, j, obs_weight, thisVel) &
!$OMP PRIVATE(i1, i2, i3, t1, t2, t3, vray, vovercsqr, fac, observedLambda) &
!$OMP PRIVATE(t, rHat, islit, fac1, fac2, fac3, obsPhoton, r1, r2, thisTau) &
!$OMP PRIVATE(escaped, currentScat, absorbed, dlambda, thisChi, thisSca) &
!$OMP PRIVATE(albedo, tempPhoton, redRegion, thrustar, ramanWeight) &
!$OMP PRIVATE(outPhoton,intPathError) &
!$OMP PRIVATE(nTau, escProb, spotPhoton) &
!$OMP PRIVATE(lambda, tauExt, tauSca, tauAbs, contTau, contWeightArray) &
!$OMP PRIVATE(rHatinStar, positionOc, linePhotonalbedo) &

!$OMP SHARED(grid) &

!$OMP SHARED(meanr_Cont, wtot_cont,meanr_line,wtot_line, ntot) &
!$OMP SHARED(nContPhotons, nPhotons, lineEmission, lamLine, nLambda) &
!$OMP SHARED(weightLinePhoton, flatSpec, vRot, secondSource, secondSourcePosition) &
!$OMP SHARED(ramanSourceVelocity, vO6, doRaman) &
!$OMP SHARED(weightContPhoton, useBias, pencilBeam ,outVec)&
!$OMP SHARED(opaqueCore, lamStart, lamEnd, thinLine, rStar, coolStarPosition) &
!$OMP SHARED(viewVec, o6xArray,o6yArray, rotationAxis, o6image, screened) &
!$OMP SHARED(xArray, yArray, statArray, stokesImage, obsImageSet, doPvimage) &
!$OMP SHARED(nSlit, pvimage, gridDistance, meanr0_line, wtot0_line) &
!$OMP SHARED(sourceSpectrum2, meanr0_cont,wtot0_cont, maxScat, mie) &
!$OMP SHARED(miePhase, zeroVec, theta1, theta2, chanceHotRing) &
!$OMP SHARED(nSpot, chanceSpot, thetaSpot, phiSpot, fSpot, chanceDust) &
!$OMP SHARED(narrowBandImage, vMin, vMax, gridUsesAMR) &
!$OMP SHARED(sampleFreq, useInterp, photLine,tooFewSamples,boundaryProbs) &
!$OMP SHARED(probDust, WeightDust, WeightPhoto, source, nsource) &
!$OMP SHARED(energyPerPhoton, filters, nUpper, nLower, nImage) &
!$OMP SHARED(negativeOpacity, iInner_beg, iInner_end) &
!$OMP SHARED(curtains, starSurface, VogitProf)



!$MPI  if (my_rank==1) &
        call tune(6, "One Outer Photon Loop") ! Start a stop watch

        ! default inner loop indices
        iInner_beg = 1
        iInner_end = nPhotons/nOuterLoop

!$MPI  !====================================================================================
!$MPI  ! Splitting the innerPhoton loop for multiple processors.
!$MPI  if (my_rank == 0) then
!$MPI     print *, ' '
!$MPI     print *, 'innerPhotonLoop computed by ', n_proc-1, ' processors.'
!$MPI     print *, ' '
!$MPI  endif
!$MPI  ! No need to use some processors if there are more processors
!$MPI  ! than the number of photons....
!$MPI  if (my_rank > nPhotons/nOuterLoop - 1)  goto 666
!$MPI    
!$MPI  if (my_rank == 0) then
!$MPI     ! we will use an array to store the rank of the process
!$MPI     !   which will calculate each photon
!$MPI     allocate(photonBelongsRank(nPhotons/nOuterLoop))
!$MPI    
!$MPI     call mpiBlockHandout(n_proc,photonBelongsRank,blockDivFactor=40,tag=tag,&
!$MPI                          setDebug=.false.)
!$MPI     deallocate(photonBelongsRank) ! we don't really need this here. 
!$MPI  end if
!$MPI  !====================================================================================

!$MPI    
!$MPI    
!$MPI  if (my_rank /= 0) then
!$MPI    mpiBlockLoop: do  
!$MPI      call mpiGetBlock(my_rank,iInner_beg, iInner_end,rankComplete,tag,setDebug=.false.)  
!$MPI      if (rankComplete) exit mpiBlockLoop  
!$MPI    

!$OMP DO SCHEDULE(DYNAMIC)
        innerPhotonLoop: do i = iInner_beg, iInner_end
!$MPI !  if (MOD(i,n_proc) /= my_rank) cycle innerPhotonLoop
           ! The following six arrays must be allocated and deallocated for each 
           ! innerPhotonLoop to make the program work with OpenMP! (RK)
           allocate(lambda(1:maxTau))
           allocate(tauExt(1:maxTau))
           allocate(tauAbs(1:maxTau))
           allocate(tauSca(1:maxTau))
           allocate(linePhotonalbedo(1:maxTau))
           allocate(contTau(1:maxTau,1:nLambda)) 
           allocate(contWeightArray(1:nLambda))
!$MPI !  if (MOD(i,n_proc) /= my_rank) goto 999


           ! continuum or line photon?

           if (i <= nContPhotons) then
              contPhoton = .true.
           else
              contPhoton = .false.
           endif
           contWindPhoton = .false.

           ! there is a chance that this continuum photon is produced in the wind rather
           ! than at the core...

           if (lineEmission .and. contPhoton) then
              call random_number(r)
              if (r < grid%chanceWindOverTotalContinuum) then
                 contWindPhoton = .true.
              endif
           endif

           nScat = 0

           ! initialize the photon
           
           contWeightArray = 1.

           select case(grid%geometry)
              case("planet")
                 call initPlanetPhoton(thisPhoton, grid, lamLine)
                 directionalWeight = 1.
                 contWindPhoton = .true.
              case DEFAULT
                 call initPhoton(thisPhoton, grid, nLambda, xArray, sourceSpectrum, &
                      lineEmission, lamLine, weightLinePhoton, &
                      weightContPhoton, contPhoton, flatspec, vRot, pencilBeam, &
                      secondSource, secondSourcePosition, &
                      ramanSourceVelocity, vo6, contWindPhoton, directionalWeight, useBias, &
                      theta1, theta2, chanceHotRing,  &
                      nSpot, chanceSpot, thetaSpot, phiSpot, fSpot, spotPhoton,  probDust, weightDust, weightPhoto,&
                      narrowBandImage, vMin, vMax, source, nSource, rHatinStar, energyPerPhoton, filters, mie,&
                      curtains, starSurface, forcedWavelength, usePhotonWavelength, VoigtProf)
                 if (thisPhoton%resonanceLine) then
                    r1 = real(i)/real(nPhotons/nOuterLoop)
                    thisPhoton%lambda = xArray(1) + r1*(xArray(nLambda)-xArray(1))
                 endif

           end select

!           write(*,*) "after init",thisPhoton%stokes%i,contwindphoton
           observedLambda = thisPhoton%lambda
           if (thisPhoton%contPhoton) then

              meanr_cont = meanr_cont + modulus(thisPhoton%position)*thisPhoton%stokes%i
              wtot_cont = wtot_cont + thisPhoton%stokes%i
           else
              meanr_line = meanr_line + modulus(thisPhoton%position)*thisPhoton%stokes%i
              wtot_line = wtot_line + thisPhoton%stokes%i
           endif



           iLambda = findIlambda(thisPhoton%lambda, xArray, nLambda, ok)

           ! now we fire the photon direct to the observer
           lineResAbs = .false.  ! F for the zero-th scattering.
           if (doRaman) then
              
              call integratePath(gridUsesAMR, VoigtProf, &
                         thisPhoton%lambda, lamLine, &
                         s2o(thisPhoton%velocity), &
                         thisPhoton%position, s2o(outVec), grid, &
                         lambda, tauExt, tauAbs, tauSca, linePhotonAlbedo, maxTau , nTau, thin_disc_on, opaqueCore, &
                         escProb, thisPhoton%contPhoton, lamStart, lamEnd, &
                         nLambda, contTau, hitCore, thinLine, lineResAbs, .false., &
                         .false., nUpper, nLower, 0., 0., 0., junk,&
                         sampleFreq,intPathError, &
                         useInterp, grid%Rstar1, coolStarPosition)
              if (intPathError == -10) then ; tooFewSamples = tooFewSamples + 1  
                 goto 999 ; endif
              if (intPathError == -20) then ; boundaryProbs = boundaryProbs + 1
                 goto 999 ; endif
              if (intPathError == -70) then ; negativeOpacity = negativeOpacity + 1 
                 goto 999 ; endif

              thisLam = thisPhoton%lambda + (thisPhoton%velocity .dot. viewVec) * 1031.928
              j = findIlambda(thisLam, o6xArray, no6pts, ok)
              if (ok) then
                 obs_weight = oneOnFourPi * exp(-tauExt(nTau))
                 o6yArray(j) = o6yArray(j) + obs_weight
                 thisVel = (thisLam-lamLine)/lamLine

                 call addPhotonToImage(viewVec, rotationAxis,o6Image(1), 1, &
                      thisPhoton, thisVel, obs_weight, filters, grid%octreeRoot%centre)
              endif
           endif

           if (.not. screened) then


              ! find optical depths to observer
              call integratePath(gridUsesAMR, VoigtProf, &
                         thisPhoton%lambda, lamLine, &
                         s2o(thisPhoton%velocity), &
                         thisPhoton%position, s2o(outVec), grid, &
                         lambda, tauExt, tauAbs, tauSca, linePhotonAlbedo, maxTau, nTau, thin_disc_on, opaqueCore, &
                         escProb, thisPhoton%contPhoton, lamStart, lamEnd, &
                         nLambda, contTau, hitCore, thinLine, lineResAbs, .false.,&
                         .false., nUpper, nLower, 0., 0., 0., junk,&
                         sampleFreq,intPathError, &
                         useInterp, grid%Rstar1, coolStarPosition)

               if (intPathError == -10) then
                    tooFewSamples = tooFewSamples + 1  
                    goto 999
               endif
               if (intPathError == -20) then
                    boundaryProbs = boundaryProbs + 1
                    goto 999
               endif
               if (intPathError == -70) then ; negativeOpacity = negativeOpacity + 1
                  goto 999; endif

              if (.not. gridUsesAMR) call getIndices(grid,thisPhoton%position,i1,i2,i3,t1,t2,t3)


              if (thisPhoton%resonanceLine) escProb = 1.

              if (thisPhoton%linePhoton) then
                 vray = -(thisPhoton%velocity .dot. outVec)
                 vovercsqr = modulus(thisPhoton%velocity)**2
                 fac = (1.d0-0.5d0*vovercsqr*(1.d0-0.5d0*vovercsqr))/(1.d0+vray)
                 observedlambda = thisPhoton%lambda / fac
                 obs_weight = oneOnFourPi * exp(-tauExt(nTau)) * escProb
              endif

              if (thisPhoton%contPhoton.and.(.not.contWindPhoton)) then
                 t = modulus(thisPhoton%position)
                 if (t /= 0.) then
                    rHat = thisPhoton%position / t
                 else
                    rHat = thisPhoton%direction
                 endif
                 t = rHat .dot. outVec

!                 if (t < 0.0) then 
                    ! The photon directs inward of the star...
                    ! this should be taken care by integratepth routine
                    ! by producing a large tau but just in case this was not taken care.
                    ! -- (RK)
!                    obs_weight = 1.0e-30
!                 else
                    if (lineEmission) then
                       obs_weight = abs(t)*exp(-tauExt(nTau)) / pi
                    else
                       obs_weight = oneOnFourPi*abs(t)*exp(-tauExt(nTau))
                    endif
!                 end if
                 observedlambda = thisPhoton%lambda
              endif

              if (.not.flatSpec.and.(.not.hitCore)) then
                 if (contWindPhoton) then
                    obs_weight = oneOnFourPi*exp(-tauExt(nTau))
                 else 
                    obs_weight = (outVec.dot.rHatinStar)*exp(-tauExt(nTau))/pi
                    if (obs_weight < 0.) obs_weight = 0.
                 endif
                 
                 iLambda = findIlambda(observedlambda, xArray,  nLambda, ok)
                 if (ok) then

!                    write(*,*) "addingPhoton",thisPhoton%stokes%i,obs_weight
                    yArray(iLambda) = yArray(iLambda) + &
                         (thisPhoton%stokes * obs_weight)
                    statArray(iLambda) = statArray(iLambda) + 1.
                 endif
                 if (stokesImage) then
                    thisVel = observedLambda
                    call addPhotonToImage(viewVec, rotationAxis, obsImageSet, nImage, thisPhoton,&
                         thisVel, obs_weight, filters, grid%octreeRoot%centre)

                 endif
                 if (doPVimage) then
                    do iSlit = 1, nSlit
                       call addPhotontoPVimage(pvImage(iSlit), thisPhoton, viewVec, rotationAxis, thisVel, &
                                 obs_weight, gridDistance)
                    enddo
                 endif
              endif
              
              if (flatSpec.and.(.not.hitCore)) then
                 if (thisPhoton%linePhoton) then
                    fac2 = 1.
!                    if (thisPHoton%resonanceline) fac2 = directionalWeight
                    iLambda = findIlambda(observedlambda, xArray, nLambda, ok)
                    if (ok) then
                       yArray(iLambda) = yArray(iLambda) + &
                            (thisPhoton%stokes * (fac2 * oneOnFourPi * escProb * exp(-tauExt(nTau))))
                       statArray(iLambda) = statArray(iLambda) + 1.
                    endif

                    obs_weight = oneOnFourPi * escProb * exp(-tauExt(nTau))*fac2

                    meanr0_line = meanr0_line + modulus(thisPhoton%position) * &
                         (thisPhoton%stokes%i * obs_weight)
                    wtot0_line = wtot0_line + (thisPhoton%stokes%i * obs_weight)
                    

                    thisVel = (observedLambda-lamLine)/lamLine
                    if (stokesImage) then
                       call addPhotonToImage(viewVec, rotationAxis, obsImageSet, nImage, &
                            thisPhoton, thisVel, obs_weight, filters, grid%octreeRoot%centre)
                    endif
                    if (dopvImage) then
                       do iSlit = 1, nSlit
                          call addPhotontoPVimage(pvImage(iSlit), thisPhoton, viewVec,  rotationAxis,thisVel, &
                            obs_weight, gridDistance)
                       enddo
                    endif

                 else
                    fac1 = 1.
                    if (.not.contWindPhoton) then
                       fac1 = 2.*abs(thisPhoton%originalNormal.dot.outVec)/twoPi
                    else
                       fac1 = oneOnfourPi
                    endif
                    
                    vray = -(thisPhoton%velocity .dot. outVec)
                    vovercsqr = modulus(thisPhoton%velocity)**2
                    fac = (1.d0-0.5d0*vovercsqr*(1.d0-0.5d0*vovercsqr))/(1.d0+vray)
                    observedlambda = thisPhoton%lambda / fac
                    
                    i1 = 0
                    do iLambda = 1, nLambda
!if (VoigtProf) then
!                       thisLam = (lamLine-thisPhoton%lambda) + xArray(iLambda)
!else
                       thisLam = (lamLine-observedlambda) + xArray(iLambda)
!end if

                       call hunt(xArray,nLambda,thisLam,i1)
                       if (i1 ==0 ) i1 = 1
                       if (grid%geometry /= "binary") then
                          fac2 = sourceSpectrum(i1)

                          if ((grid%geometry == "disk").and.(.not.spotPhoton).and.(.not.photLine)) fac2 = 1.


                       else
                          if (thisPhoton%fromStar1) then
                             fac2 = sourceSpectrum(i1)
                          else
                             fac2 = sourceSpectrum2(i1)
                          endif
                       endif
                       fac3 = contTau(nTau,i1)
                       if (thinLine) fac3 = 0.
                       obs_weight = (fac1 * exp(-(tauExt(ntau)+fac3)))*fac2
                       yArray(iLambda) = yArray(iLambda) + &
                                           (thisPhoton%stokes * obs_weight)
                       statArray(iLambda) = statArray(iLambda) + 1.

                       meanr0_cont = meanr0_cont + modulus(thisPhoton%position) &
                            * thisPhoton%stokes%i*obs_weight
                       wtot0_cont = wtot0_cont + thisPhoton%stokes%i*obs_weight
                       thisVel = (observedLambda-lamLine)/lamLine
                       if (stokesImage) then
                          call addPhotonToImage(viewVec,  rotationAxis,obsImageSet, nImage, &
                               thisPhoton, thisVel, obs_weight, filters, grid%octreeRoot%centre, &
                               xArray(iLambda))
                       endif
                       if (dopvImage) then
                          do iSlit = 1, nSlit
                             call addPhotontoPVimage(pvImage(islit), obsPhoton, viewVec,  rotationAxis, thisVel, &
                               obs_weight, gridDistance)
                          enddo
                       endif

                    enddo
                 endif
              endif

           endif

           call integratePath(gridUsesAMR, VoigtProf, &
              thisPhoton%lambda, lamLine, &
              s2o(thisPhoton%velocity), &
              thisPhoton%position, &
              thisPhoton%direction, grid, &
              lambda, tauExt, tauAbs, tauSca, linePhotonAlbedo, maxTau, nTau, thin_disc_on, opaqueCore, &
              escProb, thisPhoton%contPhoton, lamStart, lamEnd, &
              nLambda, contTau, hitCore, thinLine, lineResAbs, .false.,  &
              .false., nUpper, nLower, 0., 0., 0., &
              junk,sampleFreq,intPathError, &
              useInterp, grid%Rstar1, coolStarPosition)

              if (intPathError == -10) then ; tooFewSamples = tooFewSamples + 1  
                 goto 999 ; endif
              if (intPathError == -20) then ; boundaryProbs = boundaryProbs + 1
                 goto 999 ; endif
              if (intPathError == -70) then ; negativeOpacity = negativeOpacity + 1
                 goto 999 ; endif

!           tau_bnd = tauExt(nTau) ! Optical depth to outer boundary.
!           fac=1.0d0-exp(-tau_bnd)
!           call random_number(r1)
!           thisTau = min(-log(1.d0-r1*fac),tau_bnd)  
!           escaped = .false.!
           ! This is done so to force the first scattering if 
           ! MAXSCAT>0. 

           ! DON'T FORCE THE FIRST SCATTERING
            
           
           call random_number(r1)
           fac = 1.
           thistau = -log(max(1.e-10,(1. - r1)))
           if (thistau .gt. tauExt(nTau)) then
              escaped = .true.  
           else
              escaped = .false.  
           endif


           if (thisPhoton%contPhoton) escProb = 1.

           if (thisPhoton%resonanceLine) escProb = 1.
              
           ! Correcting the weight here... 
           ! escProb -- allowing for local emission
           thisPhoton%stokes = thisPhoton%stokes * real(fac) * escProb


           currentScat = 0


!           escaped = .false.
           absorbed = .false.
           if (doRaman) hitCore = .false.


           ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!1
           ! scattering loop !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
           ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!1
           lineResAbs = .true.
           do while (.not.escaped .and. .not.absorbed .and. &
                     (nScat < maxScat)   )
              ! Now we do not force the scattering exept for the first scattering.
              ! maxScat specifies the max number of scattering ALLOWED, but 
              ! not the number of scattering FORCED!
              

              nScat = nScat + 1

              currentScat = currentScat  + 1

              ! find position of next interaction

              call locate(tauExt, nTau, thisTau, j)


              if (j < nTau) then
                 t = 0.
                 if ((tauExt(j+1) - tauExt(j)) /= 0.) then
                    t = (thisTau - tauExt(j)) / (tauExt(j+1) - tauExt(j))
                 endif
                 dlambda = lambda(j) + (lambda(j+1)-lambda(j))*t
              else
                 dlambda = lambda(nTau)
              endif
                    
              ! New photon position 
              thisPhoton%position = thisPhoton%position + real(dlambda,kind=oct)*thisPhoton%direction
              ! adjusting the photon weights 
              if (.not. thisPhoton%linePhoton) then
                 if (j < nTau) then
                    contWeightArray(1:nLambda) = contWeightArray(1:nLambda) *  &
                         EXP(-(contTau(j,1:nLambda) + t*(contTau(j+1,1:nLambda)-contTau(j,1:nLambda))) )
                 else
                    contWeightArray(1:nLambda) = contWeightArray(1:nLambda)*EXP(-(contTau(nTau,1:nLambda)))
                 end if
              end if


              if (flatspec) then
                 iLambda = 1
              else
                 iLambda = findIlambda(thisPhoton%lambda, xArray, nLambda, ok)
              endif

              if (grid%adaptive) then
                 positionOc = thisPhoton%position
                 call amrGridValues(grid%octreeRoot, positionOc, grid=grid, iLambda=iLambda, &
                      kappaAbs = thisChi, kappaSca = thisSca)
              else
                 call getIndices(grid, thisPhoton%position, i1, i2, i3, t1, t2, t3)
                 if (.not.grid%oneKappa) then
                    if (.not.flatspec) then
                       thisChi = interpGridKappaAbs(grid, i1, i2, i3, iLambda, real(t1), real(t2), real(t3))
                       thisSca = interpGridKappaSca(grid, i1, i2, i3, iLambda, real(t1), real(t2), real(t3))
                    else
                       thisChi = interpGridKappaAbs(grid, i1, i2, i3, 1,  real(t1), real(t2), real(t3))
                       thisSca = interpGridKappaSca(grid, i1, i2, i3, 1,  real(t1), real(t2), real(t3))
                    endif
                 else
                    r = interpGridScalar2(grid%rho,grid%na1,grid%na2,grid%na3,i1,i2,i3,real(t1),real(t2),real(t3))
                    thisChi = grid%oneKappaAbs(1,iLambda) * r
                    thisSca = grid%oneKappaSca(1,iLambda) * r
                 endif
              end if
              
              if (contPhoton) then
                 if ((thisChi+thisSca) >= 0.) then
                    albedo = thisSca / (thisChi + thisSca)
                 else
                    albedo = 0.
                    write(*,*) "Error:: thisChi+thisSca < 0 in torusMain."
                    !                 stop
                 endif
              else
                 albedo = linePhotonAlbedo(j)
              endif

              if (grid%resonanceLine) albedo = 1.

              if (hitCore) then
                 if (grid%geometry /= "binary") then
                    r = modulus(thisPhoton%position)/grid%rCore
                    if (r < 1.01) then
                       absorbed = .true.
                       albedo = 0.
                    endif
                 else
                    r1 = modulus(o2s(thisPhoton%position) - grid%starpos1)/grid%rStar1
                    r2 = modulus(o2s(thisPhoton%position) - grid%starpos2)/grid%rStar2
                    r = min (r1, r2)
                    if (r < 1.01) then
                       albedo = 0.5
                    endif
                 endif
              endif
                 

              thisPhoton%stokes = thisPhoton%stokes * albedo  ! weight adjusted here!!!

              if (thisPhoton%stokes%i < reallySmall) then
                 absorbed = .true.
!                 write(*,*) "! Small photon weight",thisPhoton%stokes%i
              endif


              ! towards observer

              if (.not.absorbed) then

                 tempPhoton = thisPhoton
                 

                 call scatterPhoton(grid, tempPhoton, outVec, obsPhoton, mie, &
                       miePhase, nLambda, nMuMie, ttau_disc_on, ttauri_disc)


                 ! the o6 photon might get scattered towards the observer by a rayleigh scattering

                 if (doRaman) then
                    call integratePath(gridUsesAMR, VoigtProf, &
                            obsPhoton%lambda, lamLine, s2o(obsPhoton%velocity), &
                            obsPhoton%position, obsPhoton%direction, grid, &
                            lambda, tauExt, tauAbs, tauSca, linePhotonAlbedo, maxTau, nTau,  thin_disc_on, opaqueCore, &
                            escProb, obsPhoton%contPhoton, lamStart, lamEnd, nLambda, contTau, hitCore, &
                            thinLine, lineResAbs, .false., .false., nUpper, nLower, 0., 0., 0.,&
                            junk, sampleFreq,intPathError, &
                            useinterp, grid%Rstar1, coolStarPosition)

                   if (intPathError == -10) then ; tooFewSamples = tooFewSamples + 1  
                      goto 999 ; endif
                   if (intPathError == -20) then ; boundaryProbs = boundaryProbs + 1
                      goto 999 ; endif
                   if (intPathError == -70) then ; negativeOpacity = negativeOpacity + 1
                      goto 999 ; endif

                    vray = -(obsPhoton%velocity .dot. outVec)
                    vovercsqr = modulus(thisPhoton%velocity)**2
                    fac = (1.d0-0.5d0*vovercsqr*(1.d0-0.5d0*vovercsqr))/(1.d0+vray)
                    observedlambda = obsPhoton%lambda / fac
                    
                    obs_weight = oneOnFourPi*exp(-tauExt(nTau)) * 34./(6.6+34.)

                    j = findIlambda(observedLambda, o6xArray, no6pts, ok)
                    if (ok) then
                       o6yArray(j) = o6yArray(j) + obs_weight
                    endif

                 endif  ! raman




                 redRegion = .false.

                 if (doRaman) redRegion = .true.

                 call integratePath(gridUsesAMR, VoigtProf, &
                      obsPhoton%lambda, lamLine, &
                      s2o(obsPhoton%velocity), &
                      obsPhoton%position, obsPhoton%direction, grid, &
                      lambda, tauExt, tauAbs, tauSca, linePhotonAlbedo, maxTau, nTau,  thin_disc_on, opaqueCore, &
                      escProb, obsPhoton%contPhoton, lamStart, lamEnd, &
                      nLambda, contTau, hitCore, &
                      thinLine, lineResAbs, redRegion, &
                      .false., nUpper, nLower, 0., 0.,0.,junk,sampleFreq,intPathError, &
                      useInterp, grid%Rstar1, coolStarPosition)                 

                 if (intPathError == -10) then ; tooFewSamples = tooFewSamples + 1  
                    goto 999 ; endif
                 if (intPathError == -20) then ; boundaryProbs = boundaryProbs + 1
                    goto 999 ; endif
                 if (intPathError == -70) then ; negativeOpacity = negativeOpacity + 1
                    goto 999 ; endif


                 if (obsPhoton%linePhoton) then

                    
                    vray = -(obsPhoton%velocity .dot. outVec)
                    vovercsqr = modulus(obsPhoton%velocity)**2
                    fac = (1.d0-0.5d0*vovercsqr*(1.d0-0.5d0*vovercsqr))/(1.d0+vray)
                    if (.not.doRaman) then
                       observedlambda = obsPhoton%lambda / fac
                    else
                       observedlambda = obsPhoton%redlambda / fac
                    endif


                 else
                    observedLambda = obsPhoton%lambda
                 endif

                 thruStar = .false.

                 if (.not.flatSpec.and.(.not.hitCore).and.(.not.thruStar)) then

                    ramanWeight = 1.
                    if (doRaman) ramanWeight = 6.6 / (34.+6.6)

                    obs_weight = oneOnFourPi*exp(-tauExt(nTau)) * ramanWeight

                    iLambda = findIlambda(observedlambda, xArray, nLambda, ok)
                      

                    if (ok) then
                       yArray(iLambda) = yArray(iLambda) + obsPhoton%stokes*obs_weight

                       statArray(iLambda) = statArray(iLambda) + 1.
                    endif
                    if (doRaman) then
                       thisVel = (1./(1./observedLambda  + 1./1215.67))/1031.928-1.
                    else
                       thisVel = observedLambda
                    endif



                    if (stokesImage) then
                       call addPhotonToImage(viewVec,  rotationAxis, obsImageSet, nImage,  &
                            obsPhoton, thisVel, obs_weight, filters, grid%octreeRoot%centre)
                    endif
                    if (dopvImage) then
                       do iSlit = 1, nSlit
                          call addPhotontoPVimage(pvImage(iSlit), obsPhoton, viewVec,  rotationAxis,thisVel, &
                            obs_weight, gridDistance)
                       enddo
                    endif

                    if (doRaman) then
                       thisPhoton%stokes = thisPhoton%stokes*(1.-ramanWeight)
                    endif
                 endif



                 if (flatSpec.and.(.not.hitCore)) then



                    if (obsPhoton%linePhoton) then
                       iLambda = findIlambda(observedlambda, xArray, nLambda, ok)
                       obs_weight = oneOnFourPi*exp(-tauExt(nTau))


                       if (obsPhoton%resonanceLine) obs_weight = obs_weight * directionalWeight

                       if (ok) then
                          yArray(iLambda) = yArray(iLambda) + obsPhoton%stokes*obs_weight
                          statArray(iLambda) = statArray(iLambda) + 1.
                       endif

                       thisVel = observedLambda
                       thisVel = (observedLambda-lamLine)/lamLine
                       if (stokesImage) then
                          call addPhotonToImage(viewVec,  rotationAxis, obsImageSet, nImage, &
                               obsPhoton, thisVel, obs_weight, filters, grid%octreeRoot%centre)
                       endif
                       if (dopvImage) then
                          do iSlit = 1 , nSlit
                             call addPhotontoPVimage(pvImage(iSlit), obsPhoton, viewVec,  rotationAxis, thisVel, &
                               obs_weight, gridDistance)
                          enddo
                       endif


                    else


                       vray = -(obsPhoton%velocity .dot. outVec)
                       vovercsqr = modulus(obsPhoton%velocity)**2
                       fac = (1.d0-0.5d0*vovercsqr*(1.d0-0.5d0*vovercsqr))/(1.d0+vray)
                       observedlambda = obsPhoton%lambda / fac

                       do iLambda = 1,nLambda
!if (VoigtProf) then
!                       thisLam = (lamLine-obsPhoton%lambda) + xArray(iLambda)
!else
                       thisLam = (lamLine-observedlambda) + xArray(iLambda)
!end if


                          i1 = findILambda(thisLam, xArray, nLambda, ok)
                          if (grid%geometry /= "binary") then
                             fac2 = sourceSpectrum(i1)
                             if ((grid%geometry == "disk").and.(.not.spotPhoton).and.(.not.photLine)) fac2 = 1.
                          else
                             if (obsPhoton%fromStar1) then
                                fac2 = sourceSpectrum(i1)
                             else
                                fac2 = sourceSpectrum2(i1)
                             endif
                          endif

                          fac3 = contTau(nTau, i1)



                          if (thinLine) fac3 = 0.


                          obs_weight = exp(-(tauExt(nTau)+fac3)) * oneOnFourpi & 
                          * fac2 * directionalWeight * contWeightArray(i1)

                          
                          if (ok) then
                             yArray(iLambda) = yArray(iLambda) + &
                                  (obsPhoton%stokes*obs_weight)
                          else 
                             yarray(ilambda) = yArray(ilambda) + &
                                  obsPhoton%stokes*(oneOnFourpi* directionalweight * exp(-tauExt(ntau)))
                          endif


                          thisVel = (observedlambda-lamLine)/lamLine
                          if (stokesImage) then
                             call addPhotonToImage(viewVec,  rotationAxis, obsImageSet, nImage, &
                                  obsPhoton, thisVel, obs_weight, filters, grid%octreeRoot%centre, &
                                  xArray(iLambda))
                          endif
                          if (dopvImage) then
                             do iSlit = 1, nSlit
                                call addPhotontoPVimage(pvImage(iSlit), obsPhoton, viewVec,  rotationAxis, thisVel, &
                                  obs_weight, gridDistance)
                             enddo
                          endif


                          statArray(iLambda) = statArray(iLambda) + 1.
                       enddo
                    endif
                 endif


                 call scatterPhoton(grid,thisPhoton, zeroVec, outPhoton, mie, &
                       miePhase, nLambda, nMuMie, ttau_disc_on, ttauri_disc)
                 thisPhoton = outPhoton

                 call integratePath(gridUsesAMR, VoigtProf, &
                            thisPhoton%lambda, lamLine, &
                            s2o(thisPhoton%velocity), thisPhoton%position, &
                            thisPhoton%direction, grid, lambda, tauExt, tauAbs, &
                            tauSca, linePhotonAlbedo, maxTau, nTau, thin_disc_on, opaqueCore, &
                            escProb, thisPhoton%contPhoton, lamStart, lamEnd, &
                            nLambda, contTau, hitCore, thinLine, lineResAbs, .false., &
                            .false., nUpper, nLower, 0.,&
                            0., 0., junk,sampleFreq,intPathError, &
                            useInterp, grid%Rstar1, coolStarPosition)

                 if (intPathError == -10) then ; tooFewSamples = tooFewSamples + 1  
                    goto 999 ; endif
                 if (intPathError == -20) then ; boundaryProbs = boundaryProbs + 1
                    goto 999 ; endif
                 if (intPathError == -70) then ; negativeOpacity = negativeOpacity + 1
                    goto 999 ; endif


                  call random_number(r1)
                  thistau = -log(max(1.e-10,(1. - r1)))
                  if (thistau .gt. tauExt(nTau)) then
                     escaped = .true.  
                  else
                     escaped = .false.  
                  endif


!                  if (maxScat == 1) then
!                     call random_number(r1)
!                     thistau = -log(max(1.e-10,(1. - r1)))
!                     if (thistau .gt. tauExt(nTau)) then
!                        ! one scattering forced already, 
!                        ! so let it escape the second time if it must.
!                        escaped = .true.  
!                     else
!                        nscat = 0
!                     endif
!                  else  
!                     ! This should be never reached if MAXSCAT<2.
!                     tau_bnd = tauExt(nTau) ! Optical depth to outer boundary.
!                     if(abs(tau_bnd) < 0.01)then  ! appoximation
!                        fac=tau_bnd*(  1.0d0-0.5d0*tau_bnd*( 1.0d0-tau_bnd/3.0d0*  &
!                             (1.0d0-0.25d0*tau_bnd) )  )
!                     else
!                        fac=1.0d0-exp(-tau_bnd)
!                     end if
!                     call random_number(r1)
!                     thisTau = -log(1.d0-r1*fac)
!                     ! (RK) commented out the next line.
!                     ! if (thisTau > tauExt(nTau)) print *, 'Fixed thisTau in scattering loop.'
!                     thisTau = min(dble(thisTau),tau_bnd)
!                     thisPhoton%stokes = thisPhoton%stokes * real(fac)
!                  endif


              endif  ! (.not. absorbed)


           enddo
           nTot = nTot + nScat

999  continue  ! escape route for a bad photon

           deallocate(lambda)
           deallocate(tauSca)
           deallocate(tauExt)
           deallocate(tauAbs)
           deallocate(linePhotonalbedo)
           deallocate(contTau)
           deallocate(contWeightArray)


        enddo innerPhotonLoop
!$OMP END DO
!$OMP END PARALLEL



        
!$MPI    end do mpiBlockLoop  
!$MPI  end if ! (my_rank /= 0)

!$MPI     write (*,'(A,I3,A,I3,A,I3,A)') 'Process ',my_rank, &
!$MPI                      ' waiting to sync spectra... (',iOuterLoop,'/',nOuterLoop,')' 
!$MPI     call MPI_BARRIER(MPI_COMM_WORLD, ierr) 
!$MPI
!$MPI   ! we have to syncronize the 'yArray' after each inner photon loop to
!$MPI   !   get the statistics right  
!$MPI     allocate(tempRealArray(SIZE(yArray)))
!$MPI     tempRealArray = 0.0
!$MPI     call MPI_REDUCE(yArray%i,tempRealArray,SIZE(yArray),MPI_REAL,&
!$MPI                     MPI_SUM,0,MPI_COMM_WORLD,ierr)
!$MPI     yArray%i = tempRealArray 
!$MPI     tempRealArray = 0.0
!$MPI     call MPI_REDUCE(yArray%q,tempRealArray,SIZE(yArray),MPI_REAL,&
!$MPI                     MPI_SUM,0,MPI_COMM_WORLD,ierr)
!$MPI     yArray%q = tempRealArray 
!$MPI     tempRealArray = 0.0
!$MPI     call MPI_REDUCE(yArray%u,tempRealArray,SIZE(yArray),MPI_REAL,&
!$MPI                     MPI_SUM,0,MPI_COMM_WORLD,ierr)
!$MPI     yArray%u = tempRealArray 
!$MPI     tempRealArray = 0.0
!$MPI     call MPI_REDUCE(yArray%v,tempRealArray,SIZE(yArray),MPI_REAL,&
!$MPI                     MPI_SUM,0,MPI_COMM_WORLD,ierr)
!$MPI     yArray%v = tempRealArray 
!$MPI     deallocate(tempRealArray)
!$MPI
!$MPI     print *,'Process ',my_rank,' finished syncing output. Waiting to continue...' 
!$MPI     call MPI_BARRIER(MPI_COMM_WORLD, ierr) 



!$MPI if (my_rank == 0) &
        write(*,'(i8,a,f7.3)') iOuterLoop*nPhotons/nOuterLoop," photons done"

        errorArray(iOuterLoop,1:nLambda) = yArray(1:nLambda)

!$MPI     call MPI_BARRIER(MPI_COMM_WORLD, ierr) 
!$MPI  if (my_rank==1) &
        call tune(6, "One Outer Photon Loop") ! Stop a stop watch        
     end do outerPhotonLoop ! outer photon loop


!$MPI  if (my_rank==1) &
     call tune(6, "All Photon Loops")  ! Stop a stopwatch

!$MPI     tempInt = 0
!$MPI     call MPI_REDUCE(tooFewSamples,tempInt,1,MPI_INTEGER,MPI_SUM,0, MPI_COMM_WORLD,ierr)
!$MPI     tooFewSamples = tempInt
!$MPI
!$MPI     call MPI_REDUCE(boundaryProbs,tempInt,1,MPI_INTEGER,MPI_SUM,0, MPI_COMM_WORLD,ierr)
!$MPI     boundaryProbs = tempInt
!$MPI
!$MPI     call MPI_REDUCE(negativeOpacity,tempInt,1,MPI_INTEGER,MPI_SUM,0, MPI_COMM_WORLD,ierr)
!$MPI     negativeOpacity = tempInt
!$MPI
!$MPI     call MPI_REDUCE(nTot,tempInt,1,MPI_INTEGER,MPI_SUM,0, MPI_COMM_WORLD,ierr)
!$MPI     nTot = tempInt
!$MPI
!$MPI if (stokesimage) then
!$MPI   do i = 1, nImage
!$MPI     allocate(tempRealArray(SIZE(obsImageSet(i)%pixel)))
!$MPI     allocate(tempRealArray2(SIZE(obsImageSet(i)%pixel)))
!$MPI     tempRealArray = 0.0
!$MPI     tempRealArray2 = 0.0
!$MPI
!$MPI     tempRealArray = reshape(obsImageSet(i)%pixel%i,(/SIZE(tempRealArray)/))
!$MPI     call MPI_REDUCE(tempRealArray,tempRealArray2,SIZE(tempRealArray),MPI_REAL,&
!$MPI                     MPI_SUM,0,MPI_COMM_WORLD,ierr)
!$MPI     obsImageSet(i)%pixel%i = reshape(tempRealArray2,SHAPE(obsImageSet(i)%pixel%i))
!$MPI
!$MPI     tempRealArray = reshape(obsImageSet(i)%pixel%q,(/SIZE(tempRealArray)/))
!$MPI     call MPI_REDUCE(tempRealArray,tempRealArray2,SIZE(tempRealArray),MPI_REAL,&
!$MPI                     MPI_SUM,0,MPI_COMM_WORLD,ierr)
!$MPI     obsImageSet(i)%pixel%q = reshape(tempRealArray2,SHAPE(obsImageSet(i)%pixel%q))
!$MPI
!$MPI     tempRealArray = reshape(obsImageSet(i)%pixel%u,(/SIZE(tempRealArray)/))
!$MPI     call MPI_REDUCE(tempRealArray,tempRealArray2,SIZE(tempRealArray),MPI_REAL,&
!$MPI                     MPI_SUM,0,MPI_COMM_WORLD,ierr)
!$MPI     obsImageSet(i)%pixel%u = reshape(tempRealArray2,SHAPE(obsImageSet(i)%pixel%u))
!$MPI
!$MPI     tempRealArray = reshape(obsImageSet(i)%pixel%v,(/SIZE(tempRealArray)/))
!$MPI     call MPI_REDUCE(tempRealArray,tempRealArray2,SIZE(tempRealArray),MPI_REAL,&
!$MPI                     MPI_SUM,0,MPI_COMM_WORLD,ierr)
!$MPI     obsImageSet(i)%pixel%v = reshape(tempRealArray2,SHAPE(obsImageSet(i)%pixel%v))
!$MPI
!$MPI
!$MPI     tempRealArray = reshape(obsImageSet(i)%vel,(/SIZE(tempRealArray)/))
!$MPI     call MPI_REDUCE(tempRealArray,tempRealArray2,SIZE(tempRealArray),MPI_REAL,&
!$MPI                     MPI_SUM,0,MPI_COMM_WORLD,ierr)
!$MPI     obsImageSet(i)%vel = reshape(tempRealArray2,SHAPE(obsImageSet(i)%vel))
!$MPI
!$MPI     tempRealArray = reshape(obsImageSet(i)%totWeight,(/SIZE(tempRealArray)/))
!$MPI     call MPI_REDUCE(tempRealArray,tempRealArray2,SIZE(tempRealArray),MPI_REAL,&
!$MPI                     MPI_SUM,0,MPI_COMM_WORLD,ierr)
!$MPI     obsImageSet(i)%totWeight = reshape(tempRealArray2,SHAPE(obsImageSet(i)%totWeight))
!$MPI
!$MPI     deallocate(tempRealArray)
!$MPI     deallocate(tempRealArray2)
!$MPI   end do
!$MPI     if (doRaman) then
!$MPI        print *, 'MPI o6Image not implemented!'
!$MPI        stop
!$MPI     endif
!$MPI endif ! (stokesimage)
!$MPI
!$MPI if (doPvimage) then
!$MPI   do iSlit = 1, nSlit
!$MPI     allocate(tempRealArray(SIZE(pvImage(i)%pixel)))
!$MPI     allocate(tempRealArray2(SIZE(pvImage(i)%pixel)))
!$MPI
!$MPI     tempRealArray = reshape(pvImage(i)%pixel,(/SIZE(tempRealArray)/))
!$MPI     tempRealArray2 = 0.0
!$MPI     call MPI_REDUCE(tempRealArray,tempRealArray2,SIZE(tempRealArray),MPI_REAL,&
!$MPI                     MPI_SUM,0,MPI_COMM_WORLD,ierr)
!$MPI     pvImage(i)%pixel = reshape(tempRealArray2,SHAPE(pvImage(i)%pixel))
!$MPI
!$MPI     deallocate(tempRealArray)
!$MPI     deallocate(tempRealArray2)
!$MPI
!$MPI     allocate(tempRealArray(SIZE(pvImage(i)%vAxis)))
!$MPI     tempRealArray = 0.0
!$MPI     call MPI_REDUCE(pvImage(i)%vAxis,tempRealArray,SIZE(pvImage(i)%vAxis),MPI_REAL,&
!$MPI                     MPI_SUM,0,MPI_COMM_WORLD,ierr)
!$MPI     pvImage(i)%vAxis = tempRealArray
!$MPI     deallocate(tempRealArray)
!$MPI
!$MPI     allocate(tempRealArray(SIZE(pvImage(i)%pAxis)))
!$MPI     tempRealArray = 0.0
!$MPI     call MPI_REDUCE(pvImage(i)%pAxis,tempRealArray,SIZE(pvImage(i)%pAxis),MPI_REAL,&
!$MPI                     MPI_SUM,0,MPI_COMM_WORLD,ierr)
!$MPI     pvImage(i)%pAxis = tempRealArray
!$MPI     deallocate(tempRealArray)
!$MPI
!$MPI   end do ! iSlit 
!$MPI endif ! (doPvimage)

!$MPI if (my_rank == 0) then 
     write(*,*) " "
     write(*,'(a)') "Model summary"
     write(*,'(a)') "-------------"
     write(*,*) " "

     call systemInfo(startTime,nPhotons)
     
     if (grid%adaptive) then
        print *, tooFewSamples, ' rays had 2 or less samples.'
        print *, BoundaryProbs, ' rays had numerical problems with octal boundaries.'
        print *, negativeOpacity, ' rays had problems with negative opacity values.'
     end if
     write(*,*) " "
     write(*,*) "Average # of scattering per photon:: ", real(nTot)/real(nPhotons)
     write(*,*) " " 
!$MPI end if 

!     if (.not.grid%cartesian.and.(grid%rCore /= 0.)) then
!        if (wtot_line /= 0.) write(*,*) "Mean radius of line formation",meanr_line/wtot_line/grid%rCore
!        if (wtot0_line /= 0.) write(*,*) "Mean radius of line zero",meanr0_line/wtot0_line/grid%rCore
!        if (wtot_cont /= 0.) write(*,*) "Mean radius of cont formation",meanr_cont/wtot_cont/grid%rCore
!        if (wtot0_cont /=0.) write(*,*) "Mean radius of cont zero",meanr0_cont/wtot0_cont/grid%rCore
!     endif
     normalizeSpectrum = .false.
     if (.not.doRaman) then
        normalizeSpectrum = .true.
     endif

     if (mie) normalizeSpectrum = .false.

!$MPI if (my_rank == 0) then 
     if (nPhase == 1) then



        call writeSpectrum(outFile,  nLambda, xArray, yArray,  errorArray, nOuterLoop, &
     .false., useNdf, sed, objectDistance, jansky, SIsed, .false., lamLine)

        if (velocitySpace) then
           specFile = trim(outfile)//"_v"
           call writeSpectrum(specFile,  nLambda, xArray, yArray,  errorArray, nOuterLoop, &
             .true., useNdf, sed, objectDistance, jansky, SIsed, velocitySpace, lamLine)
        endif

     else
        write(tempChar,'(i3.3)') iPhase
        specFile = trim(outfile)//trim(tempChar)

        call writeSpectrum(specFile,  nLambda, xArray, yArray,  errorArray, nOuterLoop, &
      .false., useNdf, sed, objectDistance, jansky, SIsed, velocitySpace, lamLine)

        if (velocitySpace) then
           tempChar = trim(specFile)//"_v"
           call writeSpectrum(tempChar,  nLambda, xArray, yArray,  errorArray, nOuterLoop, &
             .true., useNdf, sed, objectDistance, jansky, SIsed, velocitySpace, lamLine)
        endif


        if (doRaman) then
           write(tempChar,'(i3.3)') iPhase
           o6filename = trim(outfile)//"_o6_"//trim(tempChar)//".dat"
           open(20,file=o6filename,status="unknown",form="formatted")
           do i = 1, no6pts
              t1 = 1./(o6xArray(2)-o6xArray(1))
              write(20,*) o6xarray(i),o6yarray(i)*t1,1.e-20,1.e-30,1.e-20,1.e-30
           enddo
           close(20)
        endif
     endif

     close(22)

     if (stokesimage) then
        do i = 1, nImage
           name_filter = get_filter_name(filters, i)
           bandwidth = 0.5*FWHM_filters(filters, i)  ! 1/2 of FWHM  [A]
           lambda_eff = lambda_eff_filters(filters, i) ! Effective wavelength of filter in [A]   
           write(specFile,'(a,a,a,i3.3)') trim(outfile),"_"//trim(name_filter),"_image",iPhase
           call writeImage(obsImageSet(i), specfile, objectDistance, imageInArcsec, lambda_eff, bandwidth)
        end do
        if (doRaman) then
           write(specFile,'(a,a,i3.3)') trim(outfile),"_o6image",iPhase
           !+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
           ! Check the the effectieve wavelength and the 
           ! bandwith of O6 image here later and replace 5000 and 1.0d0 below!
           !+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
           call writeImage(o6Image(1), specfile, objectDistance, imageInArcsec, 5000d0, 1.0d0)
        endif

     endif

     if (doPvimage) then
        do iSlit = 1, nSlit
           write(specFile,'(a,a,i3.3,a,i2.2)') trim(outfile),"_pvimage",iPhase,"_slit_",iSlit

           call smoothPVimage(pvImage(iSlit), vfwhm/2.35, pfwhm/2.35)

           call writePVimage(pvImage(iSlit), specfile, vSys)
           if (device /= "/xs") then
              write(plotfile,'(a,i3.3,a,i2.2,a,a)') "slitplot",iPhase,"_slit_",iSlit,".gif",trim(device)
           else
              plotfile = device
           endif
           ! doing this only for the first image in obsImageSet
           call plotSlitOnImage(obsImageSet(1), PVimage(iSlit), plotfile, gridDistance)
        enddo
     endif
!$MPI end if ! (my_rank == 0)

     if (stokesImage) then
        do i = 1, nImage
           call freeImage(obsImageSet(i))
        end do
     end if

     if (doPVimage) then
        do iSlit = 1, nSlit
           call freePVimage(pvImage(iSlit))
        enddo
     endif

     end do incLoop ! end of multiple inclination loop
     
     if (associated(starSurface%element)) then
       call emptySurface(starSurface)
     end if

!$MPI if (my_rank /= 0 .and. .not.noPhaseUpdate) call freeGrid(grid)
!$MPI   print *,'Process ',my_rank,' waiting inside end of phase loop...' 
!$MPI  call MPI_BARRIER(MPI_COMM_WORLD, ierr) 
  enddo phaseLoop



666 continue

!  call freeGrid(grid)


!$MPI  if (my_rank==1) &
call tune(6, "Torus Main") ! stop a stopwatch  

!$MPI  call MPI_BARRIER(MPI_COMM_WORLD, ierr) 
!$MPI  call MPI_FINALIZE(ierr)


  end program torus

!!! vim:set filetype=fortran :                                !!!  
!!! otherwise vim won't recognize a file with the suffix .raw !!!

module cmf_mod

  ! written by tjh


  use kind_mod
  use constants_mod
  use utils_mod
  use messages_mod
  use grid_mod
  use math_mod
  use modelatom_mod
  use source_mod

  !$MPI    use parallel_mod

  implicit none

  private
  public:: atomLoop, calculateAtomSpectrum

contains

  subroutine solveLevels(thisOctal, subcell, nPops, jnuLine,  &
       temperature, nAtom, thisAtom, ne, rho, jnuCont, freq, nfreq)
    type(OCTAL), pointer :: thisOctal
    integer :: subcell
    integer :: nFreq
    integer :: num(100)
    real(double) :: freq(:), jnuCont(:)
    real(double) :: nPops(:,:)
    real(double) :: temperature, ne
    real(double) :: jnuLine(:)
    type(MODELATOM) :: thisAtom(:)
    real(double), allocatable :: matrixA(:,:), matrixB(:), collMatrix(:,:), cTot(:)
    integer, allocatable :: indx(:)
    real(double), allocatable :: vMatrix(:,:), wMatrix(:,:), xMatrix(:)
    real(double) :: wMax, wMin
    real(double) :: d 
    real(double) :: arateji, boltzFac
    integer :: nLevels
    integer :: iLower, iUpper, iLevel, i, j
    integer :: itrans, l, k, iPart
    real(double) :: collEx, colldeEx
    real(double) :: a, Bul, Blu
    real(double) :: photoRatelk, recombRatekl, xSection
    real(double) :: partitionFunc
    real(double) :: fac, rho
    real(double) :: prate, rrate, NstarRatio, totRecomb, totPHotoIon, totcion
    real(double) :: tot1, tot2
    real(double) :: nuStart,thisFreq,test
    integer :: iStart
    integer :: iJnu
    real(double) :: jnu
    real(double) :: radtot, colltot
    integer :: nAtom, iAtom, nMatrix
    integer, allocatable :: nOffset(:)
    logical, allocatable :: continuumGround(:)
    integer, allocatable :: nCons(:)
    logical :: ok, debug, lymanAlpha

    debug = .false.



    allocate(nOffset(1:nAtom))
    allocate(nCons(1:nAtom))
    allocate(continuumGround(1:nAtom))
    continuumGround = .false.

    nMatrix = 0
    nOffset(1) = 0
    do iAtom = 1, nAtom

       if (iAtom /= nAtom) then
          if (thisAtom(iAtom)%nz /= thisAtom(iAtom+1)%nz) then ! if next atom is different element
             nMatrix = nMatrix + thisAtom(iAtom)%nLevels 
             nMatrix = nMatrix + 1  
             nCons(iAtom) = nMatrix
             nOffset(iAtom+1) = nMatrix
          else
             nMatrix = nMatrix + thisAtom(iAtom)%nLevels-1  ! continuum state of this atom is ground state of next
             continuumGround(iAtom) = .true.
             nOffset(iAtom+1) = nMatrix
             nCons(iAtom) = 0
          endif
       else
          nMatrix = nMatrix + thisAtom(iAtom)%nLevels  ! last atom
          nMatrix = nMatrix + 1  
          nCons(iAtom) = nMatrix
       endif
    enddo



    allocate(matrixA(1:nMatrix,1:nMatrix))
    allocate(matrixB(1:nMatrix))


    matrixA = 0.d0
    matrixB = 0.d0



    do i = 1, nMatrix
       num(i) = i
    enddo
       

    do iAtom = 1, nAtom
       if (nCons(iAtom) /= 0) then
          matrixB(nCons(iAtom)) = thisOctal%atomAbundance(subcell,iAtom) * rho
          if (continuumGround(iAtom)) then
             matrixA(nCons(iAtom),1+nOffset(iAtom):nOffset(iAtom)+thisAtom(iAtom)%nLevels-1) = 1.d0
          else
             matrixA(nCons(iAtom),1+nOffset(iAtom): nOffset(iAtom)+thisAtom(iAtom)%nLevels) = 1.d0
          endif
       endif
    enddo


    do iAtom = 1, nAtom

       colltot = 0.d0
       radtot = 0.d0

       nLevels = thisAtom(iAtom)%nLevels

       ! recombination rates

       do iTrans = 1, thisAtom(iAtom)%nTrans
          totRecomb = 0.d0
          tot1 = 0.d0
          tot2 = 0.d0

          k = thisAtom(iAtom)%iUpper(iTrans)
          l = thisAtom(iAtom)%iLower(iTrans)

          NstarRatio = boltzSahaGeneral(thisAtom(iAtom), 1, l, ne, temperature)

          if (thisAtom(iAtom)%transType(iTrans) == "RBF") then ! radiative recomb
             recombratekl = 0.d0
             nuStart = (thisAtom(iAtom)%iPot - thisAtom(iAtom)%energy(l))*evtoerg/hcgs


             call locate(freq, nfreq, nuStart, istart)

             do i = istart+1, nFreq
                xSection = photoCrossSection(thisAtom(iAtom), iTrans, l, freq(i))
                recombRatekl = recombRatekl + &
                     (fourPi/(hCgs*freq(i)))*xSection*((2.d0*hCgs*freq(i)**3)/cSpeed**2 + jnuCont(i)) * &
                     exp(-(hCgs*freq(i))/(kErg*temperature))*(freq(i)-freq(i-1))
             enddo


!             thisFreq = (thisAtom(iatom)%iPot-thisAtom(iAtom)%energy(l))*evtoerg/hcgs
!             write(*,*) "thisFreq",thisFreq,thisFreq*hcgs*ergtoev
!             xSection = photoCrossSection(thisAtom(iAtom), l, thisFreq*1.01d0)
!             test = (8.d0*pi/cspeed**2) * xSection *thisFreq**3*expint(1,hcgs*thisFreq/(kerg*temperature))
!             write(*,*) "test",l,test,recombratekl



             matrixA(l+nOffset(iAtom),k+nOffset(iAtom)) = matrixA(l+nOffset(iAtom),k+nOffset(iAtom)) + NstarRatio * recombratekl
             tot1 = tot1  + NstarRatio * recombratekl


!          if ((l == 1).and.iatom==3) then
!             write(*,*) "radiative recomb to ground state ",NstarRatio * recombratekl * &
!                  npops(iatom,k)
!          endif

          endif


          if (thisAtom(iAtom)%transType(iTrans) == "CBF") then ! collisional recomb

             collEx = collisionRate(thisAtom(iAtom), iTrans, temperature)


             matrixA(l+nOffset(iAtom),k+nOffset(iAtom)) = matrixA(l+nOffset(iAtom),k+nOffset(iAtom)) + NstarRatio*collEx*ne
             tot2 = tot2 + NstarRatio*collEx*ne

!             if ((l == 1).and.iatom==3) then
!                write(*,*) "coll recomb to ground state ",NstarRatio * ne * colleX * &
!                     npops(iatom,k) 
!             endif


          endif

          radtot = radtot + tot1
          colltot = colltot + tot2

          totRecomb =  tot1 + tot2
          matrixA(k+nOffset(iAtom), k+nOffset(iAtom)) = matrixA(k+nOffset(iAtom), k+nOffset(iAtom))-totRecomb


       enddo

!       if (iatom == 3)        write(*,*) "total recomb: ",(radtot + colltot)*nPops(iatom,k)

       lymanAlpha  = .false.

       totPhotoIon = 0.d0
       totcion = 0.d0
       do iTrans = 1, thisAtom(iAtom)%nTrans

          k = thisAtom(iAtom)%iUpper(iTrans)
          l = thisAtom(iAtom)%iLower(iTrans)



          if (thisAtom(iAtom)%transType(iTrans) == "RBB") then ! radiative BB rates
             iJnu = thisAtom(iAtom)%indexRBBTrans(iTrans)
             call returnEinsteinCoeffs(thisAtom(iAtom), iTrans, a, Bul, Blu)



             call locate(freq, nfreq, thisAtom(iatom)%transFreq(itrans), istart)

             jnu = jNuLine(iJnu)





             matrixA(k+nOffset(iAtom),k+nOffset(iAtom)) = matrixA(k+nOffset(iAtom),k+nOffset(iAtom)) - Bul * jnu - a
             matrixA(l+nOffset(iAtom),l+nOffset(iAtom)) = matrixA(l+nOffset(iAtom),l+nOffset(iAtom)) - Blu * jnu
             matrixA(k+nOffset(iAtom),l+nOffset(iAtom)) = matrixA(k+nOffset(iAtom),l+nOffset(iAtom)) + Blu * jnu
             matrixA(l+nOffset(iAtom),k+nOffset(iAtom)) = matrixA(l+nOffset(iAtom),k+nOffset(iAtom)) + Bul * jnu + a

          endif

          if (thisAtom(iAtom)%transType(iTrans) == "CBB") then ! collision BB  rates


             collEx = collisionRate(thisAtom(iAtom), iTrans, temperature)
             boltzFac =  exp(-abs(thisAtom(iAtom)%energy(k)-thisAtom(iAtom)%energy(l)) / (kev*temperature))
             colldeEx = collEx / (boltzFac * thisAtom(iAtom)%g(k)/thisAtom(iAtom)%g(l))

             matrixA(k+nOffset(iAtom),k+nOffset(iAtom)) = matrixA(k+nOffset(iAtom),k+nOffset(iAtom)) - colldeex * ne
             matrixA(l+nOffset(iAtom),l+nOffset(iAtom)) = matrixA(l+nOffset(iAtom),l+nOffset(iAtom)) - collex * ne
             matrixA(k+nOffset(iAtom),l+nOffset(iAtom)) = matrixA(k+nOffset(iAtom),l+nOffset(iAtom)) + collex * ne
             matrixA(l+nOffset(iAtom),k+nOffset(iAtom)) = matrixA(l+nOffset(iAtom),k+nOffset(iAtom)) + colldeex * ne

          endif

          ! now do bound-free rates



          if (thisAtom(iAtom)%transType(iTrans) == "RBF") then ! photoionization


             l = thisAtom(iAtom)%iLower(iTrans)
             k = thisAtom(iAtom)%iUpper(iTrans)

             nuStart = (thisAtom(iAtom)%iPot - thisAtom(iAtom)%energy(l))*evtoerg/hcgs

             call locate(freq, nfreq, nuStart, istart)

             photoRatelk = 0.d0
             do i = istart+1, nFreq
                xSection = photoCrossSection(thisAtom(iAtom), iTrans, l, freq(i))
                photoRatelk = photoRatelk + (jnuCont(i)/(hCgs*freq(i)))*xSection*(freq(i)-freq(i-1))
             enddo
             photoRatelk = photoRatelk * fourPi


             matrixA(l+nOffset(iAtom),l+nOffset(iAtom)) = matrixA(l+nOffset(iAtom),l+nOffset(iAtom)) - photoRatelk
             matrixA(k+nOffset(iAtom),l+nOffset(iAtom)) = matrixA(k+nOffset(iAtom),l+nOffset(iAtom)) + photoRatelk
             totphotoion=totphotoion + photoRatelk*npops(iatom,l)
!             if ((l == 1).and.iatom==3) then
!                write(*,*) "total photoionization from ground state ",photoRatelk*npops(iatom,l)
!             endif
          endif


          if (thisAtom(iAtom)%transType(iTrans) == "CBF") then ! collisional ionization

             k = thisAtom(iAtom)%iUpper(iTrans)
             l = thisAtom(iAtom)%iLower(iTrans)


             collEx = collisionRate(thisAtom(iAtom), iTrans, temperature)

             matrixA(l+nOffset(iAtom),l+nOffset(iAtom)) = matrixA(l+nOffset(iAtom),l+nOffset(iAtom)) - collex * ne
             matrixA(k+nOffset(iAtom),l+nOffset(iAtom)) = matrixA(k+nOffset(iAtom),l+nOffset(iAtom)) + collex * ne
             totcion = totcion + collex*ne*npops(iatom,l)
          endif


       enddo

!          if (iatom == 3) write(*,*) "total photoionization: " , totphotoion, totcion

    enddo

    
!    if (debug) then
!       write(*,'(4x,100i8)') num(1:nMatrix)
!       do i = 1, nMatrix
!          write(*,'(i4,1p,100e8.1)') i,matrixA(i,1:nMatrix),matrixB(i)
!       enddo
!    endif

!    call luSlv(matrixA, matrixB, nMatrix)
    call GAUSSJ(matrixA, nMatrix, nMatrix, matrixB, 1, nMatrix, ok)

!    allocate(indx(1:nMatrix))
!    call ludcmp(matrixA, nMatrix, nMatrix, indx, d)
!    call lubksb(matrixA, nMatrix, nMatrix, indx, matrixB)
!    deallocate(indx)

!    allocate(wMatrix(1:nMatrix,1:nMatrix))
!    allocate(vMatrix(1:nMatrix,1:nMatrix))
!    allocate(xMatrix(1:nMatrix))
!    call svdcmp(matrixA, nMatrix, nMatrix, nMatrix, nMatrix, wMatrix, vMatrix)
!    wMax = maxval(wMatrix)
!    wMin = 1.d-13 * wMax
!    where (wMatrix < wMin)
!       wMatrix = 0.d0
!    end where
!    call svbksb(matrixA, Wmatrix, vMatrix, nMatrix, nMatrix, nMatrix, nMatrix, matrixB, xmatrix)
!    matrixB = xmatrix
!    deallocate(wmatrix,vmatrix, xmatrix)


    do iAtom = 1, nAtom
       nPops(iAtom,1:thisAtom(iAtom)%nLevels) = matrixB(1+nOffset(iAtom):thisAtom(1)%nLevels+nOffset(iAtom))
    enddo
    deallocate(matrixA, matrixB)


    if (debug) then
       do iAtom = 1, nAtom
          write(*,*) trim(thisAtom(iAtom)%name),SUM(nPops(iAtom,1:thisAtom(iAtom)%nLevels-1))
          write(*,*) trim(thisAtom(iAtom)%name)//"I",nPops(iAtom,thisAtom(iAtom)%nLevels)
       enddo
       write(*,*) "Ne",ne,rho/mhydrogen
    endif

  end subroutine solveLevels


  subroutine getRay(grid, fromOctal, fromSubcell, position, direction, ds, phi, i0, &
       hCol, HeIcol, HeIIcol, nAtom, thisAtom, source, nSource, &
       hitPhotosphere, sourceNumber, cosTheta, weight, nRBBTrans, indexRBBTrans, indexAtom, nHAtom, nHeIAtom, nHeIIAtom, &
       nFreq, freq, iCont)
    use input_variables, only : opticallyThickContinuum
    type(SOURCETYPE) :: source(:)
    integer :: nfreq
    real(double) :: freq(:)
    real(double) :: iCont(:)
    integer :: nAtom
    integer :: nSource
    integer :: nRBBTrans, indexRBBTrans(:), indexAtom(:)
    type(MODELATOM) :: thisAtom(:)
    type(GRIDTYPE) :: grid
    type(OCTAL), pointer :: thisOctal, startOctal, fromOctal
    integer :: fromSubcell
    integer :: subcell
    real(double) :: ds, phi, i0(:), r, phi1, phi2, cosTheta
    real(double) :: Hcol, HeICol, HeIICol
    integer :: iTrans
    type(OCTALVECTOR) :: position, direction, currentPosition, thisPosition, thisVel
    type(OCTALVECTOR) :: rayVel, startVel, endVel, endPosition, pvec
    real(double) :: alphanu, snu, jnu
    integer :: iLower , iUpper
    real(double) :: dv, deltaV
    integer :: i
    real(double) :: distArray(200), tval
    integer :: nTau
    integer :: nHatom, nHeIAtom, nHeIIAtom
    real(double) :: nLower, nUpper
    real(double) :: dTau, etaline, didtau
    real(double), allocatable :: tau(:)
    real(double) :: intensityIntegral
    real(double) :: dvAcrossCell, projVel
    integer :: iCount
    real(double) :: a, blu, bul
    real(double) :: distTosource, totDist
    integer :: sourceNumber
    logical :: hitPhotosphere, hitSource
    real(double) :: dv1, dv2
    real(double) :: weight
    integer :: iAtom, iRBB
    real :: xH, xHeI, xHeII
    real(double) :: dTauCont, phiAv, phiNorm, kappaBB
    logical :: firstSubcell
    integer :: nBug
    integer :: iFreq
    real(double), allocatable :: tauCont(:), jnuCont(:), alphanuCont(:)

    allocate(tauCont(1:nFreq))
    allocate(jnuCont(1:nFreq))
    allocate(alphanuCont(1:nFreq))

    allocate(tau(1:nRBBTrans))
    
    position = randomPositionInCell(fromOctal, fromsubcell)

    icount = 1
    thisOctal => grid%octreeRoot
    call findSubcellLocal(position, thisOctal, subcell)


    call randomRayDirection(0.9d0, position, source, nSource, direction, weight)


    call random_number(r)

    totDist = 0.d0
    call distanceToSource(source, nSource, position, direction, hitSource, disttoSource, sourcenumber)

   if (hitSource) then
      pVec = (position + (direction * distToSource) - source(sourceNumber)%position)
      call normalize(pVec)
      cosTheta = -1.d0*(pVec.dot.direction)
   endif


    rayVel = amrGridVelocity(grid%octreeRoot, position, startOctal = thisOctal, actualSubcell = subcell)

    call random_number(r)

    deltaV = 4.3 * thisOctal%microturb(subcell) * (r-0.5d0)

    deltaV = deltaV +  (rayVel .dot. direction)

    projVel = deltaV - (rayVel .dot. direction)

    Hcol = 0.d0
    HeICol = 0.d0
    HeIICol = 0.d0
    i0 = 0.d0
    intensityIntegral = 0.0
    tau = 0.d0
    tauCont = 0.d0
    iCont = 0.d0

    hitPhotosphere = .false.
    firstSubcell = .true.

    currentPosition = position

    nBug = 0
    do while(inOctal(grid%octreeRoot, currentPosition).and.(.not.hitPhotosphere))

       nBug = 0
       phiAv = 0.d0
       phiNorm = 0.d0

       call findSubcellLocal(currentPosition, thisOctal, subcell)
       call distanceToCellBoundary(grid, currentPosition, direction, tVal, sOctal=thisOctal)

       if ((totDist + tval) > distTosource) then
          tVal = distToSource - totDist
          hitPhotosphere = .true.
       endif

       if (firstSubcell) then
          ds = tval * 1.d10
       endif


       startVel = amrGridVelocity(grid%octreeRoot, currentPosition, startOctal = thisOctal, actualSubcell = subcell) 
       endPosition = currentPosition + tval * direction
       endVel = amrGridVelocity(grid%octreeRoot, endPosition)


       dvAcrossCell = ((startVel - rayVel).dot.direction) - ((endVel - rayVel).dot.direction)
       dvAcrossCell = abs(dvAcrossCell / thisOctal%microturb(subcell))
       dv1 = abs(deltaV - (startVel .dot. direction))
       dv2 = abs(deltaV - (endVel .dot. direction))

       nTau = 2
       
       if (max(dv1,dv2) < 4.d0*thisOctal%microturb(subcell)) then
          nTau = min(max(2, nint(dvAcrossCell * 5.d0)),200)
       endif

       distArray(1) = 0.d0
       do i = 2, nTau
          
          distArray(i) = tval * dble(i-1)/dble(nTau-1)

          startOctal => thisOctal
          thisPosition = currentPosition + distArray(i)*direction
          thisVel = amrGridVelocity(grid%octreeRoot, thisPosition, startOctal = startOctal, actualSubcell = subcell) 

          alphanuCont = 0.d0
          jnuCont = 0.d0

          if (opticallyThickContinuum) then
             do iFreq = 1, nFreq
                
                
                alphanuCont(ifreq) = bfOpacity(freq(ifreq), nAtom, thisAtom, thisOctal%atomLevel(subcell,:,:))
                
                jnuCont(iFreq) = bfEmissivity(freq(ifreq), nAtom, thisAtom, &
                     thisOctal%atomLevel(subcell,:,:), thisOctal%ne(subcell), &
                     dble(thisOctal%temperature(subcell)))/fourPi
                
                dTau = alphaNuCont(iFreq) *  (distArray(i)-distArray(i-1)) * 1.d10
                
                if (alphanuCont(ifreq) /= 0.d0) then
                   snu = jnuCont(iFreq)/alphanuCont(iFreq)
                else
                   snu = tiny(snu)
                endif
                iCont(iFreq) = iCont(ifreq) +  exp(-tauCont(iFreq)) * (1.d0-exp(-dtau))*snu
                tauCont(iFreq) = tauCont(iFreq) + dtau
             enddo
          endif

          dv = deltaV - (thisVel .dot. direction)

          icount = icount + 1

          do iRBB = 1, nRBBTRans
             iAtom = indexAtom(iRBB)
             iTrans = indexRBBTrans(iRBB)

             if (thisAtom(iAtom)%transType(iTrans) == "RBB") then


                call locate(freq, nfreq, thisAtom(iAtom)%transFreq(iTrans), iFreq)

                call returnEinsteinCoeffs(thisAtom(iAtom), iTrans, a, Bul, Blu)


                alphanu = (hCgs*thisAtom(iAtom)%transFreq(iTrans)/fourPi) * &
                     phiProf(dv, thisOctal%microturb(subcell))/thisAtom(iAtom)%transFreq(iTrans)
                
                alphanu = alphanu + alphaNuCont(iFreq)

                if (firstSubcell) then
                   phiAv = phiAv + phiProf(dv, thisOctal%microturb(subcell)) * &
                        (distArray(i)-distArray(i-1)) * 1.d10
                   phiNorm = phiNorm + (distArray(i)-distArray(i-1)) * 1.d10
                endif


                iUpper = thisAtom(iAtom)%iUpper(iTrans)
                iLower = thisAtom(iAtom)%iLower(iTrans)
                
                nLower = thisOctal%atomLevel(subcell,iAtom, iLower)
                nUpper = thisOctal%atomLevel(subcell,iAtom, iUpper)

                
                alphanu = alphanu * (nLower * Blu - nUpper * Bul)
                
                dTau = alphaNu *  (distArray(i)-distArray(i-1)) * 1.d10
                

                etaLine = hCgs * a * thisAtom(iAtom)%transFreq(iTrans)
                etaLine = etaLine * thisOctal%atomLevel(subcell, iAtom, iUpper)
                jnu = (etaLine/fourPi) * phiProf(dv, thisOctal%microturb(subcell))/thisAtom(iAtom)%transFreq(iTrans)

                jnu = jnu + jnuCont(iFreq) 


                if (alphanu /= 0.d0) then
                   snu = jnu/alphanu
                else
                   snu = tiny(snu)
                endif

                i0(iRBB) = i0(iRBB) +  exp(-tau(irBB)) * (1.d0-exp(-dtau))*snu
                tau(iRBB) = tau(iRBB) + dtau

             endif
          enddo
       enddo
       currentPosition = currentPosition + (distArray(ntau)+1.d-3*grid%halfSmallestSubcell) * direction
       totdist = totdist + (distArray(ntau)+1.d-3*grid%halfSmallestSubcell)

       if (nBug > 10000) then
          write(*,*) "bug",currentPosition,nTau,distArray(nTau),modulus(currentPosition)
       endif

       if (firstSubcell) then
          phi = phiAv / phiNorm
          firstSubcell = .false.
       endif

    enddo
    if (hitPhotosphere) then ! don't include weight below - that's done when jbar is calculated
       do iFreq = 1, nFreq
          iCont(iFreq) = iCont(iFreq) + i_nu(source(sourceNumber), freq(iFreq))*cosTheta*exp(-tauCont(iFreq))
       enddo
    endif

!    call locate(freq, nfreq, cspeed/6562.8d-8,iFreq)
!    write(*,*) "icont ",icont(ifreq)

    
    if (hitPhotosphere) then ! don't include weight below - that's done when jbar is calculated
       do iRBB = 1, nRBBTrans
          iAtom = indexAtom(iRBB)
          iTrans = indexRBBTrans(iRBB)
          i0(iRBB) = i0(iRBB) + i_nu(source(sourceNumber), thisAtom(iATom)%transFreq(iTrans))*cosTheta*exp(-tau(iRBB))
!       if (thisAtom(iAtom)%iLower(iTrans)==2.and.thisAtom(iAtom)%iUpper(iTrans)==3) write(*,*) "inu line ",i0(irbb)
       enddo
    endif
    deallocate(tau)
  end subroutine getRay

  function phiProf(dv, b) result (phi)
    real(double) :: dv, b
    real(double) :: fac, phi
    phi = 1.d0 / (b * sqrt(Pi))
    fac = dv**2 / b**2
    phi = phi * exp(-fac)
  end function phiProf

  subroutine calculateJbar(thisOctal, subcell, thisAtom, nRay, ds, phi, i0, iTrans, jbar, nPops, &
       freq, nfreq, weight)
    real(double) :: freq(:), weight(:)
    logical :: doCont
    integer :: nfreq
    type(OCTAL), pointer :: thisOctal
    integer :: subcell
    type(MODELATOM) :: thisAtom
    integer :: nRay
    real(double) :: ds(:), phi(:), i0(:), nPops(:)
    integer :: iTrans
    real(double) :: jbar
    integer :: iRay
    real(double) :: nLower, nUpper
    real(double) :: jBarInternal, jBarExternal
    real(double) :: alphanu, jnu, etaline
    integer :: iUpper, iLower
    real(double) :: tau, snu, sumPhi
    real(double) :: a, bul, blu
    integer :: i
    logical,save :: first = .true.

    jBarExternal = 0.d0
    jBarInternal = 0.d0

    if (thisAtom%transType(iTrans) == "RBB") then

       iUpper = thisAtom%iUpper(iTrans)
       iLower = thisAtom%iLower(iTrans)

       sumPhi = 0.d0
       do iRay = 1, nRay
          alphanu = (hCgs*thisAtom%transFreq(iTrans)/fourPi)
          nLower = nPops(iLower)
          nUpper = nPops(iUpper)

          call returnEinsteinCoeffs(thisAtom, iTrans, a, Bul, Blu)

          alphanu = alphanu * (nLower * Blu - nUpper * Bul) * phi(iray)/thisAtom%transFreq(iTrans)

          if (alphanu < 0.d0) then
             alphanu = 0.d0
             if (first) then
                write(*,*) "negative opacity warning",iUpper,iLower,nLower,nUpper,thisAtom%name
                first = .false.
             endif
          endif

          tau = alphaNu * ds(iray)

          etaLine = hCgs * a * thisAtom%transFreq(iTrans)
          etaLine = etaLine *  nPops(iUpper)
          jnu = (etaLine/fourPi) * phi(iRay)/thisAtom%transFreq(iTrans)

          if (alphanu /= 0.d0) then
             snu = jnu/alphanu
          else
             snu = tiny(snu)
          endif

! need to include continuum here!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
          
          jBarExternal = jBarExternal + i0(iray) * exp(-tau) * phi(iRay) * weight(iRay)
          jBarInternal = jBarInternal + snu * (1.d0 - exp(-tau)) * phi(iRay) * weight(iRay)
 
          sumPhi = sumPhi + phi(iRay) * weight(iRay)
       enddo

       jbar = (jBarExternal + jBarInternal)/sumPhi
       call locate(freq, nfreq, thisAtom%transFreq(iTrans), i)

    endif
          
  end subroutine calculateJbar

  subroutine calculateJbarCont(thisOctal, subcell, nAtom, thisAtom, nray, ds, source, nSource, &
       hitPhotosphere, sourceNumber, freq, nfreq, &
       iCont, jBarCont, cosTheta, weight)
    use input_variables, only : opticallyThickContinuum
    real(double) :: iCont(:,:), jBarCont(:), ds(:)
    integer :: nAtom
    type(OCTAL), pointer :: thisOctal
    integer :: subcell
    type(MODELATOM) :: thisAtom(:)
    type(SOURCETYPE) :: source(:)
    integer :: nSource
    logical :: hitPhotosphere(:)
    integer :: sourceNumber(:)
    integer :: nfreq
    real(double) :: freq(:),  cosTheta(:), weight(:)
    integer :: iray, nRay, i
    real :: tau, xh, xhei, xheii
    real(double), allocatable :: jBarContExternal(:), jBarContInternal(:)
    integer :: nHatom, nHeIatom, nHeIIAtom
    real(double) :: alphanu
    integer :: iFreq
    real(double) :: jnu, snu

    allocate(jBarContExternal(1:nFreq))
    allocate(jBarContInternal(1:nFreq))

    jBarCont = 0.d0
    jBarContInternal = 0.d0
    jBarContExternal = 0.d0

    do iRay = 1, nRay
       do iFreq = 1, nFreq

          if (opticallyThickContinuum) then
             alphanu = bfOpacity(freq(ifreq), nAtom, thisAtom, thisOctal%atomLevel(subcell,:,:))
             jnu =  bfEmissivity(freq(ifreq), nAtom, thisAtom, &
                  thisOctal%atomLevel(subcell,:,:), thisOctal%ne(subcell), &
                  dble(thisOctal%temperature(subcell)))/fourPi
             tau = alphaNu * ds(iray)
             if (alphanu /= 0.d0) then
                snu = jnu/alphanu
             else
                snu = tiny(snu)
             endif
          endif
          jBarContExternal(iFreq) = jBarContExternal(iFreq) + iCont(iray, iFreq) * exp(-tau) * weight(iRay)
!          write(*,*) 1.d8*cspeed/freq(iFreq)," icont(iray,ifreq)",iCont(iRay,iFreq),tau
          jBarContInternal(iFreq) = jBarContInternal(iFreq) + snu * (1.d0 - exp(-tau)) * weight(iRay)
       enddo
    enddo

    jbarCont = (jBarContExternal + jBarContInternal)/SUM(weight(1:nRay))


  end subroutine calculateJbarCont


  subroutine atomLoop(grid, nAtom, thisAtom, nSource, source)

    use input_variables, only : blockhandout
!$MPI    include 'mpif.h'

    type(SOURCETYPE) :: source(:)
    integer :: nSource
    integer :: nAtom
    type(GRIDTYPE) :: grid
    type(MODELATOM) :: thisAtom(:)
    type(OCTALVECTOR) :: position, direction
    integer :: nOctal, iOctal, subcell
    real(double), allocatable :: ds(:), phi(:), i0(:,:), tau(:)
    real(double), allocatable :: Hcol(:), HeICol(:), HeIICol(:)
    integer :: nRay,m
    type(OCTAL), pointer :: thisOctal
    integer, parameter :: maxIter = 100, maxRay = 100000
    logical :: popsConverged, gridConverged 
    integer :: iRay, iTrans, iter,i 
    integer :: iStage
    real(double), allocatable :: oldpops(:,:), newPops(:,:), dPops(:,:)
    real(double) :: newNe, oldNe, dNe
    real(double), parameter :: underCorrect = 0.8D0
    real(double) :: fac
    type(octalWrapper), allocatable :: octalArray(:) ! array containing pointers to octals
    logical :: dcAllocated
    integer, dimension(:), allocatable :: octalsBelongRank
    real(double), allocatable :: tArrayd(:),tempArrayd(:)
    integer :: nVoxels
    integer :: ioctal_beg, ioctal_end, tag = 0
    real(double) :: maxFracChange
    logical :: fixedRays
    integer :: isize
    integer, allocatable :: iseed(:)
    real(double) :: tolerance
    integer, allocatable :: sourceNumber(:)
    type(OCTALVECTOR) :: posVec
    real(double) :: r
    real(double), allocatable :: cosTheta(:)
    real(double), allocatable :: weight(:)
    real(double), allocatable :: iCont(:,:)
    logical, allocatable :: hitPhotosphere(:)
    integer, parameter :: maxFreq = 200
    real(double) :: freq(maxFreq)
    real(double), allocatable :: jnuCont(:)
    integer :: nFreq, nhit, iRBB
    integer :: nRBBTrans
    integer :: indexRBBTrans(1000), indexAtom(1000)
    real(double) :: nuStart, nuEnd, ne
    integer :: iAtom
    integer :: nHAtom, nHeIAtom, nHeIIatom, ir, ifreq
    real(double) :: nstar
    logical :: debug
!$MPI    ! For MPI implementations
!$MPI    integer       ::   my_rank        ! my processor rank
!$MPI    integer       ::   np             ! The number of processes
!$MPI    integer       ::   ierr           ! error flag
!$MPI    logical       ::   rankComplete

    debug = .false.



     call createContFreqArray(nFreq, freq, nAtom, thisAtom, nsource, source, maxFreq)

     allocate(jnuCont(1:nFreq)) 

    blockHandout = .false. 

!$MPI    ! FOR MPI IMPLEMENTATION=======================================================
!$MPI    !  Get my process rank # 
!$MPI    call MPI_COMM_RANK(MPI_COMM_WORLD, my_rank, ierr)
!$MPI  
!$MPI    ! Find the total # of precessor being used in this run
!$MPI    call MPI_COMM_SIZE(MPI_COMM_WORLD, np, ierr)

    call createRRBarrays(nAtom, thisAtom, nRBBtrans, indexAtom, indexRBBTrans)

    call allocateLevels(grid, grid%octreeRoot, nAtom, thisAtom, nRBBTrans)

    !$MPI       if (my_rank == 0) &
    call writeAmrGrid("atom_tmp.grid",.false.,grid)


    nHAtom = 0
    nHeIAtom = 0
    nHeIIAtom = 0
    do iAtom = 1, nAtom
       if (thisAtom(iAtom)%name == "HI") nHatom = iAtom
       if (thisAtom(iAtom)%name == "HeI") nHeIatom = iAtom
       if (thisAtom(iAtom)%name == "HeII") nHeIIatom = iAtom
    enddo
       

    allocate(oldPops(1:nAtom,1:maxval(thisAtom(1:nAtom)%nLevels)))
    allocate(newPops(1:nAtom,1:maxval(thisAtom(1:nAtom)%nLevels)))
    allocate(dPops(1:nAtom,1:maxval(thisAtom(1:nAtom)%nLevels)))

    allocate(octalArray(grid%nOctals))
    nOctal = 0
    call getOctalArray(grid%octreeRoot,octalArray, nOctal)

    call random_seed

    call random_seed(size=iSize)
    allocate(iSeed(1:iSize))
    call random_seed(get=iSeed)
!$MPI     call MPI_BARRIER(MPI_COMM_WORLD, ierr) 
!$MPI     call MPI_BCAST(iSeed, iSize, MPI_INTEGER, 0, MPI_COMM_WORLD, ierr)


    nRay = 100

    do iStage = 1, 2


       if (iStage == 1) then
          fixedRays = .true.
          tolerance = 1.d-2
       else
          fixedRays = .false.
          tolerance = 1.d-4
       endif

       gridConverged = .false.

       do while (.not.gridConverged)

          allocate(ds(1:nRay))
          allocate(phi(1:nRay))
          allocate(i0(1:nRBBTrans, 1:nRay))
          allocate(tau(1:nRay))
          allocate(Hcol(1:nRay))
          allocate(HeIcol(1:nRay))
          allocate(HeIIcol(1:nRay))
          allocate(sourceNumber(1:nRay))
          allocate(cosTheta(1:nRay))
          allocate(weight(1:nRay))
          allocate(hitPhotosphere(1:nRay))
          allocate(iCont(1:nRay,1:nFreq))

          if (fixedRays) then
             call random_seed(put=iseed)   ! same seed for fixed rays
          else
             call random_seed
          endif

          ! default loop indecies
          ioctal_beg = 1
          ioctal_end = SIZE(octalArray)       

          


!$MPI    
!$MPI    ! we will use an array to store the rank of the process
!$MPI    !   which will calculate each octal's variables
!$MPI    allocate(octalsBelongRank(size(octalArray)))
!$MPI    
!$MPI    if (my_rank == 0) then
!$MPI       print *, ' '
!$MPI       print *, 'atomLoop  computed by ', np-1, ' processors.'
!$MPI       print *, ' '
!$MPI       call mpiBlockHandout(np,octalsBelongRank,blockDivFactor=1,tag=tag,&
!$MPI                            maxBlockSize=10,setDebug=.false.)
!$MPI    
!$MPI    endif
!$MPI    ! ============================================================================


!$MPI if (my_rank /= 0) then
!$MPI  blockLoop: do     
!$MPI call mpiGetBlock(my_rank,iOctal_beg,iOctal_end,rankComplete,tag,setDebug=.false.)
!$MPI   if (rankComplete) exit blockLoop 


          do iOctal = ioctal_beg, ioctal_end
             write(*,*) iOctal,iOctal_beg,iOctal_end
             thisOctal => octalArray(iOctal)%content
             do subcell = 1, thisOctal%maxChildren

!          open(31, file="r.dat",status="unknown",form="formatted")
!          do ir = 1, 50
!             r = log10(20.d0*rsol/1.d10) + (log10(2000.d0*rSol/1.d10)-log10(20.d0*rsol/1.d10))*real(ir-1)/49.d0
!             r = 10.d0**r
!             posVec = OCTALVECTOR(r, 0.d0, 0.d0)
!             thisOctal => grid%octreeRoot
!             call findSubcellLocal(posVec, thisOctal, subcell)

                if (.not.thisOctal%hasChild(subcell)) then
                   if (thisOctal%inflow(subcell)) then
                      nHit = 0
                      do iRay = 1, nRay
                         call getRay(grid, thisOCtal, subcell, position, direction, &
                              ds(iRay), phi(iRay), i0(1:nRBBTrans,iRay), Hcol(iray), HeICol(iRay), HeIICol(iRay),&
                              nAtom, thisAtom, source, nSource, hitPhotosphere(iRay), sourceNumber(iray), &
                              cosTheta(iRay), weight(iRay), nRBBTrans, indexRBBTrans, indexAtom, nHatom, nHeIAtom, nHeIIatom, &
                              nfreq, freq, iCont(iray,1:nFreq))
                         if (hitPhotosphere(iray)) nHit = nHit + 1
                      enddo
                      iter = 0
                      popsConverged = .false.
                      thisOctal%newatomLevel(subcell,:, :) = thisOctal%atomLevel(subcell,:, :)
                      ne = thisOctal%ne(subcell)


                      do while (.not.popsConverged)
                         iter = iter + 1
                         oldpops = thisOctal%newatomLevel(subcell,1:nAtom,1:)
                         call calculateJbarCont(thisOctal, subcell, nAtom, thisAtom, nray, ds, source, nSource, &
                              hitPhotosphere, sourceNumber, freq, nfreq, &
                              iCont, jnuCont, cosTheta, weight)
                         do iRBB = 1, nRBBTrans
                            iTrans = indexRBBTrans(iRBB)
                            iAtom =  indexAtom(iRBB)
                            call calculateJbar(thisOctal, subcell, thisAtom(iAtom), nRay, ds(1:nRay), &
                                 phi(1:nRay), i0(iRBB,1:nRay), iTrans, thisOctal%jnu(subcell,iRBB), &
                                 thisOctal%newAtomLevel(subcell,iAtom,1:), &
                                 freq, nFreq, weight(1:nRay))
                         enddo
                         newpops = thisOctal%newatomLevel(subcell, 1:nAtom, 1:)
                         call solveLevels(thisOctal, subcell, newPops, &
                              thisOctal%jnu(subcell,1:nRBBTrans),  &
                              dble(thisOctal%temperature(subcell)), nAtom, thisAtom, ne, &
                              thisOctal%rho(subcell),&
                              jnuCont, freq, nfreq)

                        dPops = newPops - thisOctal%newAtomLevel(subcell,1:nAtom,:) 

                        thisOctal%newAtomLevel(subcell,1:nAtom,:)  = &
                             thisOctal%newAtomLevel(subcell,1:nAtom,:)  + underCorrect * dPops
                        where (abs(thisOctal%newAtomLevel(subcell,1:nAtom,:)) < 1.d-30)
                           thisOctal%newAtomLevel(subcell,1:nAtom,:) = 1.d-30
                        end where
                        
                        newNe = 0.d0
                        do iAtom = 1, nAtom
                           if (iAtom /= nAtom) then
                              if (thisAtom(iAtom)%nz /= thisAtom(iAtom+1)%nz) then
                                 newne =  newNe +  &
                                      SUM(thisOctal%newAtomLevel(subcell, iAtom, 1:thisAtom(iAtom)%nLevels-1)) &
                                      * dble(thisAtom(iAtom)%charge)
                                 newne = newne + thisOctal%newAtomLevel(subcell, iAtom, thisAtom(iAtom)%nLevels) &
                                      * dble((thisAtom(iAtom)%charge+1))
                              else
                                 newne =  newNe +  &
                                      SUM(thisOctal%newAtomLevel(subcell, iAtom, 1:thisAtom(iAtom)%nLevels-1)) &
                                      * dble(thisAtom(iAtom)%charge)
                              endif
                           else
                              newne =  newNe +  &
                                   SUM(thisOctal%newAtomLevel(subcell, iAtom, 1:thisAtom(iAtom)%nLevels-1)) &
                                   * dble(thisAtom(iAtom)%charge)
                              newne = newne + thisOctal%newAtomLevel(subcell, iAtom, thisAtom(iAtom)%nLevels) &
                                   * dble((thisAtom(iAtom)%charge+1))
                           endif
                        enddo

                        dNe = newne - Ne

                        ne = ne + undercorrect * dne

                        
                        if (debug) then
                           do iatom = 1, size(thisAtom)
                              write(*,*) "Atom: ",thisAtom(iatom)%name
                              write(*,*) "Number density: ",thisOctal%rho(subcell)*thisOctal%atomAbundance(subcell, iatom)
                              do i = 1, thisAtom(iatom)%nLevels-1
                                 nStar = boltzSahaGeneral(thisAtom(iAtom), 1, i, ne, &
                                      dble(thisOctal%temperature(subcell))) * &
                                      thisOctal%newAtomLevel(subcell, iatom, thisAtom(iAtom)%nLevels)
!                                 write(*,*) "nk",thisOctal%newAtomLevel(subcell, iatom, thisAtom(iAtom)%nLevels)
!                                 write(*,*) "ratio",boltzSahaGeneral(thisAtom(iAtom), 1, i, thisOctal%ne(subcell), &
!                                      dble(thisOctal%temperature(subcell)))
!                                 write(*,*) "temp",thisOctal%temperature(subcell)
!                                 write(*,*) "ne",thisOctal%ne(subcell)
                                 write(*,*) i,thisOctal%newAtomLevel(subcell,iatom,i),oldpops(iatom,i), &
                                      abs((thisOctal%newAtomLevel(subcell,iAtom,i)-max(oldpops(iAtom,i),1.d-20)) &
                                      / max(oldpops(iAtom,i),1.d-20)), thisOctal%newAtomLevel(subcell,iatom,i)/nstar

                              enddo
                           enddo
                           write(*,*) "Ne: ",ne,dne
                           write(*,*) "T: ",thisOctal%temperature(subcell)
                        endif
                         fac = -1.d30
                         where (oldPops == 0.d0)
                            oldPops = 1.d-20
                         end where

                         do iAtom = 1, nAtom

                            fac = max(fac,maxval(abs((thisOctal%newAtomLevel(subcell,iatom,1:thisAtom(iAtom)%nLevels-1) &
                                 - oldpops(iAtom,1:thisAtom(iAtom)%nLevels-1))/oldpops(iAtom,1:thisAtom(iAtom)%nLevels-1))))
                         enddo
                         if (debug) write(*,*) iter,fac
                         if (fac < 1.d-4) popsConverged = .true.
                         if (iter == maxIter) then
                            popsConverged = .true.
                            call writeWarning("Maximum number of iterations reached in pop solver")
                         endif
                      enddo
                      thisOctal%ne(subcell) = ne
                   endif


                endif

!                call locate(freq,nfreq,cspeed/6562.8d-8,ifreq)
!                nStar = boltzSahaGeneral(thisAtom(1), 1, 6, thisOctal%ne(subcell), &
!                     dble(thisOctal%temperature(subcell))) * &
!                     thisOctal%newAtomLevel(subcell, 1, thisAtom(1)%nLevels)
!                write(31,*) real(r*1.e10), real(thisOctal%ne(subcell)), real(thisOctal%newAtomLevel(subcell,1,1:6)),&
!                     real(jnuCont(ifreq)),real(nstar)

!             enddo
!             close(31)
!             stop

             enddo
          end do

!$MPI if (.not.blockHandout) exit blockloop
!$MPI end do blockLoop        
!$MPI end if ! (my_rank /= 0)




!$MPI     call MPI_BARRIER(MPI_COMM_WORLD, ierr) 
!$MPI       if(my_rank == 0) write(*,*) "Updating MPI grids"

!$MPI
!$MPI     ! have to send out the 'octalsBelongRank' array
!$MPI     call MPI_BCAST(octalsBelongRank,SIZE(octalsBelongRank),  &
!$MPI                    MPI_INTEGER, 0, MPI_COMM_WORLD, ierr)
!$MPI     call MPI_BARRIER(MPI_COMM_WORLD, ierr) 
!$MPI
!$MPI     call countVoxels(grid%octreeRoot,nOctal,nVoxels)
!$MPI     allocate(tArrayd(1:nVoxels))
!$MPI     allocate(tempArrayd(1:nVoxels))
!$MPI     tArrayd = 0.d0
!$MPI     tempArrayd = 0.d0
!$MPI     do iAtom = 1, nAtom
!$MPI       do i = 1, thisAtom(iAtom)%nLevels
!$MPI         tArrayd = 0.d0
!$MPI          call packAtomLevel(octalArray, nVoxels, tArrayd, octalsBelongRank, iAtom, i)
!$MPI          call MPI_ALLREDUCE(tArrayd,tempArrayd,nVoxels,MPI_DOUBLE_PRECISION,&
!$MPI            MPI_SUM,MPI_COMM_WORLD,ierr)
!$MPI            tArrayd = tempArrayd
!$MPI          call unpackAtomLevel(octalArray, nVoxels, tArrayd, octalsBelongRank, iAtom, i)
!$MPI       enddo
!$MPI     enddo
!$MPI     deallocate(tArrayd, tempArrayd)

!$MPI       if(my_rank == 0) write(*,*) "Done updating"


          maxFracChange = -1.d30
          call swapPops(grid%octreeRoot, maxFracChange)
          write(*,*) "Maximum fractional change this iteration",maxFracChange
          write(*,*) "Fractional change",maxFracChange,"tolerance",tolerance , &
               "fixed rays",fixedrays,"nray",nray

          !$MPI       if (my_rank == 0) &
          call writeAmrGrid("atom_tmp.grid",.false.,grid)


          if (maxFracChange < tolerance) then
             gridConverged = .true.
          endif



!$MPI       deallocate(octalsBelongRank)

          deallocate(ds, phi, i0, tau, sourceNumber, cosTheta, hitPhotosphere, &
               weight, hcol, heicol, heiicol, iCont)

          if (.not.gridConverged) then
             if (.not.fixedRays) nRay = nRay * 2
          endif
          if (nRay > maxRay) then
             nRay = maxRay
             call writeWarning("Maximum number of rays exceeded - capping")
          endif
       enddo
    enddo
    write(*,*) "ATOM loop done."
    stop
  end subroutine atomLoop

  recursive  subroutine  swapPops(thisOctal, maxFracChange)
    type(GRIDTYPE) :: grid
    type(MODELATOM) :: thisAtom
    type(octal), pointer   :: thisOctal
    type(octal), pointer  :: child 
    integer :: subcell, i, iUpper, iLower, j, iAtom
    real(double) :: maxFracChange, temp
  
    do subcell = 1, thisOctal%maxChildren
       if (thisOctal%hasChild(subcell)) then
          ! find the child
          do i = 1, thisOctal%nChildren, 1
             if (thisOctal%indexChild(i) == subcell) then
                child => thisOctal%child(i)
                call swapPops(child, maxFracChange)
                exit
             end if
          end do
       else
          do iAtom = 1, size(thisOctal%newAtomLevel,2)
             do j = 1 , 6
                if (thisOctal%atomLevel(subcell,iAtom,j) /= 0.d0) then
                   temp = abs((thisOctal%newatomLevel(subcell,iAtom,j) - &
                        thisOctal%atomLevel(subcell,iAtom,j)) / &
                        thisOctal%atomLevel(subcell,iAtom,j))
                   if (temp > maxFracChange) then
                      maxFracChange = temp
                   endif
                endif
             enddo
          enddo
          thisOctal%atomLevel(subcell,:,:) = &
               thisOctal%newatomLevel(subcell,:,:)
       endif
    enddo
  end subroutine swapPops

  recursive  subroutine  calcEtaLine(thisOctal, thisAtom, nAtom, iAtom, iTrans)
    type(GRIDTYPE) :: grid
    type(MODELATOM) :: thisAtom(:)
    integer :: nAtom
    integer :: iTrans
    type(octal), pointer   :: thisOctal
    type(octal), pointer  :: child 
    integer :: subcell, i, iUpper,  j, iAtom
    real(double) :: a, bul, blu
    real(double) :: etaLine
  
    do subcell = 1, thisOctal%maxChildren
       if (thisOctal%hasChild(subcell)) then
          ! find the child
          do i = 1, thisOctal%nChildren, 1
             if (thisOctal%indexChild(i) == subcell) then
                child => thisOctal%child(i)
                call calcEtaLine(child, thisAtom, nAtom, iAtom, iTrans)
                exit
             end if
          end do
       else

          call returnEinsteinCoeffs(thisAtom(iatom), iTrans, a, Bul, Blu)
          iUpper = thisAtom(iatom)%iUpper(iTrans)
          etaLine = hCgs * a * thisAtom(iatom)%transFreq(iTrans)
          etaLine = etaLine * thisOctal%atomLevel(subcell, iAtom,iUpper)
	  
          thisOctal%etaLine(subcell) = etaLine 
          
       endif
    enddo
  end subroutine calcEtaLine

  recursive subroutine  allocateLevels(grid, thisOctal, nAtom, thisAtom, nRBBTrans)
    type(GRIDTYPE) :: grid
    type(MODELATOM) :: thisAtom(:)
    type(octal), pointer   :: thisOctal
    type(octal), pointer  :: child 
    integer :: subcell, i, iUpper, iLower
    real(double) :: etaLine
    integer :: nAtom
    integer :: nRBBTrans
    integer :: iatom
  do subcell = 1, thisOctal%maxChildren
       if (thisOctal%hasChild(subcell)) then
          ! find the child
          do i = 1, thisOctal%nChildren, 1
             if (thisOctal%indexChild(i) == subcell) then
                child => thisOctal%child(i)
                call allocateLevels(grid, child, nAtom, thisAtom, nRBBTrans)
                exit
             end if
          end do
       else

          if (.not.associated(thisOctal%atomLevel)) then
             allocate(thisOctal%atomLevel(1:thisOctal%maxChildren, 1:nAtom, 1:maxval(thisAtom(1:nAtom)%nLevels)))
             thisOctal%atomLevel = 1.d-30
          endif

          if (.not.associated(thisOctal%newatomLevel)) then
             allocate(thisOctal%newatomLevel(1:thisOctal%maxChildren, 1:nAtom, 1:maxval(thisAtom(1:nAtom)%nLevels)))
             thisOctal%newatomLevel = 1.d-30
          endif

          if (.not.associated(thisOctal%jnu)) then
             allocate(thisOctal%jnu(1:thisOctal%maxChildren, 1:nRBBTrans))
             thisOctal%jnu = 1.d-30
          endif
       endif
    enddo
  end subroutine allocateLevels
  

  subroutine randomRayDirection(probTowardsSource, point, source, nSource, direction, weight)
    type(OCTALVECTOR) :: point, direction, toStar
    type(SOURCETYPE) :: source(:)
    integer :: nSource
    real(double) :: probTowardsSource, weight
    integer :: i
    real(double) :: chanceSource
    real(double) :: omegaSubtendedBySource
    real(double) :: theta, dOmega, r, cosTheta
    logical :: hitCore
    integer :: nBug

    omegaSubtendedBySource = 0.d0
    do i = 1 , nSource
       theta = asin(source(i)%radius/modulus(point-source(i)%position))
       domega = twoPi * (1.d0 - cos(theta))
       omegaSubtendedBySource = omegaSubtendedbySource + dOmega
    enddo

    chanceSource = omegaSubtendedBySource / fourPi

    weight = 1.d0
 
    call random_number(r)

    if (r < probTowardsSource) then
       weight = chanceSource/probTowardsSource
       call random_number(r)
       i = int(r*real(nSource))+1
       toStar = source(i)%position - point
       call normalize(toStar)
       theta = asin(min(1.d0, max(-1.d0,source(i)%radius/modulus(point-source(i)%position))))
       cosTheta = cos(theta)
       hitCore = .false.
       nbug = 0
       do while(.not.hitCore)
          direction = randomUnitVector()
          if (acos(direction.dot.toStar) < theta) hitCore = .true.
          nbug = nbug  + 1
          if (nbug > 10000000) then
             write(*,*) "bug in direction to star"
             direction = toStar
          endif
       enddo
    else
       weight = (1.d0-chanceSource)/(1.d0-probTowardsSource)
       hitCore = .true.
       do while(hitCore)
          direction = randomUnitVector()
          do i = 1, nSource
             call distanceToSource(source, i, point, direction, hitCore, r)
          enddo
       end do
    endif
  end subroutine randomRayDirection



  function intensityAlongRay(position, direction, grid, thisAtom, nAtom, iAtom, iTrans, deltaV, source, nSource) result (i0)
    use input_variables, only : opticallyThickContinuum
    type(OCTALVECTOR) :: position, direction, startPosition, pvec
    type(GRIDTYPE) :: grid
    integer :: nSource
    type(SOURCETYPE) :: source(:)
    integer :: iAtom, nAtom
    type(MODELATOM) :: thisAtom(:)
    real(double) :: disttoGrid
    integer :: itrans
    real(double) :: totDist
    logical :: hitSource
    real(double) :: i0
    type(OCTAL), pointer :: thisOctal, startOctal, fromOctal
    integer :: fromSubcell
    integer :: subcell
    real(double) :: ds, phi, r, costheta
    type(OCTALVECTOR) :: currentPosition, thisPosition, thisVel
    type(OCTALVECTOR) :: rayVel, startVel, endVel, endPosition
    real(double) :: alphanu, snu, jnu
    integer :: iLower , iUpper
    real(double) :: dv, deltaV
    integer :: i, icount
    real(double) :: distArray(200), tval
    integer :: nTau
    real(double) :: nLower, nUpper
    real(double) :: dTau, etaline, didtau, tau
    real(double) :: intensityIntegral
    real(double) :: dvAcrossCell
    real(double) :: dv1, dv2
    real(double) :: a, bul, blu
    integer :: nHatom,nHeIAtom, nHeIIAtom
    real(double) ::  dTauCont, HCol, HeICol, HeIICol
    real(double) :: distToSource
    integer :: sourcenumber
    real :: xH, XheI, xHeII
    logical :: firstSubcell
    logical :: endLoopAtPhotosphere


    nHAtom = 0
    nHeIAtom = 0
    nHeIIAtom = 0
    do i = 1, nAtom
       if (thisAtom(i)%name == "HI") nHatom = i
       if (thisAtom(i)%name == "HeI") nHeIatom = i
       if (thisAtom(i)%name == "HeII") nHeIIatom = i
    enddo

    distToGrid = distanceToGridFromOutside(grid, position, direction)

    if (distToGrid > 1.e29) then
       write(*,*) "ray does not intersect grid",position,direction
       i0 = 0.d0
       goto 666
    endif

    iUpper = thisAtom(iAtom)%iUpper(iTrans)
    iLower = thisAtom(iAtom)%iLower(iTrans)

    currentPosition = position + (distToGrid + 1.d-3*grid%halfSmallestSubcell) * direction



    totDist = 0.d0
    call distanceToSource(source, nSource, currentposition, direction, hitSource, disttoSource, sourcenumber)

   if (hitSource) then
      pVec = (currentposition + (direction * distToSource) - source(sourceNumber)%position)
      call normalize(pVec)
      cosTheta = -1.d0*(pVec.dot.direction)
   endif



!    write(*,*) "currentposition",sqrt(currentPosition%x**2+currentPosition%y**2),currentPosition%z, &
!         inOctal(grid%octreeRoot, currentPosition),distTogrid
    i0 = 0.d0
    intensityIntegral = 0.0
    tau = 0.d0
    rayVel = OCTALVECTOR(0.d0, 0.d0, 0.d0)

    thisOctal => grid%octreeRoot
    icount = 0
    endLoopAtPhotosphere = .false.
    do while(inOctal(grid%octreeRoot, currentPosition).and.(.not.endloopAtPhotosphere))
       icount = icount + 1 

       call findSubcellLocal(currentPosition, thisOctal, subcell)
       call distanceToCellBoundary(grid, currentPosition, direction, tVal, sOctal=thisOctal)


       if ((totDist + tval) > distTosource) then
          tVal = distToSource - totDist
          endLoopAtPhotosphere = .true.
       endif


       startVel = amrGridVelocity(grid%octreeRoot, currentPosition, startOctal = thisOctal, actualSubcell = subcell) 
       endPosition = currentPosition + tval * direction
       endVel = amrGridVelocity(grid%octreeRoot, endPosition)

       dvAcrossCell = ((startVel - rayVel).dot.direction) - ((endVel - rayVel).dot.direction)


       dvAcrossCell = abs(dvAcrossCell / thisOctal%microturb(subcell))

       dv1 = abs(deltaV - (startVel .dot. direction))
       dv2 = abs(deltaV - (endVel .dot. direction))

       nTau = 2
!       if (dvacrosscell > 10.d0) then
!          write(*,*) "dvacrosscell",dvacrosscell,dv1*cspeed/1.d5,dv2*cspeed/1.d5
!          write(*,*) modulus(startVel)*cspeed/1.d5,modulus(endVel)*cspeed/1.d5, modulus(thisOctal%velocity(subcell))*cspeed/1.d5
!       endif

       if (max(dv1,dv2) < 4.d0*thisOctal%microturb(subcell)) then
          nTau = min(max(2, nint(dvAcrossCell * 20.d0)),200)
       endif

       distArray(1) = 0.d0
       do i = 2, nTau

          distArray(i) = tval * dble(i-1)/dble(nTau-1)

          startOctal => thisOctal
          thisPosition = currentPosition + distArray(i)*direction
          thisVel = amrGridVelocity(grid%octreeRoot, thisPosition, startOctal = startOctal, actualSubcell = subcell) 
          thisVel= thisVel - rayVel


          dv = (thisVel .dot. direction) + deltaV

          call returnEinsteinCoeffs(thisAtom(iAtom), iTrans, a, Bul, Blu)


          alphanu = (hCgs*thisAtom(iAtom)%transFreq(iTrans)/fourPi) * &
               phiProf(dv, thisOctal%microturb(subcell))/thisAtom(iAtom)%transFreq(iTrans)


          iUpper = thisAtom(iAtom)%iUpper(iTrans)
          iLower = thisAtom(iAtom)%iLower(iTrans)

          nLower = thisOctal%atomLevel(subcell,iAtom, iLower)
          nUpper = thisOctal%atomLevel(subcell,iAtom, iUpper)
          alphanu = alphanu * (nLower * Blu - nUpper * Bul)

!          write(*,*) modulus(currentPosition),nUpper

          dTau = alphaNu *  (distArray(i)-distArray(i-1)) * 1.d10


          if (opticallyThickContinuum) then
             dTauCont = bfOpacity(thisAtom(iAtom)%transFreq(iTrans), nAtom, thisAtom, thisOctal%atomLevel(subcell,:,:)) &
                  *  (distArray(i)-distArray(i-1)) * 1.d10
          dTau = dTau + dTauCont
       endif

          etaLine = hCgs * a * thisAtom(iAtom)%transFreq(iTrans)
          etaLine = etaLine * thisOctal%atomLevel(subcell, iAtom, iUpper)
          jnu = (etaLine/fourPi) * phiProf(dv, thisOctal%microturb(subcell))/thisAtom(iAtom)%transFreq(iTrans)

! add continuous bf and ff emissivity of hydrogen
          
          jnu = jnu +  bfEmissivity(thisAtom(iatom)%transFreq(iTrans), nAtom, thisAtom, &
               thisOctal%atomLevel(subcell,:,:), thisOctal%ne(subcell), &
                  dble(thisOctal%temperature(subcell)))/fourPi


          if (alphanu /= 0.d0) then
             snu = jnu/alphanu
          else
             snu = tiny(snu)
          endif

          i0 = i0 +  exp(-tau) * (1.d0-exp(-dtau))*snu
          tau = tau + dtau
!          write(*,*) "i0",i0,"tau",tau,"snu",snu
       enddo
       currentPosition = currentPosition + (distArray(ntau)+1.d-3*grid%halfSmallestSubcell) * direction
       totdist = totdist + (distArray(ntau)+1.d-3*grid%halfSmallestSubcell)
    enddo

    if (endLoopAtPhotosphere) then
!       write(*,*) "i0",i0,i_nu(source(sourceNumber), thisAtom(iATom)%transFreq(iTrans))*cosTheta*exp(-tau),tau
!       write(*,*) "pos",modulus(currentPosition)/source(1)%radius
       i0 = i0 + i_nu(source(sourceNumber), thisAtom(iATom)%transFreq(iTrans))*cosTheta*exp(-tau)
    endif

!    write(*,*) "tau",tau,"deltav",deltaV*cspeed/1.d5

666 continue 

  end function intensityAlongRay

  
  subroutine calculateAtomSpectrum(grid, thisAtom, nAtom, iAtom, iTrans, viewVec, distance, source, nsource)
!$MPI    include 'mpif.h'

    type(GRIDTYPE) :: grid
    type(MODELATOM) :: thisAtom(:)
    integer :: nSource
    type(SOURCETYPE) :: source(:)
    integer :: nAtom, iAtom
    real(double) :: distance
    integer :: itrans
    integer :: nRay
    type(OCTALVECTOR) :: rayPosition(5000)
    real(double) :: da(5000), dOmega(5000)
    type(OCTALVECTOR) :: viewVec
    real(double) :: deltaV
    integer :: iv, iray
    integer :: nLambda
    real(double) :: flux, i0
    real(double), allocatable :: vArray(:), spec(:), tempArray(:)
    integer :: iv1, iv2, i
!$MPI    ! For MPI implementations
!$MPI    integer       ::   my_rank        ! my processor rank
!$MPI    integer       ::   np             ! The number of processes
!$MPI    integer       ::   ierr           ! error flag
!$MPI    logical       ::   rankComplete


!$MPI    ! FOR MPI IMPLEMENTATION=======================================================
!$MPI    !  Get my process rank # 
!$MPI    call MPI_COMM_RANK(MPI_COMM_WORLD, my_rank, ierr)
!$MPI  
!$MPI    ! Find the total # of precessor being used in this run
!$MPI    call MPI_COMM_SIZE(MPI_COMM_WORLD, np, ierr)


    call calcEtaLine(grid%octreeRoot, thisAtom, nAtom, iAtom, iTrans)
    call plot_AMR_values(grid, "etaLine", "x-z", 0.,  &
         "etaline.ps/vcps", .true., .false.)


    call createRayGrid(nRay, rayPosition, da, dOmega, viewVec, distance, grid)

    nLambda = 100

    iv1 = 1
    iv2 = nLambda
 
!$MPI    iv1 = (my_rank) * (nLambda / (np)) + 1
!$MPI    iv2 = (my_rank+1) * (nLambda / (np))
!$MPI    if (my_rank == (np-1)) iv2 = nLambda


    allocate(spec(1:nLambda), vArray(1:nLambda))
    spec = 0.d0
    do iv = 1, nLambda
       vArray(iv) = 2000.e5/cspeed * (2.d0*dble(iv-1)/dble(nLambda-1)-1.d0)
    enddo
    do iv = iv1, iv2
       deltaV  = vArray(iv)
       do iRay = 1, nRay
          i0 = intensityAlongRay(rayposition(iRay), viewvec, grid, thisAtom, nAtom, iAtom, iTrans, -deltaV, source, nSource) !minus v 
          spec(iv) = spec(iv) + i0 * domega(iRay) 
       enddo
    enddo
!$MPI     call MPI_BARRIER(MPI_COMM_WORLD, ierr) 
!$MPI     allocate(tempArray(1:nLambda))
!$MPI       call MPI_ALLREDUCE(spec,tempArray,nLambda,MPI_DOUBLE_PRECISION,&
!$MPI           MPI_SUM,MPI_COMM_WORLD,ierr)
!$MPI    spec(1:nLambda) = tempArray(1:nLambda)
!$MPI     deallocate(tempArray)

!$MPI    if (my_rank == 0) then
    open(42, file="spectrum.dat",status="unknown",form="formatted")
    do i = 1, nLambda
       write(42, *) vArray(i)*cspeed/1.d5, spec(i)
    enddo
    close(42)
!$MPI endif
    deallocate(vArray, spec)
  end subroutine calculateAtomSpectrum


  subroutine createRayGrid(nRay, rayPosition, da, dOmega, viewVec, distance, grid)
    type(GRIDTYPE) :: grid
    integer :: nRay
    type(OCTALVECTOR) :: rayPosition(:), thisPos, viewVec, xProj,yProj
    real(double) :: da(:), dOmega(:), distance
    real(double), allocatable :: rGrid(:), dr(:), phigrid(:), dphi(:)
    real(double) :: rMax
    integer :: nr, nphi, ir, iphi
    real(double) :: r1 , r2, phi1, phi2, phiOffset
    real(double) :: xPos, yPos, zPos, cosInc, azimuth
    
    rmax = 100.*rsol/1.d10
    nr = 100
    nphi = 20
    nray = 0

    allocate(rGrid(1:nr), dr(1:nr), phiGrid(1:nPhi), dphi(1:nPhi))

    do ir = 1, nr
       r1 = log10(rmax) * dble(ir-1)/dble(nr)
       r2 = log10(rmax) * dble(ir)/dble(nr)
       r1 = 10.d0**r1
       r2 = 10.d0**r2
!       r1 = rMax * dble(ir-1)/dble(nr)
!       r2 = rMax * dble(ir)/dble(nr)
       rgrid(ir) = 0.5d0 * (r1 + r2)
       dr(ir) = r2 - r1
    enddo
    do iphi = 1, nPhi
       phi1 = twoPi * dble(iphi-1)/dble(nPhi)
       phi2 = twoPi * dble(iphi)/dble(nPhi)
       phiGrid(iPhi) = 0.5d0 * (phi1 + phi2)
       dphi(iPhi) = phi2 - phi1
    enddo

    do ir = 1, nr
       r1 = rGrid(ir)
       call random_number(phiOffset)
       phiOffset = phiOffset * dphi(1)
       do iPhi = 1, nPhi
          phi1 = phiGrid(iPhi) + phiOffset
          if (phi1 > twoPi) phi1 = phi1 - twoPi

          xPos = r1 * sin(phi1)
          yPos = 0.d0
          zPos = r1 * cos(phi1)

          xProj =  OCTALVECTOR(0.d0, 0.d0, 1.d0)  .cross. viewVec
          call normalize(xProj)
          yProj = viewVec .cross. xProj
         call normalize(yProj)

          nRay = nRay + 1
         rayPosition(nray) =  (xPos * xProj) + (zPos * yProj)
         rayposition(nray) = rayPosition(nRay) + ((-1.d0*grid%octreeRoot%subcellSize*10.d0) * viewVec)

          da(nRay) = pi*( (r1 + dr(ir)/2.d0)**2 - (r1 - dr(ir)/2.d0)**2) * dphi(iPhi)/twoPi
          dOmega(nRay) = da(nRay) / (fourPi * distance**2)
       enddo
    enddo
  end subroutine createRayGrid


!$MPI      subroutine packAtomLevel(octalArray, nTemps, tArray, octalsBelongRank, iAtom, iLevel)
!$MPI    include 'mpif.h'
!$MPI        type(OCTALWRAPPER) :: octalArray(:)
!$MPI        integer :: octalsBelongRank(:)
!$MPI        integer :: nTemps
!$MPI        real(double) :: tArray(:)
!$MPI        integer :: iOctal, iSubcell, my_rank, ierr, iAtom
!$MPI        integer :: iLevel
!$MPI        type(OCTAL), pointer :: thisOctal
!$MPI
!$MPI       call MPI_COMM_RANK(MPI_COMM_WORLD, my_rank, ierr)
!$MPI       !
!$MPI       ! Update the edens values of grid computed by all processors.
!$MPI       !
!$MPI       nTemps = 0
!$MPI       do iOctal = 1, SIZE(octalArray)
!$MPI
!$MPI          thisOctal => octalArray(iOctal)%content
!$MPI          
!$MPI          do iSubcell = 1, thisOctal%maxChildren
!$MPI              if (.not.thisOctal%hasChild(iSubcell)) then
!$MPI                 nTemps = nTemps + 1
!$MPI                 if (octalsBelongRank(iOctal) == my_rank) then
!$MPI                   tArray(nTemps) = thisOctal%newAtomLevel(isubcell, iAtom, iLevel)
!$MPI                 else 
!$MPI                   tArray(nTemps) = 0.d0
!$MPI                 endif
!$MPI              endif
!$MPI          end do
!$MPI       end do
!$MPI     end subroutine packAtomLevel

!$MPI      subroutine unpackAtomLevel(octalArray, nTemps, tArray, octalsBelongRank, iAtom, iLevel)
!$MPI    include 'mpif.h'
!$MPI        type(OCTALWRAPPER) :: octalArray(:)
!$MPI        integer :: octalsBelongRank(:)
!$MPI        integer :: nTemps
!$MPI        real(double) :: tArray(:)
!$MPI        integer :: iOctal, iSubcell, my_rank, ierr, iAtom
!$MPI        integer :: iLevel
!$MPI        type(OCTAL), pointer :: thisOctal
!$MPI
!$MPI       call MPI_COMM_RANK(MPI_COMM_WORLD, my_rank, ierr)
!$MPI       !
!$MPI       ! Update the edens values of grid computed by all processors.
!$MPI       !
!$MPI       nTemps = 0
!$MPI       do iOctal = 1, SIZE(octalArray)
!$MPI
!$MPI          thisOctal => octalArray(iOctal)%content
!$MPI          
!$MPI          do iSubcell = 1, thisOctal%maxChildren
!$MPI              if (.not.thisOctal%hasChild(iSubcell)) then
!$MPI                 nTemps = nTemps + 1
!$MPI                 thisOctal%newAtomLevel(isubcell, iAtom, iLevel) = tArray(nTemps) 
!$MPI              endif
!$MPI          end do
!$MPI       end do
!$MPI     end subroutine unpackAtomLevel

end module cmf_mod

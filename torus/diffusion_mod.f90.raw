! this is a module to apply the diffusion approximation to
! the very optically thick central regions of circumstellar stellar discs.


module diffusion_mod

use constants_mod
use gridtype_mod
use amr_mod
use vector_mod
use messages_mod
use grid_mod
use parallel_mod

implicit none


contains




  subroutine solveDiffusion(grid, zArray, xPos, temperature, rho,  diffApprox, nz, ok, debugoutput)
    implicit none
    type(GRIDTYPE) :: grid
    type(OCTAL), pointer :: thisOctal
    integer :: subcell
    integer :: nz
    real(double) :: zArray(*)
    real :: xPos
    logical :: debugoutput
    type(OCTALVECTOR) :: octVec
    real :: temperature(*)
    real(double) :: rho(*)
    real :: flux(1000)
    real :: jd(1000), kappap(1000)
    real(double) :: kappa_ross(1000)
    real :: tau(1000)
    logical :: diffApprox(*)
    real(double) :: dTdZ(1000), newTemperature(1000), frac(1000)
    real :: oldVal, thisVal
    real(double) :: kappa
    integer :: i, nIter, j
    logical :: converged
    real(double) :: tReal(1000),zReal(1000),rhoReal(1000)
    integer :: nReal
    real :: bigJ
    real :: dtdz1, dfdz(1000)
    real(double) :: lambdad(1000),gammad(1000),dfraddz(1000)
    integer :: istart
    real :: safetemp
    real(double) :: dJdz(1000)
    real :: nextJd, nextfd, nextfdiff
    real :: t0, t1, fac
    real(double) :: gammairr(1000),frad(1000)
    real(double) :: fd(1000), dfddz(1000), firr(1000)
    real(double) :: jirr(1000)
    real :: influx
    logical :: ok
    
    ok = .true.


! now take the first nreal points in the temperature/z run
! which correspond to temperatures that have be calculated
! via the lucy algorithm


    nReal = 0
    do i = 1, nz
       if (.not.diffApprox(i)) then
          nReal = nReal + 1
          tReal(nReal) = temperature(i)
          zReal(nReal) = zArray(i)
          rhoReal(nReal) = rho(i)
       else
          iStart = i ! first element of diffusion array
          exit
       endif
    enddo
    


 
    converged = .false.

!    do i = 1, iStart-1
!       octVec = VECTOR(xPos, 0., zArray(i))
!       call amrGridValues(grid%octreeRoot, octVec, foundOctal=thisOctal, &
!            foundSubcell=subcell, rosselandKappa=kappa, grid=grid)
!       if (thisOctal%undersampled(subcell)) then
!          ok = .false.
!          goto 666
!       endif
!    enddo

    

!    zarray(nz+1) = 0.
!    t1 = treal(nreal)
!    t0 = 0.99 * t1
!    fac = log(t1/t0)/abs(zreal(nreal))
!    do i = iStart,nz+1
!       temperature(i) = t0 * exp(fac*abs(zArray(i)))
!       dtdz(i) = t0 * fac *  exp(fac*abs(zArray(i))) / 1.e10
!    enddo

    rho(nz+1) = rho(nz)

    
    octVec = VECTOR(xPos, 0., zArray(istart))
    call amrGridValues(grid%octreeRoot, octVec, foundOctal=thisOctal, &
            foundSubcell=subcell,  grid=grid)

    temperature(istart:nz) = temperature(istart-1)
    goto 666
       
    if (thisOctal%nDiffusion(subcell)  == 0.) then
       goto 666
    endif

    inFlux = thisOctal%incidentflux(subcell)


    octVec = VECTOR(xPos, 0., zArray(istart-1))
    call amrGridValues(grid%octreeRoot, octVec, foundOctal=thisOctal, &
         foundSubcell=subcell, rosselandKappa=kappa, grid=grid)

    firr(istart-1) = -inFlux

    nIter = 0
    do while(.not.converged)

       do i = 1, nz+1
          newTemperature(i) = temperature(i)
       enddo

       
       ! first calculate the opacities

       do i = iStart-1, nz+1
          octVec = VECTOR(xPos, 0., zArray(i))
          call amrGridValues(grid%octreeRoot, octVec, foundOctal=thisOctal, &
               foundSubcell=subcell, rosselandKappa=kappa_ross(i), kappap=kappap(i), grid=grid, &
               atthistemperature=real(newtemperature(i)))
       enddo

       tau(istart-1) = 0.

       ! first tau is from edge of diffusion zone to first cell within diffusion zone

       tau(istart) = kappa_ross(istart) * rho(istart) * 0.5 * abs(zArray(istart)-zArray(istart-1)) * 1.e10
       do i = istart+1, nz
          tau(i) = tau(i-1) + kappa_ross(i) *  rho(i) * abs(zArray(i)-zArray(i-1)) * 1.e10
       enddo
       do i = istart-1, nz
          firr(i) = -inFlux * exp(-tau(i))
          jirr(i) = influx * exp(-tau(i)) / fourPi
       enddo

       
       do i = iStart-1, nz
          gammairr(i) = fourPi * kappaP(i) * rho(i) * jirr(i)
       enddo
       

       fd(istart-1) = -firr(istart-1)
       frad(iStart-1) = firr(iStart-1) + fd(iStart-1)
       jd(istart-1) = (stefanBoltz * temperature(istart-1)**4 / pi) - jirr(istart-1)
       djdz(istart-1) = (3./fourPi) * kappa_ross(istart-1) * rho(istart-1) * fd(istart-1)
       lambdad(istart-1) = fourPi * kappap(istart-1)*rho(istart-1)*(stefanBoltz*newtemperature(istart-1)**4 /pi)
       gammad(istart-1) = fourPi * kappap(istart-1)*rho(istart-1)*jd(istart-1)
       dfddz(iStart-1) = lambdad(istart-1) - gammad(istart-1) -gammairr(istart-1)
       zArray(nz+1) = 0.
!       if (debugoutput) write(*,'(i3,8a12)') 0,"z","t","dfddz","fd","firr","jd","djdz","jdiff"
        i = istart-1
!        if (debugoutput) write(*,'(i3,1p,8e12.3)') &
!             i, zArray(i), newtemperature(i), dfddz(i), fd(i), firr(i), jd(i), djdz(i), jirr(i)
       do i = iStart, nz

          
          fd(i) = -firr(i)
          jd(i) = jd(i-1) + djdz(i-1)  * (zArray(i)-zArray(i-1)) * 1.e10             

          newTemperature(i) = (pi*(jd(i) + jirr(i))/stefanBoltz)
          if (newtemperature(i) > 0.) then
             newtemperature(i) = newTemperature(i)**0.25
!             if (newTemperature(i) < 50.) then
!                temperature(istart:nz) = temperature(istart-1)
!                goto 666
!             endif
          else
             temperature(istart:nz) = temperature(istart-1)
             goto 666
          endif

          lambdad(i) = fourPi * kappap(i)*rho(i)*(stefanBoltz*newtemperature(i)**4 /pi)
          gammad(i) = fourPi * kappap(i)*rho(i)*jd(i)
          dfddz(i) = lambdad(i) - gammad(i) - gammairr(i)
          djdz(i) = (3./fourPi) * kappa_ross(i) * rho(i) * fd(i)
!          if (debugoutput) &
!               write(*,'(i3,1p,8e12.3)') i, zArray(i), newtemperature(i), dfddz(i), fd(i), firr(i), jd(i), djdz(i), jirr(i)
       enddo

555 continue
       temperature(1:nz) = newTemperature(1:nz)

       do i = nz - 1, istart-1
          dtdz(i) = (temperature(i+1)-temperature(i))/(zArray(i+1)-Zarray(i)) / 1.e10
       enddo


       nIter = nIter + 1
       if (nIter > 3) then
          converged = .true.
!          stop
       endif
    enddo

666 continue

  end subroutine solveDiffusion

  subroutine throughoutMidplaneDiff(grid, epsoverdt, debugoutput)

    type(GRIDTYPE) :: grid
    real(double),allocatable :: zAxis1(:), subcellsize(:)
    real,allocatable :: temperature1(:)
    real(double),allocatable ::  rho(:) 
    real(double),allocatable :: zAxis2(:)
    real, allocatable ::  temperature2(:)
    integer :: nz1, nz2
    real(oct) :: epsOverdt
    real :: xpos, ypos, radius, drho, smallestSubcell
    logical, allocatable :: diffApprox(:)
    logical :: converged, debugoutput
    real(double), allocatable :: xAxis(:)
    integer :: nx, i, j
    real :: flux
    logical :: ok1, ok2
    integer :: nOctals,nCells

    if (grid%octreeRoot%threed) then
       write(*,*) "Finding vertical temperature runs in diffusion zone."
       converged = .false.
       do while(.not.converged)
          converged = .true.
          call findVerticalTempDiffusion(grid%octreeRoot, grid, converged)
       enddo
       write(*,*) "Done."
       goto 666
    endif


    call countVoxels(Grid%octreeRoot,nOctals,nCells)

    allocate(zAxis1(nCells))
    allocate(subcellSize(nCells))
    allocate(temperature1(nCells))
    allocate(rho(ncells))
    allocate(zAxis2(ncells))
    allocate(temperature2(nCells))
    allocate(xAxis(ncells))
    allocate(diffApprox(ncells))

    call calcIncidentFlux(grid, epsoverdt)

    call copytemperaturetoChiline(grid%octreeRoot)


    nx = 0
    call getxValuesdiff(grid%octreeRoot,nx,xAxis)
    call stripSimilarValues(xAxis,nx,1.d-5*grid%halfSmallestSubcell)
    xAxis(1:nx) = xAxis(1:nx) + 1.d-5*grid%halfSmallestSubcell
    xPos = grid%halfSmallestSubcell - grid%octreeRoot%subcellSize
    smallestSubcell = 2. * grid%halfSmallestSubcell
    
    xPos = grid%halfSmallestSubcell
    yPos = 0.

!    call locate(xaxis, nx, 14.*rsol/1.e10, j)
!    write(*,*) "Solving from x=2*rinner only!!!!!!!!!!!!!!!!!!"
    j = 1

    do i = j, nx
       radius = xAxis(i)
       xPos = xAxis(i)

       ok1 = .false.
       ok2 = .false.

       call getTemperatureDensityRunDiff(grid, zAxis1, subcellsize, rho, temperature1, diffApprox, xPos, yPos, nz1, -1.d0)

       if (nz1 > 1) then
          call solveDiffusion(grid, zAxis1, xPos, temperature1, rho, diffapprox, nz1, ok1, debugoutput)
       endif

       call getTemperatureDensityRunDiff(grid, zAxis2, subcellsize, rho, temperature2, diffApprox, xPos, yPos, nz2, +1.d0)

       if (nz2 > 1) then
          call solveDiffusion(grid, zAxis2, xPos, temperature2, rho, diffapprox, nz2, ok2, debugoutput)
       endif
 
       if (ok1.and.ok2) then
          call combineRuns(zAxis1, temperature1,  nz1, zAxis2, temperature2, nz2)
          call putTemperatureRunDiff(grid, zAxis1, temperature1, nz1, xPos, yPos, -1.d0)
          call putTemperatureRunDiff(grid, zAxis2, temperature2, nz2, xPos, yPos, +1.d0)
       endif


    enddo

    call copyChilineTotemperature(grid%octreeRoot)


    deallocate(diffApprox)
    deallocate(zAxis1)
    deallocate(subcellSize)
    deallocate(temperature1)
    deallocate(rho)
    deallocate(zAxis2)
    deallocate(temperature2)
    deallocate(xAxis)
666 continue
  end subroutine throughoutMidplaneDiff

  subroutine combineRuns(x1, y1, n1, x2, y2, n2)
    integer :: n1, n2
    real(double) :: x1(:), x2(:)
    real :: y1(:), y2(:)
    real :: yt1(10000), yt2(10000), yt
    integer :: i, j
    real(double) :: swap, t
    
    
    do i = 1, n1/2
       swap = x1(i)
       x1(i) = x1(n1-i+1)
       x1(n1-i+1) = swap
       swap = y1(i)
       y1(i) = y1(n1-i+1)
       y1(n1-i+1) = swap
    enddo
    


    do i = 1, n2/2
       swap = x2(i)
       x2(i) = x2(n2-i+1)
       x2(n2-i+1) = swap
       swap = y2(i)
       y2(i) = y2(n2-i+1)
       y2(n2-i+1) = swap
    enddo

    do i = 1, n1
       call locate(x2, n2, x1(i), j)
       t = (x1(i)-x2(j))/(x2(j+1)-x2(j))
       yt = y2(j) + t * y2(j+1)
       yt1(i) = 0.5*(y1(i)+ yt)
    enddo
    do i = 1, n2
       call locate(x1, n1, x2(i), j)
       t = (x2(i)-x1(j))/(x1(j+1)-x1(j))
       yt = y1(j) + t * y1(j+1)
       yt2(i) = 0.5*(y2(i)+ yt)
    enddo
    y1(1:n1) = yt1(1:n1)
    y2(1:n2) = yt2(1:n2)
  end subroutine combineRuns

  subroutine getTemperatureDensityRunDiff(grid, zAxis, subcellsize, rho, temperature, diffApprox, xPos, yPos, nz, direction)
    type(GRIDTYPE) :: grid
    type(octal), pointer   :: thisOctal
    integer :: nz
    real(double) :: rho(*)
    real :: temperature(*)
    real(double) :: zAxis(*), subcellsize(*)
    logical :: diffApprox(*)
    real :: xPos, yPos
    integer :: subcell
    real(double) :: rhotemp
    real :: temptemp
    real(double) :: direction
    type(OCTALVECTOR) :: currentPos, temp
    real :: halfSmallestSubcell
    logical :: someDiffusion
    integer :: i

    nz = 0
    halfSmallestSubcell = grid%halfSmallestSubcell

    currentPos = OCTALVECTOR(xPos, yPos, -1.*direction*grid%ocTreeRoot%subcellsize)

    do while((-1.*direction*currentPos%z) > 0. )
       call amrGridValues(grid%octreeRoot, currentPos, foundOctal=thisOctal, &
            foundSubcell=subcell, rho=rhotemp, temperature=temptemp)
          temp = subCellCentre(thisOctal, subcell)
          if (thisOctal%inflow(subcell)) then
             nz = nz + 1
             temperature(nz) = temptemp
             diffApprox(nz) = thisOctal%diffusionApprox(subcell)
             rho(nz) = rhotemp
             zAxis(nz) = abs(temp%z)
             subcellsize(nz) = thisOctal%subcellsize
          endif
          currentPos = OCTALVECTOR(xPos, yPos, temp%z+0.5*direction*thisOctal%subcellsize+direction*halfSmallestSubcell)
    end do


    someDiffusion = .false.
    do i = 1, nz
       if (diffApprox(i)) someDiffusion = .true.
    enddo
    if (.not.someDiffusion) nz = 0
    

  end subroutine getTemperatureDensityRunDiff

  subroutine putTemperatureRunDiff(grid, zAxis, temperature, nz, xPos, yPos, direction)
    type(GRIDTYPE) :: grid
    type(octal), pointer   :: thisOctal
    integer :: nz
    real :: xPos, yPos
    real(double) :: zAxis(:)
    real :: temperature(:)
    integer :: i, subcell
    real(double) :: direction
    type(octalvector) :: currentPos
    
    do i = 1, nz
       currentPos = OCTALVECTOR(xPos, yPos, -1.d0*direction*zAxis(i))
       call amrGridValues(grid%octreeRoot, currentPos, foundOctal=thisOctal, &
            foundSubcell=subcell)
       if (thisOctal%diffusionApprox(subcell)) then
          thisOctal%chiline(subcell) = temperature(i) ! use chiline as temporary temperature storage
       endif
    enddo
  end subroutine putTemperatureRunDiff

  recursive subroutine getxValuesdiff(thisOctal, nx, xAxis)

    type(octal), pointer   :: thisOctal
    type(octal), pointer  :: child
    type(octalvector) :: rVec
    integer :: nx, subcell, i
    real(double) :: xAxis(:)

    do subcell = 1, thisOctal%maxChildren
       if (thisOctal%hasChild(subcell)) then
          ! find the child
          do i = 1, thisOctal%nChildren, 1
             if (thisOctal%indexChild(i) == subcell) then
                child => thisOctal%child(i)
                call getxValuesdiff(child, nx, xAxis)
                exit
             end if
          end do
       else

          rVec = subcellCentre(thisOctal, subcell)
          nx = nx + 1
          xAxis(nx) = rVec%x
       end if
    end do

  end subroutine getxValuesdiff


  subroutine defineDiffusionZone(grid, outputFlag, resetTemp)

    use input_variables, only: rinner, router, diffDepth
    type(GRIDTYPE) :: grid
    real(double),allocatable :: zAxis(:), subcellsize(:)
    real,allocatable :: rho(:), temperature(:)
    integer :: nz
    real :: xpos, ypos, radius, drho, smallestSubcell
    logical :: resetTemp
    real(double) :: derivs(10)
    logical :: converged 
    real(double),allocatable :: xAxis(:)
    integer :: nx, i
    real :: flux
    real,allocatable :: rosselandOpticalDepth(:)
    integer :: j
    type(OCTALVECTOR) :: octVec
    real(double) :: kappa
    type(OCTAL), pointer :: thisOctal, boundaryOctal
    integer :: subcell
    real(double),allocatable :: zBoundary(:)
    real(double),allocatable :: xBoundary(:), sigma(:), tboundary(:)
    real(double), allocatable :: workarray(:)
    integer, parameter :: maxPoly = 20
    integer :: nPoly = 10
    real(double) :: apoly(maxPoly), chisq
    real(double), allocatable :: rval(:)
    integer :: nBoundary
    real(double) :: xStart
    integer :: iBoundary, boundarySubcell
    real(double) :: zApprox, eps
    real(double) :: tot
    real(double) :: zSize
    logical :: first
    logical :: outputFlag
    integer :: ierr
    real(double) :: xval
    integer, parameter :: maxZones = 100
    integer :: leftBoundary(maxZones), rightBoundary(maxZones)
    integer :: leftBoundaryX(maxZones), rightBoundaryX(maxZones)
    integer :: zone, nZones, zeroCounter, nZoneBoundary
    logical :: inZone
    integer :: nOctals, nCells
    integer :: ndiffcells 


    ndiffcells = 0

    call countVoxels(grid%octreeRoot,nOctals,nCells)

    allocate(zBoundary(ncells),xBoundary(ncells),sigma(ncells),tboundary(ncells),rval(ncells))
    allocate(zAxis(ncells))
    allocate(xAxis(ncells))
    allocate(subcellsize(ncells))
    allocate(rosselandOpticalDepth(ncells))

    call getxAxisRun(grid, xAxis, subcellSize, 0., 0., nx, +1.d0)

    call zeroDiffusionProb(grid%octreeRoot)

    call setNoDiffusion(grid%octreeRoot)


    if (grid%octreeRoot%threed) then
       call setDiffusionOnCrossings(grid%octreeRoot)
       goto 666
    endif


    if (writeoutput) write(*,*) "Defining diffusion zones..."
!    if (writeoutput) write(*,*) "! left hand diffusion boundary is off!!!!"






    xStart = xAxis(nx)
    rosselandOpticalDepth(1) = 0.
    do j = 2, nx
       octVec = OCTALVECTOR(xAxis(j), 0., 0.)
       call amrGridValues(grid%octreeRoot, octVec, foundOctal=thisOctal, &
            foundSubcell=subcell, rosselandKappa=kappa, grid=grid)
       rosselandOpticalDepth(j) = rosselandOpticalDepth(j-1) + &
            kappa * thisOctal%rho(subcell) *  subcellsize(j)*1.e10
       if (rosselandOpticalDepth(j) > diffDepth) then
          xStart = xAxis(j)
          exit
       endif
    enddo

    nx = 0
    call getxValuesdiff(grid%octreeRoot,nx,xAxis)
    call stripSimilarValues(xAxis,nx,1.d-5*grid%halfSmallestSubcell)
    xAxis(1:nx) = xAxis(1:nx) + 1.d-5*grid%halfSmallestSubcell

    call locate(xAxis, nx, xStart, iBoundary)


    nZones = 0
    inZone = .false.
    nBoundary = 0

    do i = iBoundary, nx
       xPos = xAxis(i)
       yPos = 0.
       first = .true.

       call getzAxisRun(grid, zAxis, subcellSize, xPos, yPos, nz, -1.)
       
       rosselandOpticalDepth(1) = 0.
       do j = 2, nz
          octVec = OCTALVECTOR(xpos, 0., zAxis(j))
          call amrGridValues(grid%octreeRoot, octVec, foundOctal=thisOctal, &
               foundSubcell=subcell, rosselandkappa=kappa, grid=grid)
          rosselandOpticalDepth(j) = rosselandOpticalDepth(j-1) + kappa * thisOctal%rho(subcell) * subcellsize(j)*1.e10

          if (rosselandOpticalDepth(j) > diffDepth) then

             if (first) then
                nBoundary = nBoundary + 1
                xBoundary(nBoundary) = xAxis(i)
                zBoundary(nBoundary) = zAxis(j)
                first = .false.
             endif

             if (.not.inZone)  then
                inZone = .true.
                nZones = nZones + 1
                if (nZones .gt. maxZones) then
                   write(*,*) "Too many diffusion zones. Setting no diffusion zone"
                   call setNoDiffusion(grid%octreeRoot)
                   nZones = 0
                   goto 666
                end if
                leftBoundary(nZones) = nBoundary
                leftBoundaryX(nZones) = i
                zeroCounter = 0
             end if
          else
             if ((j == nz).and.inZone) then
                zeroCounter = zeroCounter + 1
                if ((zeroCounter == 5)) then
                   inZone = .false.
                   rightBoundary(nZones) = nBoundary
                   rightBoundaryX(nZones) = i - zeroCounter
                end if
             end if
          endif
       enddo

    enddo
    if (inZone) then
       rightBoundary(nZones) = nBoundary
       rightBoundaryX(nZones) = nx - zeroCounter
    end if

    
    if (nZones > 0) then
       xBoundary(1:nBoundary) = log10(xBoundary(1:nBoundary))
       call locate(xBoundary, nBoundary,xBoundary(1)*1.05d0, i)
       sigma(1:i) = 100.d0
       sigma((i+1):nboundary) = 1.d0
    endif

    do zone = 1, nZones

       nZoneBoundary = rightBoundary(zone)-leftBoundary(zone)+1
       if (nZoneBoundary > 5) then
          allocate(workarray(3*nZoneBoundary+3*20+3))
          
          npoly = min((nZoneBoundary - 1), 10)
          eps = 0.d0
          
          
          call dpolft(nZoneBoundary, xBoundary(leftBoundary(zone):rightBoundary(zone)), &
               zBoundary(leftBoundary(zone):rightBoundary(zone)), sigma(leftBoundary(zone):rightBoundary(zone)), &
               npoly, npoly, eps,  rval, ierr, workarray)
          
          
          
          if (outputFlag) then
             open(66,file="boundary.dat",form="formatted",status="unknown")
             do i = 1, nBoundary
                call dp1vlu(nPoly, 0, xBoundary(i), tot, derivs, workarray)
                write(66,*) 10.**xBoundary(i),zBoundary(i),tot
             enddo
             close(66)
          endif
          
          
          
          do i = leftBoundaryX(zone), rightBoundaryX(zone)
             xPos = xAxis(i)
             call getzAxisRun(grid, zAxis, subcellSize, xPos, yPos, nz, -1.)
             
             xval = log10(dble(xpos))
             call dp1vlu(nPoly, 0, xval, zApprox, derivs, workarray)
             
             if (zApprox < 0.) zApprox = 0.
             
             do j = 2, nz
                octVec = OCTALVECTOR(xpos, 0., zAxis(j))
                call amrGridValues(grid%octreeRoot, octVec, foundOctal=thisOctal, &
                     foundSubcell=subcell)
                zSize = thisOctal%subcellsize/2.d0
                if ((zAxis(j)+zSize) <= zApprox) then
                   thisOctal%diffusionApprox(subcell) = .true.
                   if (resetTemp) thisOctal%temperature(subcell) = 20.
                   nDiffCells = nDiffCells  + 1
                   
                   ! put in the lefthand boundary of the diffusion zone if necessary
                   if (i == leftBoundaryX(zone)) then
                      octVec = OCTALVECTOR(xAxis(leftBoundaryX(zone)), 0., zAxis(j))
                      call amrGridValues(grid%octreeRoot, octVec, foundOctal=boundaryOctal, &
                           foundSubcell=boundarySubcell)
                      boundaryOctal%leftHandDiffusionBoundary(boundarySubcell) = .true.
                   endif
                   ! put in the righthand boundary of the diffusion zone if necessary
                   if (i == rightBoundaryX(zone)) then
                      octVec = OCTALVECTOR(xAxis(rightBoundaryX(zone)), 0., zAxis(j))
                      call amrGridValues(grid%octreeRoot, octVec, foundOctal=boundaryOctal, &
                           foundSubcell=boundarySubcell)
                      boundaryOctal%rightHandDiffusionBoundary(boundarySubcell) = .true.
                   endif
                else
                   thisOctal%diffusionApprox(subcell) = .false.
                endif
             enddo


             call getzAxisRun(grid, zAxis, subcellSize, xPos, yPos, nz, +1.)

             do j = 2, nz
                octVec = OCTALVECTOR(xpos, 0., zAxis(j))
                call amrGridValues(grid%octreeRoot, octVec, foundOctal=thisOctal, &
                     foundSubcell=subcell)
                zSize = thisOctal%subcellsize/2.d0
                if (abs(zAxis(j)-zSize) <= zApprox) then
                   thisOctal%diffusionApprox(subcell) = .true.
                   if (resetTemp) thisOctal%temperature(subcell) = 20.
                   nDiffCells = nDiffCells  + 1
                   ! put in the lefthand boundary of the diffusion zone if necessary
                   if (i == leftBoundaryX(zone)) then
                      octVec = OCTALVECTOR(xAxis(leftBoundaryX(zone)), 0., zAxis(j))
                      call amrGridValues(grid%octreeRoot, octVec, foundOctal=boundaryOctal, &
                           foundSubcell=boundarySubcell)
                      boundaryOctal%leftHandDiffusionBoundary(boundarySubcell) = .true.
                   endif
                   ! put in the righthand boundary of the diffusion zone if necessary
                   if (i == rightBoundaryX(zone)) then
                      octVec = OCTALVECTOR(xAxis(rightBoundaryX(zone)), 0., zAxis(j))
                      call amrGridValues(grid%octreeRoot, octVec, foundOctal=boundaryOctal, &
                           foundSubcell=boundarySubcell)
                      boundaryOctal%rightHandDiffusionBoundary(boundarySubcell) = .true.
                   endif
                else
                   thisOctal%diffusionApprox(subcell) = .false.
                endif
             enddo

          enddo
          deallocate(workarray)
       end if
    

    end do


666 continue

    if (writeoutput) write(*,*) "Done.", nZones, "diffusion zone(s) defined."


    write(*,*) nDiffCells, " cells defined in diff approx"

    deallocate(zBoundary,xBoundary,sigma,tboundary,rval)
    deallocate(zAxis, xAxis)
    deallocate(subcellsize)
    deallocate(rosselandOpticalDepth)


  end subroutine defineDiffusionZone


  subroutine diffPhotonPosition(grid, thisOctal, subcell, rVec)
    type(GRIDTYPE) :: grid
    integer :: subcell, tempsubcell
    type(OCTAL), pointer :: thisOctal, tempOctal, oldOctal
    type(OCTALVECTOR) :: rVec, cVec
    real(double) :: phi
    logical :: found
     
    rVec = subcellCentre(thisOctal, subcell)
    phi = atan2(rvec%y, rvec%z)
    cVec = rVec
    oldOctal => thisOctal
    tempOctal => thisOctal
    found = .false.

    if (thisOctal%leftHandDiffusionBoundary(subcell)) then
       do while (.not.found)
          rVec = rVec - xHatOctal * (0.5d0*tempOctal%subcellSize+grid%halfsmallestsubcell*0.01d0)
          call amrGridValues(grid%octreeRoot, rVec, startOctal=oldOctal, &
               foundOctal=tempOctal, foundSubcell=tempsubcell)
          if (.not.tempOctal%diffusionApprox(tempSubcell)) then
             found = .true.
          else
             oldOctal => tempOctal
             rVec = subcellCentre(tempOctal, tempSubcell)
          endif
       enddo
    else if (thisOctal%rightHandDiffusionBoundary(subcell)) then
       do while (.not.found)
          rVec = rVec + xHatOctal * (0.5d0*tempOctal%subcellSize+grid%halfsmallestsubcell*0.01d0)
          call amrGridValues(grid%octreeRoot, rVec, startOctal=oldOctal, &
               foundOctal=tempOctal, foundSubcell=tempsubcell)
          if (.not.tempOctal%diffusionApprox(tempSubcell)) then
             found = .true.
          else
             oldOctal => tempOctal
             rVec = subcellCentre(tempOctal, tempSubcell)
          endif
       enddo
    else
       do while (.not.found)
          
          if (cVec%z > 0.d0) then
             rVec = rVec + zHatOctal * (0.5d0*tempOctal%subcellSize+grid%halfsmallestsubcell*0.01d0)
          else
             rVec = rVec - zHatOctal * (0.5d0*tempOctal%subcellSize+grid%halfsmallestsubcell*0.01d0)
          endif
          call amrGridValues(grid%octreeRoot, rVec, startOctal=oldOctal, &
               foundOctal=tempOctal, foundSubcell=tempsubcell)
          if (.not.tempOctal%diffusionApprox(tempSubcell)) then
             found = .true.
          else
             oldOctal => tempOctal
             rVec = subcellCentre(tempOctal, tempSubcell)
          endif
          
       end do
    endif
    rVec = rotateZ(rVec, phi)
  end subroutine diffPhotonPosition
       






  subroutine getxAxisRun(grid, xAxis, subcellSize, zPos, yPos, nx, direction)
    type(GRIDTYPE) :: grid
    type(octal), pointer   :: thisOctal
    integer :: nx
    real(double) :: xAxis(*), subcellsize(*)
    real :: zPos, yPos
    integer :: subcell
    real(double) :: rhotemp
    real :: temptemp
    real(double) :: direction
    type(OCTALVECTOR) :: currentPos, temp
    real :: halfSmallestSubcell

    nx = 0
    halfSmallestSubcell = grid%halfSmallestSubcell

    currentPos = OCTALVECTOR(0., yPos, zPos)

    do while((currentPos%x) < grid%octreeRoot%subcellSize )
       call amrGridValues(grid%octreeRoot, currentPos, foundOctal=thisOctal, &
            foundSubcell=subcell, rho=rhotemp, temperature=temptemp, grid=grid)
       nx = nx + 1
       temp = subCellCentre(thisOctal, subcell)
       xAxis(nx) = temp%x
       subcellsize(nx) = thisOctal%subcellsize
       currentPos = OCTALVECTOR(xAxis(nx)+0.5*direction*thisOctal%subcellsize+direction*halfSmallestSubcell, yPos, zPos)
    end do
    
 
  end subroutine getxAxisRun

  subroutine getzAxisRun(grid, zAxis, subcellSize, xPos, yPos, nz, direction)
    type(GRIDTYPE) :: grid
    type(octal), pointer   :: thisOctal
    integer :: nz
    real(double) :: zAxis(:), subcellsize(:)
    real :: xPos, yPos
    integer :: subcell
    real(double) :: rhotemp
    real :: temptemp
    real :: direction
    type(OCTALVECTOR) :: currentPos, temp
    real :: halfSmallestSubcell

    nz = 0
    halfSmallestSubcell = grid%halfSmallestSubcell

    currentPos = OCTALVECTOR(xpos, yPos, -1.*direction*grid%octreeRoot%subcellsize)
    do while((-1.d0*direction*currentPos%z) > 0.)
       call amrGridValues(grid%octreeRoot, currentPos, foundOctal=thisOctal, &
            foundSubcell=subcell, rho=rhotemp, temperature=temptemp, grid=grid)
       nz = nz + 1
       temp = subCellCentre(thisOctal, subcell)
       zAxis(nz) = temp%z
       subcellsize(nz) = thisOctal%subcellsize
       currentPos = OCTALVECTOR(xpos, yPos, zAxis(nz)+0.5d0*direction*thisOctal%subcellsize+direction*halfSmallestSubcell)
    end do
    
  end subroutine getzAxisRun


  real function getTempGradient(nz, t, z)
    integer :: nz
    integer :: tnz
    real(double) :: t(*), z(*), chisq, apoly(4)
    integer :: nterms
    real(double) :: revT(1000), revZ(1000)
    integer :: i

    real :: xp(1000), yp(1000)
    ! fit a polynomial

    do i =1, nz
       revZ(i) = z(nz-i+1)
       revT(i) = t(nz-i+1)
    enddo

    tnz = min(4, nz)

    nTerms = 2

    call polfit(revz(2:tnz), revt(2:tnz), revt(2:tnz), tnz-1 ,nterms , -1, apoly, chisq)

!    getTempGradient = apoly(2) + 2.*revZ(1)*apoly(3)

    getTempGradient = apoly(2) * revZ(1)

    getTempGradient = getTempGradient / 1.e10 ! [K cm-1]

!    xp(1:nz) = revz(1:nz)
!    yp(1:nz) = revT(1:nz)
!    call pgbegin(0,"/xs",1,1)
!    call pgask(.true.)
!    call pgenv(xp(1),xp(nz), 6.,yp(nz)*1.1,0.,0.)
!    call pgbin(nz, xp, yp,.true.)
!    do i = 1, nz
!       yp(i) = apoly(1) + apoly(2)*xp(i)
!    enddo
!    call pgsci(2)
!    call pgline(tnz,xp,yp)
!    read(*,*) i
!    call pgend


  end function getTempGradient


  recursive subroutine copychilinetoTemperature(thisOctal)
  type(octal), pointer   :: thisOctal
  type(octal), pointer  :: child 
  integer :: subcell, i
  
  do subcell = 1, thisOctal%maxChildren
       if (thisOctal%hasChild(subcell)) then
          ! find the child
          do i = 1, thisOctal%nChildren, 1
             if (thisOctal%indexChild(i) == subcell) then
                child => thisOctal%child(i)
                call copychilinetoTemperature(child)
                exit
             end if
          end do
       else
          if (thisOctal%diffusionApprox(subcell)) then
             thisOctal%oldtemperature(subcell) = thisOctal%temperature(subcell)
             thisOctal%temperature(subcell) = max(thisOctal%chiline(subcell),3.d0)
          endif
       endif
    enddo
  end subroutine copychilinetoTemperature

  recursive subroutine copyTemperaturetochiline(thisOctal)
  type(octal), pointer   :: thisOctal
  type(octal), pointer  :: child 
  integer :: subcell, i
  
  do subcell = 1, thisOctal%maxChildren
       if (thisOctal%hasChild(subcell)) then
          ! find the child
          do i = 1, thisOctal%nChildren, 1
             if (thisOctal%indexChild(i) == subcell) then
                child => thisOctal%child(i)
                call copytemperaturetochiline(child)
                exit
             end if
          end do
       else
          if (thisOctal%diffusionApprox(subcell)) then
             thisOctal%chiline(subcell) = thisOctal%temperature(subcell)
          endif
       endif
    enddo
  end subroutine copyTemperaturetochiline

  recursive subroutine zeroDiffusionProb(thisOctal)
  type(octal), pointer   :: thisOctal
  type(octal), pointer  :: child 
  integer :: subcell, i
  
  do subcell = 1, thisOctal%maxChildren
       if (thisOctal%hasChild(subcell)) then
          ! find the child
          do i = 1, thisOctal%nChildren, 1
             if (thisOctal%indexChild(i) == subcell) then
                child => thisOctal%child(i)
                call zeroDiffusionProb(child)
                exit
             end if
          end do
       else
          thisOctal%diffusionProb(subcell) = 0.d0
          thisOctal%diffusionApprox = .false.
       endif
    enddo
  end subroutine zeroDiffusionProb


  subroutine putDiffusionProb(grid, thisOctal, subcell)
    type(GRIDTYPE) :: grid
    type(OCTAL), pointer :: thisOctal
    type(OCTALVECTOR) :: rVec
    integer :: subcell
    integer :: nFreq, iLam
    real(double) :: freq(1000), dnu(1000), thisLam, norm, r1, r2, v, kappaP
    real(double) :: kabsArray(1000)
    integer :: i


    nFreq = grid%nLambda
    do i = 1, nFreq
       freq(nFreq-i+1) = cSpeed / (grid%lamArray(i)*1.e-8)
    enddo


    do i = 2, nFreq-1
       dnu(i) = 0.5*((freq(i+1)+freq(i))-(freq(i)+freq(i-1)))
    enddo
    dnu(1) = freq(2)-freq(1)
    dnu(nFreq) = freq(nFreq)-freq(nFreq-1)

    call amrGridValues(grid%octreeRoot, subcellCentre(thisOctal,subcell), startOctal=thisOctal, &
         actualSubcell=subcell, kappaAbsArray=kAbsArray, grid=grid)


    kappap = 0.
    norm = 0.
    do i = 1, nFreq
       thisLam = (cSpeed / freq(i)) * 1.e8
       call hunt(grid%lamArray, grid%nLambda, real(thisLam), iLam)
       if ((iLam >=1) .and. (iLam <= grid%nLambda)) then
          kappaP = kappaP + dble(kabsArray(ilam)) * &
               dble(bnu(dble(freq(i)),dble(thisOctal%temperature(subcell)))) * dble(dnu(i)) 
          norm = norm + dble(bnu(dble(freq(i)),dble(thisOctal%temperature(subcell)))) * dble(dnu(i)) 
       endif
    enddo
    kappaP = kappaP / norm / 1.e10
    rVec = subcellCentre(thisOctal,subcell)
    r1 = rVec%x-thisOctal%subcellSize/2.d0
    r2 = rVec%x+thisOctal%subcellSize/2.d0
    v = dble(pi) * (r2**2 - r1**2) * thisOctal%subcellSize * 1.d30

    thisOctal%diffusionProb(subcell) = fourPi * kappaP * (stefanBoltz/pi) * &
         (thisOctal%temperature(subcell)**4) * V 
  end subroutine putDiffusionProb


  recursive subroutine sumDiffusionProb(thisOctal, tot)
  type(octal), pointer   :: thisOctal
  type(octal), pointer  :: child 
  integer :: subcell, i
  real(double) :: tot
  
  do subcell = 1, thisOctal%maxChildren
       if (thisOctal%hasChild(subcell)) then
          ! find the child
          do i = 1, thisOctal%nChildren, 1
             if (thisOctal%indexChild(i) == subcell) then
                child => thisOctal%child(i)
                call sumDiffusionProb(child, tot)
                exit
             end if
          end do
       else
          tot = tot + thisOctal%diffusionProb(subcell)
       endif
       thisOctal%diffusionProb(subcell) = tot
    enddo
  end subroutine sumDiffusionProb

  recursive subroutine normDiffusionProb(thisOctal, tot)
  type(octal), pointer   :: thisOctal
  type(octal), pointer  :: child 
  integer :: subcell, i
  real(double) :: tot
  
  if (thisOctal%nChildren > 0) then
            
     ! call this subroutine recursively on each of its children
     do subcell = 1, thisOctal%nChildren, 1 
        child => thisOctal%child(subcell)
        call normDiffusionProb(child, tot)
     end do
  end if

  thisOctal%diffusionProb  = thisOctal%diffusionProb /tot


  end subroutine normDiffusionProb


  recursive subroutine setDiffusionOnCrossings(thisOctal)
    use input_variables, only : minCrossings
    type(octal), pointer   :: thisOctal
    type(octal), pointer  :: child 
    integer :: subcell, i
    real(double) :: tot
    
    do subcell = 1, thisOctal%maxChildren
       if (thisOctal%hasChild(subcell)) then
          ! find the child
          do i = 1, thisOctal%nChildren, 1
             if (thisOctal%indexChild(i) == subcell) then
                child => thisOctal%child(i)
                call setDiffusionOnCrossings(child)
                exit
             end if
          end do
       else
          if (thisOctal%nCrossings(subcell) < minCrossings) then
             thisOctal%diffusionApprox(subcell) = .true.
             thisOctal%etaline(subcell) = 0.0 
          else
             thisOctal%diffusionApprox(subcell) = .false.
             thisOctal%etaline(subcell) = 1.e30
          endif
       endif
    enddo
  end subroutine setDiffusionOnCrossings

  recursive subroutine findVerticalTempDiffusion(thisOctal, grid, converged)
    use input_variables, only : minCrossings
    type(GRIDTYPE) :: grid
    type(octal), pointer   :: thisOctal, startOctal,foundOctal
    type(octal), pointer  :: child 
    integer :: subcell, i
    logical :: converged
    type(OCTALVECTOR) :: v1, v2, centre, octVec
    integer :: foundSubcell
    real(double) :: r
    real :: temp

    v1 = OCTALVECTOR(0.d0, 0.d0, +1.d0)
    v2 = OCTALVECTOR(0.d0, 0.d0, -1.d0)

    
    do subcell = 1, thisOctal%maxChildren
       if (thisOctal%hasChild(subcell)) then
          ! find the child
          do i = 1, thisOctal%nChildren, 1
             if (thisOctal%indexChild(i) == subcell) then
                child => thisOctal%child(i)
                call findVerticalTempDiffusion(child, grid, converged)
                exit
             end if
          end do
       else
          if (thisOctal%diffusionApprox(subcell).and.(thisOctal%etaLine(subcell) == 0.d0)) then
             r = thisOctal%subcellSize/2. + grid%halfSmallestSubcell * 0.1
             centre = subcellCentre(thisOctal, subcell)
             octVec = centre + r * v1
             if (inOctal(grid%octreeRoot, octVec)) then
                startOctal => thisOctal
                call amrGridValues(grid%octreeRoot, octVec, grid=grid, startOctal=startOctal, &
                     foundOctal=foundOctal, foundSubcell=foundSubcell,temperature=temp)
                if (foundOctal%etaLine(foundSubcell) /= 0.) then
                   thisOctal%temperature(subcell) = temp
                   thisOctal%etaLine(subcell) = 1.e30
                   converged = .false.
                endif
             endif
             r = thisOctal%subcellSize/2. + grid%halfSmallestSubcell * 0.1
             centre = subcellCentre(thisOctal, subcell)
             octVec = centre + r * v2
             if (inOctal(grid%octreeRoot, octVec)) then
                startOctal => thisOctal
                call amrGridValues(grid%octreeRoot, octVec, grid=grid, startOctal=startOctal, &
                     foundOctal=foundOctal, foundSubcell=foundSubcell,temperature=temp)
                if (foundOctal%etaLine(foundSubcell) /= 0.) then
                   thisOctal%temperature(subcell) = temp
                   thisOctal%etaLine(subcell) = 1.e30
                   converged = .false.
                endif
             endif
          endif
       endif
    enddo
  end subroutine findVerticalTempDiffusion



  recursive subroutine setNoDiffusion(thisOctal)
  type(octal), pointer   :: thisOctal
  type(octal), pointer  :: child 
  integer :: subcell, i

  if (thisOctal%nChildren > 0) then
            
     ! call this subroutine recursively on each of its children
     do subcell = 1, thisOctal%nChildren, 1 
        child => thisOctal%child(subcell)
        call setNoDiffusion(child)
     end do 
  end if

  thisOctal%diffusionApprox = .false.
  thisOctal%leftHandDiffusionBoundary = .false.
  thisOctal%rightHandDiffusionBoundary = .false.


end subroutine setNoDiffusion




  RECURSIVE SUBROUTINE locateDiffusionProbAMR(probability,thisOctal,subcell) 
    ! finds the subcell that contains a given value of 'probability'.
    ! each subcell of the tree's octals has a value for line emission 
    !   probability which is an upper bound of the subcell's value in the cumulative probability
    !   distribution for the 

    IMPLICIT NONE

    real(double), INTENT(IN) :: probability
    TYPE(octal), POINTER              :: thisOctal
    INTEGER, INTENT(OUT)              :: subcell

    INTEGER              :: i, j 
   
   
    ! we need to treat the first subcell as a special case
    
    IF (probability < thisOctal%diffusionProb(1)) THEN

      IF (thisOctal%hasChild(1)) THEN
      
        ! find the child
        DO j = 1, thisOctal%nChildren, 1
          IF (thisOctal%indexChild(j) == 1) THEN
            thisOctal => thisOctal%child(j)
            CALL locateDiffusionProbAMR(probability,thisOctal,subcell)
            RETURN
          END IF
        END DO
        
      ELSE 
        subcell = 1
        RETURN
        
      END IF
    END IF   
  
   
    DO i = 2, thisOctal%maxChildren, 1
      IF (probability > thisOctal%diffusionProb(i-1) .AND. &
          probability < thisOctal%diffusionProb(i)) THEN
      
        IF (thisOctal%hasChild(i)) THEN
          
          ! find the child
          DO j = 1, thisOctal%nChildren, 1
            IF (thisOctal%indexChild(j) == i) THEN
              thisOctal => thisOctal%child(j)
              CALL locateDiffusionProbAMR(probability,thisOctal,subcell)
              RETURN
            END IF
          END DO
          
        ELSE 
          subcell = i
          RETURN
        
        END IF
      END IF
    END DO

      
  END SUBROUTINE locateDiffusionProbAMR

  subroutine calcIncidentFlux(grid, epsoverdt)
    type(GRIDTYPE) :: grid
    type(OCTALVECTOR) :: octVec, cVec
    type(OCTAL), pointer :: thisOctal
    integer :: subcell
    real(oct) :: epsoverdt
    integer :: nx
    real(double) :: xAxis(2000000), zAxis(2000000)
    real :: temperature(2000000)
    real(double) :: rho(2000000)
    real(double) :: subcellSize(2000000)
    logical :: diffApprox(20000000)
    real :: xpos, ypos
    integer :: i, j, nz
    real :: area
    integer :: iBoundary
    nx = 0
    call getxValuesdiff(grid%octreeRoot,nx,xAxis)
    call stripSimilarValues(xAxis,nx,1.d-5*grid%halfSmallestSubcell)
    xAxis(1:nx) = xAxis(1:nx) + 1.d-5*grid%halfSmallestSubcell

    iBoundary = 0
    do i = 1, nx
       xpos = xAxis(i)
       ypos = 0.
       call getTemperatureDensityRunDiff(grid, zAxis, subcellsize, rho, temperature, diffApprox, xPos, yPos, nz, -1.d0)
       do j = 1, nz
          if (diffApprox(j)) then
             iBoundary = j 
             exit
          endif
       end do
       if (iBoundary /= 0) then
          octVec=OCTALVECTOR(xpos, ypos, zAxis(iBoundary))
          call amrGridValues(grid%octreeRoot, octVec, foundOctal=thisOctal, foundSubcell=Subcell, grid=grid)
          cVec = subcellCentre(thisOctal, subcell)
          area = pi*((cVec%x+thisOctal%subcellSize)**2-(cVec%x-thisOctal%subcellSize)**2) * 1.e20
          thisOctal%incidentflux(subcell) = thisOctal%nDiffusion(subcell)*epsOverdT / area 
       endif
       
       iBoundary = 0
       call getTemperatureDensityRunDiff(grid, zAxis, subcellsize, rho, temperature, diffApprox, xPos, yPos, nz, +1.d0)
       do j = 1, nz
          if (diffApprox(j)) then
             iBoundary = j 
             exit
          endif
       end do
       if (iBoundary /= 0) then
          octVec=OCTALVECTOR(xpos, ypos, -1.*zAxis(iBoundary))
          call amrGridValues(grid%octreeRoot, octVec, foundOctal=thisOctal, foundSubcell=Subcell, grid=grid)
          cVec = subcellCentre(thisOctal, subcell)
          area = pi*((cVec%x+thisOctal%subcellSize/2.)**2-(cVec%x-thisOctal%subcellSize/2.)**2) * 1.e20
          thisOctal%incidentflux(subcell) = thisOctal%nDiffusion(subcell)*epsOverdT / area 
       endif
    enddo
  end subroutine calcIncidentFlux

  real function returnFluxDiff(thisTemp, ival, jval, fd, jd, gammadiff, &
       kappa_ross, kappap, rho, zAxis, temperature, nz, &
       nextJd, nextFd, nextfDiff)
       real :: thisTemp
       integer :: ival, jval
       real(double) :: fd(*), gammadiff(*)
       real :: jd(*), kappa_ross(*), kappap(*)
       real :: rho(*), zAxis(*), temperature(*)
       integer :: nz
       real :: djdz, dfddz, dtdz
       real :: nextjd, nextfd, nextfdiff


       dfddz = fourPi * kappap(ival) * rho(ival) * (stefanBoltz*temperature(ival)**4/pi - jd(ival))
       nextFd = fd(ival) + dfddz * (zAxis(jval)-zAxis(ival)) * 1.e10
       dtdz = (thisTemp-temperature(ival))/(zAxis(jval)-zAxis(ival)) / 1.e10
       nextFdiff = (-16.*stefanBoltz*thisTemp**3)/(3.*kappa_ross(jval)*rho(jval)) * dtdz
       djdz = -3./fourPi * kappa_ross(ival) * rho(ival) * fd(ival)
       nextJd = jd(ival) +  djdz * (zAxis(jval)-zAxis(ival)) * 1.e10

       returnFluxdiff = nextFdiff + nextFd
       write(*,*) thisTemp,temperature(ival),nextfd,nextfDiff,returnFluxdiff
  end function returnFluxDiff

  recursive subroutine setDiffusionCoeff(grid, thisOctal)
    type(octal), pointer   :: thisOctal
    type(octal), pointer  :: child 
    type(GRIDTYPE) :: grid
    real(double) :: kRos, kabs
    real :: kappap
    integer :: subcell, i
    
    do subcell = 1, thisOctal%maxChildren
       if (thisOctal%hasChild(subcell)) then
          ! find the child
          do i = 1, thisOctal%nChildren, 1
             if (thisOctal%indexChild(i) == subcell) then
                child => thisOctal%child(i)
                call setDiffusionCoeff(grid, child)
                exit
             end if
          end do
       else
          thisOctal%temperature(subcell) = (thisOctal%eDens(subcell)/arad)**0.25d0

          call returnKappa(grid, thisOctal, subcell, rosselandKappa=kros)
          thisOctal%kappaRoss(subcell) = kRos
          thisOctal%diffusionCoeff(subcell) =  cSpeed / max(1.d-20,(kRos * thisOctal%rho(subcell)))
          thisOctal%oldeDens(subcell) = thisOctal%eDens(subcell)
       endif
    enddo
  end subroutine setDiffusionCoeff

  recursive subroutine seteDens(grid, thisOctal)
    type(octal), pointer   :: thisOctal
    type(octal), pointer  :: child 
    type(GRIDTYPE) :: grid
    real(double) :: kRos, kabs
    real :: kappap
    integer :: subcell, i
    
    do subcell = 1, thisOctal%maxChildren
       if (thisOctal%hasChild(subcell)) then
          ! find the child
          do i = 1, thisOctal%nChildren, 1
             if (thisOctal%indexChild(i) == subcell) then
                child => thisOctal%child(i)
                call seteDens(grid, child)
                exit
             end if
          end do
       else
          thisOctal%eDens(subcell) = aRad * thisOctal%temperature(subcell)**4
       endif
    enddo
  end subroutine seteDens

  recursive subroutine checkConvergence(thisOctal, tol, dtmax, converged)
    type(octal), pointer   :: thisOctal
    type(octal), pointer  :: child 
    real :: deltaT, tol, dtmax
    integer :: subcell, i
    logical :: converged
    
    do subcell = 1, thisOctal%maxChildren
       if (thisOctal%hasChild(subcell)) then
          ! find the child
          do i = 1, thisOctal%nChildren, 1
             if (thisOctal%indexChild(i) == subcell) then
                child => thisOctal%child(i)
                call checkConvergence(child, tol, dtMax, converged)
                exit
             end if
          end do
       else
          deltaT = abs(thisOctal%eDens(subcell)-thisOctal%oldeDens(subcell)) &
                / thisOctal%oldEdens(subcell)
          dtMax = max(dtMax, deltaT)
          if (deltaT > tol) converged = .false.
          
       endif
    enddo
  end subroutine checkConvergence

  subroutine jacobiSweep(grid,  tol, demax, converged)
    use input_variables, only : blockhandout
!$MPI    include 'mpif.h'
    type(octal), pointer   :: thisOctal, neighbourOctal, startOctal
    type(octal), pointer  :: child 
    type(GRIDTYPE) :: grid
    integer :: my_rank, np, isubcell, ierr
    real(double) :: kRos
    real(double) :: tol, deMax
    real(double), allocatable :: demaxArray(:)
    real(double), allocatable :: tempDoubleArray(:)
    logical :: converged
    integer :: subcell, i, neighbourSubcell
    real(double) :: eDens(-1:1,-1:1,-1:1)
    real(double) :: dCoeff(-1:1,-1:1,-1:1)
    real(double) :: dCoeffhalf(-1:1,-1:1,-1:1)
    real(double) :: eNplus1
    real(double) :: r, gradE, bigR, lambda
    real(double) :: DeltaT, DeltaX, deltaE
    type(OCTALVECTOR) :: octVec
    integer                     :: nOctal        ! number of octals in grid
    type(octalWrapper), allocatable :: octalArray(:) ! array containing pointers to octals
    integer :: iOctal
    integer :: iOctal_beg, iOctal_end

!$MPI     logical :: dcAllocated
!$MPI     integer, dimension(:), allocatable :: octalsBelongRank
!$MPI     logical :: rankComplete
!$MPI     integer :: iRank
!$MPI     integer :: tag = 0
!$MPI     integer :: tempInt


    np = 1
    my_rank = 1

    deMax = -1.d30

    allocate(octalArray(grid%nOctals))
    nOctal = 0
    call getOctalArray(grid%octreeRoot,octalArray, nOctal)
    if (nOctal /= grid%nOctals) then
       write(*,*) "Screw up in get octal array", nOctal,grid%nOctals
       stop
    endif

!$MPI    ! FOR MPI IMPLEMENTATION=======================================================
!$MPI    !  Get my process rank # 
!$MPI    call MPI_COMM_RANK(MPI_COMM_WORLD, my_rank, ierr)
!$MPI  
!$MPI    ! Find the total # of precessor being used in this run
!$MPI    call MPI_COMM_SIZE(MPI_COMM_WORLD, np, ierr)
!$MPI    
!$MPI    ! we will use an array to store the rank of the process
!$MPI    !   which will calculate each octal's variables
!$MPI    allocate(octalsBelongRank(size(octalArray)))
!$MPI    
!$MPI    if (my_rank == 0) then
!$MPI  !     print *, ' '
!$MPI  !     print *, 'Jacobi sweep  computed by ', np-1, ' processors.'
!$MPI  !     print *, ' '
!$MPI       call mpiBlockHandout(np,octalsBelongRank,blockDivFactor=1,tag=tag,&
!$MPI                            maxBlockSize=100,setDebug=.false.)
!$MPI    
!$MPI    endif
!$MPI    ! ============================================================================

    allocate(demaxArray(1:np))
    deMaxArray = 0.d0
    
    ! default loop indices
    ioctal_beg = 1
    ioctal_end = nOctal


!$MPI if (my_rank /= 0) then
!$MPI  blockLoop: do     
!$MPI call mpiGetBlock(my_rank,iOctal_beg,iOctal_end,rankComplete,tag,setDebug=.false.)
!$MPI   if (rankComplete) exit blockLoop 

    do iOctal =  iOctal_beg, iOctal_end

       thisOctal => octalArray(iOctal)%content

       do subcell = 1, thisOctal%maxChildren

          if (.not.thisOctal%hasChild(subcell)) then

             eDens = 0.d0
             dCoeff = 0.d0

             if (thisOctal%diffusionApprox(subcell)) then

                if (thisOctal%twoD) then
                   r = thisOctal%subcellSize/2. + grid%halfSmallestSubcell * 0.1

                   eDens(0, 0, 0) = thisOctal%eDens(subcell)
                   dCoeff(0, 0, 0) = thisOctal%diffusionCoeff(subcell)

                   ! positive x

                   octVec = subcellCentre(thisOctal, subcell) + OCTALVECTOR(r, 0.d0, 0.d0)
                   if (inOctal(grid%octreeRoot, octVec)) then
                      startOctal => thisOctal
                      call amrGridValues(grid%octreeRoot, octVec, grid=grid, startOctal=startOctal, &
                           foundOctal=neighbourOctal, foundsubcell=neighbourSubcell)
                      eDens(1, 0, 0) = neighbourOctal%eDens(neighboursubcell)
                      dCoeff(1, 0, 0) = neighbourOctal%diffusionCoeff(neighboursubcell)
                   else
                      eDens(1, 0, 0) = eDens(0, 0, 0)
                      dCoeff(1, 0, 0) = dCoeff(0, 0, 0)
                   endif
                   ! negative x

                   octVec = subcellCentre(thisOctal, subcell) - OCTALVECTOR(r, 0.d0, 0.d0)
                   if (inOctal(grid%octreeRoot, octVec)) then
                      startOctal => thisOctal
                      call amrGridValues(grid%octreeRoot, octVec, grid=grid, startOctal=startOctal, &
                           foundOctal=neighbourOctal, foundsubcell=neighbourSubcell)
                      eDens(-1, 0, 0) = neighbourOctal%eDens(neighbourSubcell)
                      dCoeff(-1, 0, 0) = neighbourOctal%diffusionCoeff(neighbourSubcell)
                   else
                      eDens(-1, 0, 0) = eDens(0, 0, 0)
                      dCoeff(-1, 0, 0) = dCoeff(0, 0, 0)
                   endif

                   ! positive z

                   octVec = subcellCentre(thisOctal, subcell) + OCTALVECTOR(0.d0, 0.d0, r)
                   if (inOctal(grid%octreeRoot, octVec)) then
                      startOctal => thisOctal
                      call amrGridValues(grid%octreeRoot, octVec, grid=grid, startOctal=startOctal, &
                           foundOctal=neighbourOctal, foundsubcell=neighbourSubcell)
                      eDens(0, 0, 1) = neighbourOctal%eDens(neighbourSubcell)
                      dCoeff(0, 0, 1) = neighbourOctal%diffusionCoeff(neighbourSubcell)
                   else
                      eDens(0, 0, 1) = eDens(0, 0, 0)
                      dCoeff(0, 0, 1) = dCoeff(0, 0, 0)
                   endif

                   ! negative z

                   octVec = subcellCentre(thisOctal, subcell) - OCTALVECTOR(0.d0, 0.d0, r)
                   if (inOctal(grid%octreeRoot, octVec)) then
                      startOctal => thisOctal
                      call amrGridValues(grid%octreeRoot, octVec, grid=grid, startOctal=startOctal, &
                           foundOctal=neighbourOctal, foundsubcell=neighbourSubcell)
                      eDens(0,  0, -1) = neighbourOctal%eDens(neighbourSubcell)
                      dCoeff(0, 0, -1) = neighbourOctal%diffusionCoeff(neighbourSubcell)
                   else
                      eDens(0, 0, -1) = eDens(0, 0, 0)
                      dCoeff(0, 0, -1) = dCoeff(0, 0, 0)
                   endif

                else
                   r = thisOctal%subcellSize/2. + grid%halfSmallestSubcell * 0.1

                   eDens(0, 0, 0) = thisOctal%eDens(subcell)
                   dCoeff(0, 0, 0) = thisOctal%diffusionCoeff(subcell)

                   ! positive x

                   octVec = subcellCentre(thisOctal, subcell) + OCTALVECTOR(r, 0.d0, 0.d0)
                   if (inOctal(grid%octreeRoot, octVec)) then
                      startOctal => thisOctal
                      call amrGridValues(grid%octreeRoot, octVec, grid=grid, startOctal=startOctal, &
                           foundOctal=neighbourOctal, foundsubcell=neighbourSubcell)
                      eDens(1, 0, 0) = neighbourOctal%eDens(neighboursubcell)
                      dCoeff(1, 0, 0) = neighbourOctal%diffusionCoeff(neighboursubcell)
                   else
                      eDens(1, 0, 0) = eDens(0, 0, 0)
                      dCoeff(1, 0, 0) = dCoeff(0, 0, 0)
                   endif

                   ! negative x

                   octVec = subcellCentre(thisOctal, subcell) - OCTALVECTOR(r, 0.d0, 0.d0)
                   if (inOctal(grid%octreeRoot, octVec)) then
                      startOctal => thisOctal
                      call amrGridValues(grid%octreeRoot, octVec, grid=grid, startOctal=startOctal, &
                           foundOctal=neighbourOctal, foundsubcell=neighbourSubcell)
                      eDens(-1, 0, 0) = neighbourOctal%eDens(neighbourSubcell)
                      dCoeff(-1, 0, 0) = neighbourOctal%diffusionCoeff(neighbourSubcell)
                   else
                      eDens(-1, 0, 0) = eDens(0, 0, 0)
                      dCoeff(-1, 0, 0) = dCoeff(0, 0, 0)
                   endif
                   ! positive y

                   octVec = subcellCentre(thisOctal, subcell) + OCTALVECTOR(0.d0, r, 0.d0)
                   if (inOctal(grid%octreeRoot, octVec)) then
                      startOctal => thisOctal
                      call amrGridValues(grid%octreeRoot, octVec, grid=grid, startOctal=startOctal, &
                           foundOctal=neighbourOctal, foundsubcell=neighbourSubcell)
                      eDens(0, 1, 0) = neighbourOctal%eDens(neighboursubcell)
                      dCoeff(0, 1, 0) = neighbourOctal%diffusionCoeff(neighboursubcell)
                   else
                      eDens(0, 1, 0) = eDens(0, 0, 0)
                      dCoeff(0, 1, 0) = dCoeff(0, 0, 0)
                   endif
                   ! negative y

                   octVec = subcellCentre(thisOctal, subcell) - OCTALVECTOR(0.d0, r, 0.d0)
                   if (inOctal(grid%octreeRoot, octVec)) then
                      startOctal => thisOctal
                      call amrGridValues(grid%octreeRoot, octVec, grid=grid, startOctal=startOctal, &
                           foundOctal=neighbourOctal, foundsubcell=neighbourSubcell)
                      eDens(0, -1, 0) = neighbourOctal%eDens(neighbourSubcell)
                      dCoeff(0, -1, 0) = neighbourOctal%diffusionCoeff(neighbourSubcell)
                   else
                      eDens(0, -1, 0) = eDens(0, 0, 0)
                      dCoeff(0, -1, 0) = dCoeff(0, 0, 0)
                   endif

                   ! positive z

                   octVec = subcellCentre(thisOctal, subcell) + OCTALVECTOR(0.d0, 0.d0, r)
                   if (inOctal(grid%octreeRoot, octVec)) then
                      startOctal => thisOctal
                      call amrGridValues(grid%octreeRoot, octVec, grid=grid, startOctal=startOctal, &
                           foundOctal=neighbourOctal, foundsubcell=neighbourSubcell)
                      eDens(0, 0, 1) = neighbourOctal%eDens(neighbourSubcell)
                      dCoeff(0, 0, 1) = neighbourOctal%diffusionCoeff(neighbourSubcell)
                   else
                      eDens(0, 0, 1) = eDens(0, 0, 0)
                      dCoeff(0, 0, 1) = dCoeff(0, 0, 0)
                   endif

                   ! negative z

                   octVec = subcellCentre(thisOctal, subcell) - OCTALVECTOR(0.d0, 0.d0, r)
                   if (inOctal(grid%octreeRoot, octVec)) then
                      startOctal => thisOctal
                      call amrGridValues(grid%octreeRoot, octVec, grid=grid, startOctal=startOctal, &
                           foundOctal=neighbourOctal, foundsubcell=neighbourSubcell)
                      eDens(0,  0, -1) = neighbourOctal%eDens(neighbourSubcell)
                      dCoeff(0, 0, -1) = neighbourOctal%diffusionCoeff(neighbourSubcell)
                   else
                      eDens(0, 0, -1) = eDens(0, 0, 0)
                      dCoeff(0, 0, -1) = dCoeff(0, 0, 0)
                   endif
                endif

                gradE = sqrt((eDens(1,0,0)-eDens(-1,0,0))**2 + &
                     (eDens(0,1,0)-eDens(0,-1,0))**2 + &
                     (eDens(0,0,1)-eDens(0,0,-1))**2)
                gradE = abs(gradE) / (2.d0*thisOctal%subcellsize*1.e10)
                bigR = gradE / (eDens(0,0,0) * (thisOctal%kappaRoss(subcell) * thisOctal%rho(subcell)))
                lambda = (2.d0 + bigR) / (6.d0 + 3.d0*bigR + bigR**2)

                dCoeffHalf = 0.d0

                dCoeffHalf(1, 0, 0) = 0.5d0 * (dCoeff(1, 0, 0) + dCoeff(0, 0, 0))
                dCoeffHalf(-1, 0, 0) = 0.5d0 * (dCoeff(0, 0, 0) + dCoeff(-1, 0, 0))

                dCoeffHalf(0, 1, 0) = 0.5d0 * (dCoeff(0, 1, 0) + dCoeff(0, 0, 0))
                dCoeffHalf(0, -1, 0) = 0.5d0 * (dCoeff(0, 0, 0) + dCoeff(0, -1, 0))

                dCoeffHalf(0, 0, 1) = 0.5d0 * (dCoeff(0, 0, 1) + dCoeff(0, 0, 0))
                dCoeffHalf(0, 0, -1) = 0.5d0 * (dCoeff(0, 0, 0) + dCoeff(0, 0, -1))

                dCoeffHalf(-1:1,-1:1,-1:1) = dCoeffHalf(-1:1,-1:1,-1:1) * lambda

                DeltaX = r * 1.d10
                DeltaT = DeltaX**2 / (2.d0 * maxval(dcoeffHalf(-1:1,-1:1,-1:1)))

                DeltaT = deltaT * 0.5

                if (thisOctal%twoD) then
                   enplus1 = eDens(0,0,0) + (DeltaT/DeltaX**2) * (dCoeffHalf(1,0,0)*(eDens(1,0,0)-eDens(0,0,0)) &
                        - dCoeffHalf(-1,0,0)*(eDens(0,0,0)-eDens(-1,0,0)) &
                        + dCoeffHalf(0,0,1)*(eDens(0,0,1)-eDens(0,0,0)) &
                        - dCoeffHalf(0,0,-1)*(eDens(0,0,0)-eDens(0,0,-1)))
                else
                   enplus1 = eDens(0,0,0) + (DeltaT/DeltaX**2) * &
                        (  dCoeffHalf(1,0,0)*(eDens(1,0,0)-eDens(0,0,0)) &
                        - dCoeffHalf(-1,0,0)*(eDens(0,0,0)-eDens(-1,0,0)) &
                        + dCoeffHalf(0,1,0)*(eDens(0,1,0)-eDens(0,0,0)) &
                        - dCoeffHalf(0,-1,0)*(eDens(0,0,0)-eDens(0,-1,0)) &
                        + dCoeffHalf(0,0,1)*(eDens(0,0,1)-eDens(0,0,0)) &
                        - dCoeffHalf(0,0,-1)*(eDens(0,0,0)-eDens(0,0,-1)))
                endif
                if (enPlus1 < 0.d0) then
                   write(*,*) "Warning: negative energy density."
                   enPlus1 = arad*(10.d0**4)
                endif
                !          thisOctal%eDens(subcell) = enPlus1
                thisOctal%chiline(subcell) = enPlus1
                !          thisOctal%temperature(subcell) = (enPlus1 / aRad)**0.25d0

                deltaE = abs(enPlus1-thisOctal%oldeDens(subcell)) &
                     / thisOctal%oldEdens(subcell)
                deMaxArray(my_rank) = max(deMaxArray(my_rank), deltae)
             endif

          endif
       enddo
    enddo

!$MPI if (.not.blockHandout) exit blockloop
!$MPI end do blockLoop       
!$MPI end if ! (my_rank /= 0)

!$MPI    allocate(tempDoubleArray(np))
!$MPI    tempDoubleArray = 0.d0
!$MPI    call MPI_ALLREDUCE(deMaxArray,tempDoubleArray,np,MPI_DOUBLE_PRECISION,&
!$MPI         MPI_SUM,MPI_COMM_WORLD,ierr)
!$MPI    deMax = MAXVAL(tempDoubleArray)
!$MPI    deMaxArray = tempDoubleArray
!$MPI   deallocate(tempDoubleArray)

!$MPI  !   print *,'Process ',my_rank,' waiting to update values in Jacobi sweep...' 
!$MPI     call MPI_BARRIER(MPI_COMM_WORLD, ierr) 
!$MPI
!$MPI     ! have to send out the 'octalsBelongRank' array
!$MPI     call MPI_BCAST(octalsBelongRank,SIZE(octalsBelongRank),  &
!$MPI                    MPI_INTEGER, 0, MPI_COMM_WORLD, ierr)
!$MPI     call MPI_BARRIER(MPI_COMM_WORLD, ierr) 
!$MPI
!$MPI       !
!$MPI       ! Update the edens values of grid computed by all processors.
!$MPI       !
!$MPI       do iOctal = 1, SIZE(octalArray)
!$MPI       !   print *,'Process ',my_rank,' starting octal ',iOctal 
!$MPI
!$MPI       !   if (my_rank==0)   print *,'Root reports rank ',octalsBelongRank(ioctal), 'for octal',ioctal
!$MPI          thisOctal => octalArray(iOctal)%content
!$MPI          
!$MPI          do iSubcell = 1, thisOctal%maxChildren
!$MPI             if (octalArray(iOctal)%inUse(iSubcell).and. &
!$MPI                     octalArray(iOctal)%content%diffusionApprox(iSubcell)) then
!$MPI                
!$MPI                call MPI_BCAST(thisOctal%chiline(iSubcell), 1, MPI_DOUBLE_PRECISION,&
!$MPI                     octalsBelongRank(iOctal), MPI_COMM_WORLD, ierr)
!$MPI             end if
!$MPI          
!$MPI          end do
!$MPI       end do
!$MPI          
!$MPI          
!$MPI  !   print *,'Process ',my_rank,' finished updating values in Jacobi sweep...' 
!$MPI     call MPI_BARRIER(MPI_COMM_WORLD, ierr) 

    
    if (deMax > tol) converged = .false.
    deallocate(octalArray)
    deallocate(demaxArray)
end subroutine jacobiSweep

  subroutine solveArbitraryDiffusionZones(grid)
!$MPI    include 'mpif.h'
    type(GRIDTYPE) :: grid
    logical :: gridConverged
    real :: dummy(1)
    real(double) :: deMax
    integer :: niter
    integer, parameter :: maxIter = 100
    integer :: my_rank, ierr

!$MPI    ! FOR MPI IMPLEMENTATION=======================================================
!$MPI    !  Get my process rank # 
!$MPI    call MPI_COMM_RANK(MPI_COMM_WORLD, my_rank, ierr)

    call seteDens(grid, grid%octreeRoot)
    call setDiffusionCoeff(grid, grid%octreeRoot)
    gridconverged = .false.
    nIter = 0
     do while (.not.gridconverged)
        nIter = nIter + 1
        gridconverged = .true.
        deMax = -1.e30
        call jacobiSweep(grid, 0.05d0, demax, gridConverged)
        call copyEdens(grid%octreeRoot)
        call setDiffusionCoeff(grid, grid%octreeRoot)
!$MPI !if (my_rank == 0) then
      !  write(*,*) nIter," Maximum relative change in eDens:",deMax
!        call plot_AMR_values(grid, "temperature", "x-z", real(grid%octreeRoot%centre%y), &
!             "/xs", .true., .false., &
!             0, dummy, dummy, dummy, real(grid%octreeRoot%subcellsize), .false.,boxfac=0.01) 
!$MPI  !endif
        if (nIter < 3) gridConverged = .false.
        if (nIter > maxIter) then
!$MPI if (my_rank == 0) &
           write(*,*) "No solution found after ",maxIter," iterations"
           gridConverged = .true.
        endif
     enddo
   end subroutine solveArbitraryDiffusionZones


  recursive subroutine defineDiffusionOnUndersampled(thisOctal)
    type(octal), pointer   :: thisOctal
    type(octal), pointer  :: child
    integer :: subcell
    integer :: i

    do subcell = 1, thisOctal%maxChildren
       if (thisOctal%hasChild(subcell)) then
          ! find the child
          do i = 1, thisOctal%nChildren, 1
             if (thisOctal%indexChild(i) == subcell) then
                child => thisOctal%child(i)
                call defineDiffusionOnUndersampled(child)
                exit
             end if
          end do
       else
          if (thisOctal%undersampled(subcell)) then
             thisOctal%diffusionApprox(subcell) = .true.
          endif
       end if
    end do

  end subroutine defineDiffusionOnUndersampled

  recursive subroutine defineDiffusionOnRosseland(grid, thisOctal)
    use input_variables, only : tauDiff 
    type(GRIDTYPE) :: grid
    type(octal), pointer   :: thisOctal
    type(octal), pointer  :: child
    integer :: subcell
    integer :: i
    real(double) :: kRos, tau
    do subcell = 1, thisOctal%maxChildren
       if (thisOctal%hasChild(subcell)) then
          ! find the child
          do i = 1, thisOctal%nChildren, 1
             if (thisOctal%indexChild(i) == subcell) then
                child => thisOctal%child(i)
                call defineDiffusionOnRosseland(grid, child)
                exit
             end if
          end do
       else
          call returnKappa(grid, thisOctal, subcell, rosselandKappa=kros)
          tau = kros * thisOctal%rho(subcell) * thisOctal%subcellSize *1.e10
          if (tau > taudiff) then
             thisOctal%diffusionApprox(subcell) = .true.
          else
             thisOctal%diffusionApprox(subcell) = .false.
          endif
       end if
    end do

  end subroutine defineDiffusionOnRosseland

  recursive subroutine resetDiffusionTemp(thisOctal, temp)
    type(octal), pointer   :: thisOctal
    type(octal), pointer  :: child
    integer :: subcell
    integer :: i
    real :: temp
    do subcell = 1, thisOctal%maxChildren
       if (thisOctal%hasChild(subcell)) then
          ! find the child
          do i = 1, thisOctal%nChildren, 1
             if (thisOctal%indexChild(i) == subcell) then
                child => thisOctal%child(i)
                call resetDiffusionTemp(child, temp)
                exit
             end if
          end do
       else
          if (thisOctal%diffusionApprox(subcell)) then
             thisOctal%temperature(subcell) = temp
             thisOctal%eDens(subcell) = arad * temp**4
          endif
       end if
    end do

  end subroutine resetDiffusionTemp

  recursive subroutine copyEdens(thisOctal)
    type(octal), pointer   :: thisOctal
    type(octal), pointer  :: child
    integer :: subcell
    integer :: i
    real :: temp
    do subcell = 1, thisOctal%maxChildren
       if (thisOctal%hasChild(subcell)) then
          ! find the child
          do i = 1, thisOctal%nChildren, 1
             if (thisOctal%indexChild(i) == subcell) then
                child => thisOctal%child(i)
                call copyEdens(child)
                exit
             end if
          end do
       else
          if (thisOctal%diffusionApprox(subcell)) then
             thisOctal%eDens(subcell) = thisOctal%chiLine(subcell)
          endif
       end if
    end do

  end subroutine copyEdens


  subroutine randomWalk(grid, startOctal, startSubcell,  endOctal, endSubcell, temp)
    type(GRIDTYPE) :: grid
    type(OCTAL), pointer :: startOctal, endOctal, walkOctal, sOctal
    type(OCTALVECTOR) :: rVec
    type(OCTALVECTOR) :: xAxis, yAxis,zAxis
    real :: temp
    integer :: startSubcell, endSubcell, walkSubcell
    real :: r

    xAxis = OCTALVECTOR(1.d0, 0.d0, 0.d0)
    yAxis = OCTALVECTOR(0.d0, 1.d0, 0.d0)
    zAxis = OCTALVECTOR(0.d0, 0.d0, 1.d0)
    walkOctal => startOctal
    walkSubcell = startSubcell
    rVec = subcellCentre(walkOctal, walkSubcell)

    do while(walkOctal%diffusionApprox(walkSubcell))


       if (startOctal%twoD) then
          call random_number(r)
          rVec = subcellCentre(walkOctal, walkSubcell)
          
          if (r < 0.25) then
             rVec = rVec + (walkOctal%subcellSize/2.d0+grid%halfSmallestsubcell)*xAxis
          else if ((r >= 0.25).and.(r < 0.5)) then
             rVec = rVec - (walkOctal%subcellSize/2.d0+grid%halfSmallestsubcell)*xAxis
          else if ((r >= 0.5).and.(r < 0.75)) then
             rVec = rVec + (walkOctal%subcellSize/2.d0+grid%halfSmallestsubcell)*zAxis
          else if (r >= 0.75) then
             rVec = rVec - (walkOctal%subcellSize/2.d0+grid%halfSmallestsubcell)*zAxis
          endif
          sOctal => walkOctal
          temp = walkOctal%temperature(walkSubcell)
          if (.not.inOctal(grid%octreeRoot, rVec)) then
             rVec = subcellCentre( walkOctal, walkSubcell)
          endif
          call amrgridvalues(grid%octreeRoot, rVec, startOctal=sOctal, foundOctal=walkOctal, foundSubcell=walkSubcell)
       else
          call random_number(r)
          rVec = subcellCentre(walkOctal, walkSubcell)
          
          if (r < 0.166666) then
             rVec = rVec + (walkOctal%subcellSize/2.d0+grid%halfSmallestsubcell)*xAxis
          else if ((r >= 0.166666).and.(r < 0.333333)) then
             rVec = rVec - (walkOctal%subcellSize/2.d0+grid%halfSmallestsubcell)*xAxis
          else if ((r >= 0.333333).and.(r < 0.5)) then
             rVec = rVec + (walkOctal%subcellSize/2.d0+grid%halfSmallestsubcell)*yAxis
          else if ((r >= 0.5).and.(r < 0.666666)) then
             rVec = rVec - (walkOctal%subcellSize/2.d0+grid%halfSmallestsubcell)*yAxis
          else if ((r >= 0.6666666).and.(r < 0.833333)) then
             rVec = rVec + (walkOctal%subcellSize/2.d0+grid%halfSmallestsubcell)*zAxis
          else if (r >= 0.8333333) then
             rVec = rVec - (walkOctal%subcellSize/2.d0+grid%halfSmallestsubcell)*zAxis
          endif
          sOctal => walkOctal
          temp = walkOctal%temperature(walkSubcell)
          if (.not.inOctal(grid%octreeRoot, rVec)) then
             rVec = subcellCentre( walkOctal, walkSubcell)
          endif
          call amrgridvalues(grid%octreeRoot, rVec, startOctal=sOctal, foundOctal=walkOctal, foundSubcell=walkSubcell)
       endif
    enddo
    endOctal => walkOctal
    endSubcell = walkSubcell
  end subroutine randomWalk




end module diffusion_mod





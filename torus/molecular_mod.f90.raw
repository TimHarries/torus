module molecular_mod

! written by tjh


  use kind_mod
  use constants_mod
  use utils_mod
  use messages_mod
  use grid_mod
  use math_mod
!$MPI    use parallel_mod

  implicit none



  type MOLECULETYPE
     character(len=10) :: molecule
     real :: molecularweight
     real(double) :: abundance
     integer :: nLevels
     real(double), pointer :: energy(:)
     real(double), pointer :: g(:)
     real(double), pointer :: j(:)
     integer :: nTrans
     real(double), pointer :: einsteinA(:)
     real(double), pointer :: einsteinBlu(:)
     real(double), pointer :: einsteinBul(:)
     real(double), pointer :: transfreq(:)
     integer, pointer :: itransUpper(:)
     integer, pointer :: itransLower(:)
     real(double), pointer :: Eu(:)
     integer, pointer :: iCollUpper(:,:)
     integer, pointer :: iCollLower(:,:)
     integer :: nCollPart
     character(len=20), pointer :: collBetween(:)
     integer, pointer :: nCollTrans(:)
     integer, pointer :: nCollTemps(:)
     real(double), pointer :: collTemps(:,:)
     real(double), pointer :: collRates(:,:,:)
  end type MOLECULETYPE


  type DATACUBE
     character(len=80) :: label
     integer :: nx
     integer :: ny
     integer :: nv
     real(double), pointer :: xAxis(:)
     real(double), pointer :: yAxis(:)
     real(double), pointer :: vAxis(:)
     real(double), pointer :: intensity(:,:,:)
  end type DATACUBE

contains


  subroutine initCube(thisCube, nx, ny, nv)
    type(DATACUBE) :: thisCube
    integer :: nx, ny, nv

    thisCube%nx = nx
    thisCube%ny = ny
    thisCube%nv = nv
    allocate(thisCube%xAxis(1:nx))
    allocate(thisCube%yAxis(1:ny))
    allocate(thisCube%vAxis(1:nv))
    allocate(thisCube%intensity(1:nx,1:ny,1:nv))

    thisCube%intensity = 0.d0

  end subroutine initCube

  subroutine addSpatialAxes(cube, xMin, xMax, yMin, yMax)
    type(DATACUBE) :: cube
    real(double) :: xMin, xMax, yMax, yMin
    integer :: i

    do i = 1, cube%nx
       cube%xAxis(i) = xmin + (xmax-xmin)*dble(i-1)/dble(cube%nx)
    enddo
    do i = 1, cube%ny
       cube%yAxis(i) = ymin + (ymax-ymin)*dble(i-1)/dble(cube%ny)
    enddo
  end subroutine addSpatialAxes

  subroutine addVelocityAxis(cube, vMin, vMax)
    type(DATACUBE) :: cube
    real(double) :: vMin, vMax
    integer :: i

    do i = 1, cube%nv
       cube%vAxis(i) = vmin + (vmax-vmin)*dble(i-1)/dble(cube%nv)
    enddo
  end subroutine addVelocityAxis

  subroutine readMolecule(thisMolecule, molFilename)
    type(MOLECULETYPE) :: thisMolecule
    character(len=*) :: molFilename
    character(len=80) :: junk, message
    character(len=200):: dataDirectory, filename
    integer :: i, j, iLow, iUp, iPart
    real(double) :: a, freq, eu, c(20)

    thisMolecule%abundance = 1.d-9 ! fixed at benchmark value here

    call unixGetenv("TORUS_DATA", dataDirectory, i)
    filename = trim(dataDirectory)//"/"//molfilename

    open(30, file=filename, status="old", form="formatted")

    read(30,*) junk
    read(30,'(a)') thisMolecule%molecule

    call writeInfo("Reading data for molecule: "//trim(thisMolecule%molecule),IMPORTANT)
    read(30,*) junk
    read(30,*) thisMolecule%molecularWeight

    read(30,*) junk
    read(30,*) thisMolecule%nLevels

    allocate(thisMolecule%energy(1:thisMolecule%nLevels))
    allocate(thisMolecule%g(1:thisMolecule%nLevels))
    allocate(thisMolecule%j(1:thisMolecule%nLevels))

    read(30,*) junk
    do i = 1, thisMolecule%nLevels
       read(30,*) j, thisMolecule%energy(i), thisMolecule%g(i), thisMolecule%j(i)

       thisMolecule%energy(i) = thisMolecule%energy(i) / 8065.541  ! per cm to ev
       
    enddo

    read(30,*) junk
    read(30,*) thisMolecule%nTrans

    allocate(thisMolecule%einsteinA(1:thisMolecule%nTrans))
    allocate(thisMolecule%einsteinBul(1:thisMolecule%nTrans))
    allocate(thisMolecule%einsteinBlu(1:thisMolecule%nTrans))
    allocate(thisMolecule%transfreq(1:thisMolecule%nTrans))
    allocate(thisMolecule%itransUpper(1:thisMolecule%nTrans))
    allocate(thisMolecule%itransLower(1:thisMolecule%nTrans))
    allocate(thisMolecule%eu(1:thisMolecule%nTrans))
    read(30,*) junk
    do i = 1, thisMolecule%nTrans
       read(30,*) j, iUp, iLow, a, freq, eu

       thisMolecule%einsteinA(i) = a
       thisMolecule%transfreq(i) = freq*1.d9
       thisMolecule%eu(i) = eu
       thisMolecule%itransUpper(i) = iUp
       thisMolecule%itransLower(i) = iLow

       thisMolecule%einsteinBul(i) = a * (cspeed**2)/(2.d0*hcgs*(freq*1.d9)**3)

       thisMolecule%einsteinBlu(i) = thisMolecule%einsteinBul(i) &
            * thisMolecule%g(iUp)/thisMolecule%g(iLow)

    enddo

    read(30,*) junk
    read(30,*) thisMolecule%nCollPart
    
    allocate(thisMolecule%nCollTrans(1:thisMolecule%nCollPart))
    allocate(thisMolecule%nCollTemps(1:thisMolecule%nCollPart))
    allocate(thisMolecule%collTemps(1:thisMolecule%nCollPart, 1:20))
    allocate(thisMolecule%collBetween(1:thisMolecule%nCollPart))

    
    do iPart = 1, thisMolecule%nCollPart

       read(30,*) junk
       read(30,*) thisMolecule%collBetween(iPart)
       
       read(30,*) junk
       read(30,*) thisMolecule%nCollTrans(iPart)

       read(30,*) junk
       read(30,*) thisMolecule%nCollTemps(iPart)


       read(30,*) junk
       read(30,*) thisMolecule%collTemps(iPart,1:thisMolecule%nCollTemps(ipart))

       allocate(thisMolecule%collRates(1:thisMolecule%nCollPart, &
            1:thisMolecule%nCollTrans(iPart), 1:thisMolecule%nCollTemps(ipart)))
       allocate(thisMolecule%iCollUpper(1:thisMolecule%nCollPart, 1:thisMolecule%nCollTrans(iPart)))
       allocate(thisMolecule%iCollLower(1:thisMolecule%nCollPart, 1:thisMolecule%nCollTrans(iPart)))
       thisMolecule%collRates = 0.d0
       read(30,*) junk
       do j = 1, thisMolecule%nCollTrans(iPart)
          read(30,*) i, thisMolecule%iCollUpper(ipart,j), &
               thisMolecule%iCollLower(ipart,j), c(1:thisMolecule%nCollTemps(iPart))
          thisMolecule%collRates(iPart, j, 1:thisMolecule%nCollTemps(iPart)) = c(1:thisMolecule%nCollTemps(iPart))
       enddo
    enddo
    close(30)
    call writeInfo("Done.", IMPORTANT)
  end subroutine readMolecule

  subroutine readBenchmarkMolecule(thisMolecule, molFilename)
    type(MOLECULETYPE) :: thisMolecule
    character(len=*) :: molFilename
    character(len=80) :: junk, message
    character(len=200):: dataDirectory, filename
    integer :: i, j, iLow, iUp, iPart
    real(double) :: a, freq, eu, c(20)

    thisMolecule%abundance = 1.d-9 ! fixed at benchmark value here


    open(30, file=molfilename, status="old", form="formatted")

    read(30,'(a)') thisMolecule%molecule
    call writeInfo("Reading data for molecule: "//trim(thisMolecule%molecule),IMPORTANT)

    read(30,*) thisMolecule%molecularWeight

    read(30,*) thisMolecule%nLevels, thisMolecule%nTrans

    allocate(thisMolecule%energy(1:thisMolecule%nLevels))
    allocate(thisMolecule%g(1:thisMolecule%nLevels))
    allocate(thisMolecule%j(1:thisMolecule%nLevels))

    allocate(thisMolecule%einsteinA(1:thisMolecule%nTrans))
    allocate(thisMolecule%einsteinBul(1:thisMolecule%nTrans))
    allocate(thisMolecule%einsteinBlu(1:thisMolecule%nTrans))
    allocate(thisMolecule%transfreq(1:thisMolecule%nTrans))
    allocate(thisMolecule%itransUpper(1:thisMolecule%nTrans))
    allocate(thisMolecule%itransLower(1:thisMolecule%nTrans))
    allocate(thisMolecule%eu(1:thisMolecule%nTrans))


    read(30,'(7f11.7)') thisMolecule%energy(1:thisMolecule%nLevels)

    thisMolecule%energy = thisMolecule%energy / 8065.541  ! per cm to ev
       

    read(30,*) thisMolecule%g(1:thisMolecule%nLevels)
    thisMolecule%j(1:thisMolecule%nLevels) = (thisMolecule%g(1:thisMolecule%nLevels) - 1.d0)/2.d0

    read(30,*) thisMolecule%itransUpper(1:thisMolecule%nTrans)
    read(30,*) thisMolecule%itransLower(1:thisMolecule%nTrans)

    read(30,*) thisMolecule%einsteinA(1:thisMolecule%nTrans)
 
    do i = 1, thisMolecule%nTrans

       thisMolecule%transFreq(i) = ((thisMolecule%energy(thisMolecule%iTransUpper(i)) - &
            thisMolecule%energy(thisMolecule%iTransLower(i)))/ergToEV)/hcgs
       thisMolecule%einsteinBul(i) = thisMolecule%einsteinA(i) * (cspeed**2)/(2.d0*hcgs*thisMolecule%transFreq(i)**3)

       thisMolecule%einsteinBlu(i) = thisMolecule%einsteinBul(i) &
            * thisMolecule%g(thisMolecule%iTransUpper(i))/thisMolecule%g(thisMolecule%iTransLower(i))

    enddo

    read(30,*) junk

    thisMolecule%nCollPart = 1
    iPart = 1

    allocate(thisMolecule%nCollTrans(1:thisMolecule%nCollPart))
    allocate(thisMolecule%nCollTemps(1:thisMolecule%nCollPart))


    allocate(thisMolecule%collTemps(1:thisMolecule%nCollPart, 1:4))

    read(30,*) thisMolecule%nCollTrans(1), thisMolecule%nCollTemps(1),thisMolecule%collTemps(1,1:4)

    allocate(thisMolecule%iCollUpper(1:thisMolecule%nCollPart, 1:thisMolecule%nCollTrans(iPart)))
    allocate(thisMolecule%iCollLower(1:thisMolecule%nCollPart, 1:thisMolecule%nCollTrans(iPart)))

    allocate(thisMolecule%collRates(1:thisMolecule%nCollPart, &
         1:thisMolecule%nCollTrans(iPart), 1:thisMolecule%nCollTemps(ipart)))

    read(30,*) thisMolecule%iCollUpper(1, 1:thisMolecule%nCollTrans(1))
    read(30,*) thisMolecule%iCollLower(1, 1:thisMolecule%nCollTrans(1))
    do i = 1, thisMolecule%nCollTemps(1)
       read(30,*) thisMolecule%collRates(iPart,  1:thisMolecule%nCollTrans(ipart), i)
    enddo

    close(30)
    call writeInfo("Done.", IMPORTANT)
  end subroutine readBenchmarkMolecule


  subroutine solveLevels(nPops, jnu,  temperature, thisMolecule, nh2)
    real(double) :: nPops(:)
    real(double) :: temperature
    real(double) :: jnu(:)
    real(double) :: nh2
    type(MOLECULETYPE) :: thisMolecule
    real(double), allocatable :: matrixA(:,:), matrixB(:), collMatrix(:,:), cTot(:)
    real(double) :: arateji, boltzFac
    integer :: nLevels
    integer :: iLower, iUpper, iLevel, i, j
    integer :: itrans, l, k, iPart
    real(double) :: collEx, colldeEx

    nLevels = thisMolecule%nLevels

    allocate(matrixA(1:nLevels+1,1:nLevels+1))
    allocate(matrixB(1:nLevels+1))

    matrixA = 1.d-30
    matrixB = 0.d0

    matrixA(nLevels+1,1:nLevels+1) = 1.d0
    matrixA(1:nLevels+1,nLevels+1) = 1.d-30

    matrixB(nLevels+1) = 1.d0
    allocate(collMatrix(1:nLevels+1, 1:nLevels+1))


    do iTrans = 1, thisMolecule%nTrans

       k = thisMolecule%iTransUpper(iTrans)
       l = thisMolecule%iTransLower(iTrans)
    

       matrixA(k,k) = matrixA(k,k) + thisMolecule%einsteinBul(iTrans) * jnu(iTrans) + thisMolecule%einsteinA(iTrans)
       matrixA(l,l) = matrixA(l,l) + thisMolecule%einsteinBlu(iTrans) * jnu(iTrans)
       matrixA(k,l) = matrixA(k,l) - thisMolecule%einsteinBlu(iTrans) * jnu(iTrans)
       matrixA(l,k) = matrixA(l,k) - thisMolecule%einsteinBul(iTrans) * jnu(iTrans) - thisMolecule%einsteinA(iTrans)

    enddo


    collMatrix = 0.d0

    do iPart = 1, thisMolecule%nCollPart
       do iTrans = 1, thisMolecule%nCollTrans(iPart)
          
          k = thisMolecule%iCollUpper(iPart, iTrans)
          l = thisMolecule%iCollLower(iPart, iTrans)

          boltzFac =  exp(-abs(thisMolecule%energy(k)-thisMolecule%energy(l)) / (kev*temperature))
          colldeEx = collRate(thisMolecule, temperature, iPart, iTrans) * nh2! * (nh2 * thisMolecule%abundance)!!!!
          collEx = colldeEx * boltzFac * thisMolecule%g(k)/thisMolecule%g(l)


          collMatrix(l, k) = collMatrix(l, k) + collEx
          collMatrix(k, l) = collMatrix(k, l) + colldeEx

       enddo
    enddo

    allocate(cTot(1:thisMolecule%nLevels))
    cTot = 0.d0
    do k = 1, thisMolecule%nLevels
       do l = 1, thisMolecule%nLevels
          cTot(k) = cTot(k) + collMatrix(k,l)
       enddo
    enddo

    do i = 1, thisMolecule%nLevels
          matrixA(i,i) = matrixA(i,i) + cTot(i)
       do j = 1, thisMolecule%nLevels
          if (i /= j) then
             matrixA(i,j) = matrixA(i,j) - collMatrix(j, i)
          endif
       enddo
    enddo

  call luSlv(matrixA, matrixB, nLevels+1)



  nPops(1:nLevels) = matrixB(1:nLevels)


  
  deallocate(matrixA, matrixB, collMatrix, cTot)

  end subroutine solveLevels


  real(double) function collRate(thisMolecule, temperature, iPart, iTrans)
    type(MOLECULETYPE) :: thisMolecule
    real(double) :: temperature, r
    integer :: i, iTrans, k, iPart

    collRate = 0.d0

       
    call locate(thisMolecule%collTemps(iPart,1:thisMolecule%nCollTemps(iPart)), &
         thisMolecule%nCollTemps(iPart), temperature, k)

    r = (temperature - thisMolecule%collTemps(iPart,k)) / &
         (thisMolecule%collTemps(iPart,k+1) - thisMolecule%collTemps(iPart, k))

    collRate = collRate + thisMolecule%collRates(iPart, iTrans, k) + &
         r * ( thisMolecule%collRates(iPart, iTrans, k+1) -  thisMolecule%collRates(iPart, iTrans, k))

  end function collRate


  recursive subroutine  solveAllPops(grid, thisOctal, thisMolecule)
    type(GRIDTYPE) :: grid
    type(MOLECULETYPE) :: thisMolecule
    type(octal), pointer   :: thisOctal
    type(octal), pointer  :: child 
    integer :: subcell, i, iUpper, iLower
    real(double) :: etaLine
  
    do subcell = 1, thisOctal%maxChildren
       if (thisOctal%hasChild(subcell)) then
          ! find the child
          do i = 1, thisOctal%nChildren, 1
             if (thisOctal%indexChild(i) == subcell) then
                child => thisOctal%child(i)
                call solveAllpops(grid, child, thisMolecule)
                exit
             end if
          end do
       else
          call solveLevels(thisOctal%molecularLevel(subcell,1:thisMolecule%nLevels), &
               thisOctal%jnu(subcell,1:thisMolecule%nTrans),  &
               dble(thisOctal%temperature(subcell)), thisMolecule, thisOctal%nh2(subcell))
       endif
    enddo
  end subroutine solveAllPops

  recursive subroutine  swapPops(thisOctal, maxFracChange)
    type(GRIDTYPE) :: grid
    type(MOLECULETYPE) :: thisMolecule
    type(octal), pointer   :: thisOctal
    type(octal), pointer  :: child 
    integer :: subcell, i, iUpper, iLower
    real(double) :: maxFracChange
  
    do subcell = 1, thisOctal%maxChildren
       if (thisOctal%hasChild(subcell)) then
          ! find the child
          do i = 1, thisOctal%nChildren, 1
             if (thisOctal%indexChild(i) == subcell) then
                child => thisOctal%child(i)
                call swapPops(child, maxFracChange)
                exit
             end if
          end do
       else
          where(thisOctal%newMolecularLevel(subcell,:) /= 0.d0)
             maxFracChange = max(maxFracChange, &
                  MAXVAL(abs((thisOctal%newMolecularLevel(subcell,:) - &
                  thisOctal%molecularLevel(subcell,:)) / &
                  thisOctal%newmolecularLevel(subcell,:))))
          end where
          thisOctal%molecularLevel(subcell,1:thisMolecule%nLevels) = &
               thisOctal%newmolecularLevel(subcell,1:thisMolecule%nLevels)
       endif
    enddo
  end subroutine swapPops

  recursive subroutine  allocateMolecularLevels(grid, thisOctal, thisMolecule)
    type(GRIDTYPE) :: grid
    type(MOLECULETYPE) :: thisMolecule
    type(octal), pointer   :: thisOctal
    type(octal), pointer  :: child 
    integer :: subcell, i, iUpper, iLower
    real(double) :: etaLine
  
  do subcell = 1, thisOctal%maxChildren
       if (thisOctal%hasChild(subcell)) then
          ! find the child
          do i = 1, thisOctal%nChildren, 1
             if (thisOctal%indexChild(i) == subcell) then
                child => thisOctal%child(i)
                call allocateMolecularLevels(grid, child, thisMolecule)
                exit
             end if
          end do
       else

          if (.not.associated(thisOctal%molecularLevel)) then
             allocate(thisOctal%molecularLevel(1:thisOctal%maxChildren, 1:thisMolecule%nLevels))
          endif
          thisOctal%molecularLevel = 1.d-30

          if (.not.associated(thisOctal%newmolecularLevel)) then
             allocate(thisOctal%newmolecularLevel(1:thisOctal%maxChildren, 1:thisMolecule%nLevels))
          endif
          thisOctal%newmolecularLevel = 1.d-30

          if (.not.associated(thisOctal%jnu)) then
             allocate(thisOctal%jnu(1:thisOctal%maxChildren, 1:thisMolecule%nTrans))
          endif
          do i = 1, thisMolecule%nTrans
             thisOctal%jnu(subcell,i) = bnu(thisMolecule%transFreq(i), dble(thisOctal%temperature(subcell)))
          enddo
          thisOctal%jnu = 1.d-30
       endif
    enddo
  end subroutine allocateMolecularLevels




  function phiProf(dv, b) result (phi)
    real(double) :: dv, b
    real(double) :: fac, phi
    phi = 1.d0 / (b * sqrt(Pi))
    fac = dv**2 / b**2
    phi = phi * exp(-fac)
  end function phiProf




  subroutine getRay(grid, fromOctal, fromSubcell, position, direction, ds, phi, i0, thisMolecule)
    type(MOLECULETYPE) :: thisMolecule
    type(GRIDTYPE) :: grid
    type(OCTAL), pointer :: thisOctal, startOctal, fromOctal
    integer :: fromSubcell
    integer :: subcell
    real(double) :: ds, phi, i0(:), r, phi1, phi2
    integer :: iTrans
    type(OCTALVECTOR) :: position, direction, currentPosition, thisPosition, thisVel
    type(OCTALVECTOR) :: rayVel, startVel, endVel, endPosition
    real(double) :: alphanu, snu, jnu
    integer :: iLower , iUpper
    real(double) :: dv, deltaV
    integer :: i
    real(double) :: distArray(200), tval
    integer :: nTau
    real(double) :: nLower, nUpper
    real(double) :: dTau, etaline, didtau
    real(double), allocatable :: tau(:)
    real(double) :: intensityIntegral
    real(double) :: dvAcrossCell, projVel
    integer :: iCount

    allocate(tau(1:thisMolecule%nTrans))
    
    position = randomPositionInCell(fromOctal, fromsubcell)

    icount = 1
    thisOctal => grid%octreeRoot
    call findSubcellLocal(position, thisOctal, subcell)


    direction = randomUnitVector()
    call random_number(r)
!    if (r < 0.1) then
!       direction = position
!       call normalize(direction)
!       direction = (-1.d0) * direction
!    endif

    rayVel = amrGridVelocity(grid%octreeRoot, position, startOctal = thisOctal, actualSubcell = subcell)

    call random_number(r)

    deltaV = 4.3 * thisOctal%microturb(subcell) * (r-0.5d0)


    deltaV = deltaV +  (rayVel .dot. direction)

    projVel = deltaV - (rayVel .dot. direction)

    phi1 = phiProf(projVel, thisOctal%microturb(subcell))

    call distanceToCellBoundary(grid, position, direction, ds, sOctal=thisOctal)

    currentPosition = position + ds * direction

    phi2 = phi1 
    if (inOctal(grid%octreeRoot, currentPosition)) then
       thisVel = amrGridVelocity(grid%octreeRoot, currentPosition, startOctal = thisOctal) 
       projVel = deltaV - (thisVel.dot.direction)
       
       phi2 = phiProf(projVel, thisOctal%microturb(subcell))
    else
       phi2 = phi1
    endif

    phi  = (phi1 + phi2)/2.d0
!    if (modulus(thisVel) /= 0.d0) &
!    write(*,*) phi1,phi2,phi
    ds = ds * 1.d10



    i0 = 0.d0
    intensityIntegral = 0.0
    tau = 0.d0



    do while(inOctal(grid%octreeRoot, currentPosition))

       call findSubcellLocal(currentPosition, thisOctal, subcell)
       call distanceToCellBoundary(grid, currentPosition, direction, tVal, sOctal=thisOctal)

       startVel = amrGridVelocity(grid%octreeRoot, currentPosition, startOctal = thisOctal, actualSubcell = subcell) 
       endPosition = currentPosition + tval * direction
       endVel = amrGridVelocity(grid%octreeRoot, endPosition)

       dvAcrossCell = ((startVel - rayVel).dot.direction) - ((endVel - rayVel).dot.direction)
       dvAcrossCell = abs(dvAcrossCell / (thisOctal%microturb(subcell)/2.35d0))


       nTau = min(max(2, nint(dvAcrossCell * 20.d0)),200)
!       write(*,*) ntau

       distArray(1) = 0.d0
       do i = 2, nTau
          
          distArray(i) = tval * dble(i-1)/dble(nTau-1)

          startOctal => thisOctal
          thisPosition = currentPosition + distArray(i)*direction
          thisVel = amrGridVelocity(grid%octreeRoot, thisPosition, startOctal = startOctal, actualSubcell = subcell) 


          dv = deltaV - (thisVel .dot. direction)
!          write(*,*) icount,dv*cspeed/1.d5,modulus(thisPosition)
          icount = icount + 1

          do iTrans = 1, thisMolecule%nTrans
             alphanu = (hCgs*thisMolecule%transFreq(iTrans)/fourPi) * &
                  phiProf(dv, thisOctal%microturb(subcell))/thisMolecule%transFreq(iTrans)

             iUpper = thisMolecule%iTransUpper(iTrans)
             iLower = thisMolecule%iTransLower(iTrans)
             
             nLower = thisOctal%molecularLevel(subcell,iLower) * thisMolecule%abundance * thisOctal%nh2(subcell)
             nUpper = thisOctal%molecularLevel(subcell,iUpper) * thisMolecule%abundance * thisOctal%nh2(subcell)

             alphanu = alphanu * (nLower * thisMolecule%einsteinBlu(iTrans) - &
                  nUpper * thisMolecule%einsteinBul(iTrans))

             dTau = alphaNu *  (distArray(i)-distArray(i-1)) * 1.d10

             etaLine = hCgs * thisMolecule%einsteinA(iTrans) * thisMolecule%transFreq(iTrans)
             etaLine = etaLine * thisOctal%nh2(subcell) * thisMolecule%abundance * thisOctal%molecularLevel(subcell, iUpper)
             jnu = (etaLine/fourPi) * phiProf(dv, thisOctal%microturb(subcell))/thisMolecule%transFreq(iTrans)



             if (alphanu /= 0.d0) then
                snu = jnu/alphanu
             else
                snu = tiny(snu)
             endif

             i0(iTrans) = i0(iTrans) +  exp(-tau(iTrans)) * (1.d0-exp(-dtau))*snu
             tau(iTrans) = tau(iTrans) + dtau
          enddo
       enddo
       currentPosition = currentPosition + (distArray(ntau)+1.d-3*grid%halfSmallestSubcell) * direction
    enddo
    do iTrans = 1, thisMolecule%nTrans
       i0(iTrans) = i0(iTrans) + bnu(thisMolecule%transFreq(iTrans), Tcbr) * exp(-tau(iTrans))
    enddo
    deallocate(tau)
  end subroutine getRay



  subroutine dumpResults(grid, thisMolecule)
    type(GRIDTYPE) :: grid
    type(MOLECULETYPE) :: thisMolecule
    integer :: nr
    real(double) :: r, ang
    integer :: i
    real(double) :: pops(10)
    type(OCTAL), pointer :: thisOctal
    integer :: subcell
    integer :: j
    real(double) :: x, z
    type(OCTALVECTOR) :: posvec
    real(double) :: router, rinner, jnu
    
    rinner = 1.e6
    router  = 4.6e7
    
    nr = 20
    open(31,file="results.dat",status="unknown",form="formatted")
    do i = 1, nr
       r = log10(rinner) + dble(i-1)/dble(nr-1)*(log10(router) - log10(rinner))
       r = 10.d0**r
       pops = 0.d0
       jnu = 0.d0
       do j = 1 , 20
          call random_number(ang)
          ang = ang * pi
          z = r*cos(ang)
          x = r*sin(ang)
          posVec = OCTALVECTOR(x, 0.d0, z)
          thisOctal => grid%octreeroot
          call findSubcellLocal(posVec, thisOctal,subcell)
          pops = pops + thisOctal%molecularLevel(subcell,1:10)
          jnu = jnu + thisOctal%jnu(subcell,1)
       enddo
       pops = pops / 20.d0
       jnu = jnu / 20.d0
       write(31,*) real(r*1.d10), real(pops(1:6)),jnu
    enddo
    close(31)
  end subroutine dumpResults

          
  subroutine molecularLoop(grid, thisMolecule)

    use input_variables, only : blockhandout
!$MPI    include 'mpif.h'

    type(GRIDTYPE) :: grid
    type(MOLECULETYPE) :: thisMolecule
    type(OCTALVECTOR) :: position, direction
    integer :: nOctal, iOctal, subcell
    real(double), allocatable :: ds(:), phi(:), i0(:,:), tau(:)
    integer :: nRay
    type(octalWrapper), allocatable :: octalArray(:) ! array containing pointers to octals
    type(OCTAL), pointer :: thisOctal
    integer, parameter :: maxIter = 100
    logical :: converged
    integer :: iRay, iTrans, iter,i 
    real(double), allocatable :: oldpops(:)
    real(double) :: fac
!$MPI    ! For MPI implementations
!$MPI    integer       ::   my_rank        ! my processor rank
!$MPI    integer       ::   np             ! The number of processes
!$MPI    integer       ::   ierr           ! error flag
!$MPI    logical       ::   rankComplete

     logical :: dcAllocated
     integer, dimension(:), allocatable :: octalsBelongRank
     real(double), allocatable :: tArrayd(:),tempArrayd(:)
     integer :: nVoxels
     integer :: ioctal_beg, ioctal_end, tag = 0
     real(double) :: maxFracChange


!$MPI    ! FOR MPI IMPLEMENTATION=======================================================
!$MPI    !  Get my process rank # 
!$MPI    call MPI_COMM_RANK(MPI_COMM_WORLD, my_rank, ierr)
!$MPI  
!$MPI    ! Find the total # of precessor being used in this run
!$MPI    call MPI_COMM_SIZE(MPI_COMM_WORLD, np, ierr)

    call allocateMolecularLevels(grid, grid%octreeRoot, thisMolecule)


    call solveAllPops(grid, grid%octreeRoot, thisMolecule)
!$MPI if (my_rank ==0 ) then
    write(*,*) "Dumping results",log10(bnu(thisMolecule%transFreq(1),2.782d0))
    call dumpresults(grid, thisMolecule)
!$MPI endif
    nRay = 100
    allocate(ds(1:nRay))
    allocate(phi(1:nRay))
    allocate(i0(1:thisMolecule%nTrans, 1:nRay))
    allocate(tau(1:nRay))

    allocate(oldPops(1:thisMolecule%nLevels))

    allocate(octalArray(grid%nOctals))
    nOctal = 0
    call getOctalArray(grid%octreeRoot,octalArray, nOctal)

    do while (.true.)


    ! default loop indecies
    ioctal_beg = 1
    ioctal_end = SIZE(octalArray)       
    


!$MPI    
!$MPI    ! we will use an array to store the rank of the process
!$MPI    !   which will calculate each octal's variables
!$MPI    allocate(octalsBelongRank(size(octalArray)))
!$MPI    
!$MPI    if (my_rank == 0) then
!$MPI       print *, ' '
!$MPI       print *, 'molecular  computed by ', np-1, ' processors.'
!$MPI       print *, ' '
!$MPI       call mpiBlockHandout(np,octalsBelongRank,blockDivFactor=1,tag=tag,&
!$MPI                            maxBlockSize=10,setDebug=.false.)
!$MPI    
!$MPI    endif
!$MPI    ! ============================================================================



!$MPI if (my_rank /= 0) then
!$MPI  blockLoop: do     
!$MPI call mpiGetBlock(my_rank,iOctal_beg,iOctal_end,rankComplete,tag,setDebug=.false.)
!$MPI   if (rankComplete) exit blockLoop 


       do iOctal = ioctal_beg, ioctal_end
          write(*,*) iOctal,ioctal_beg,ioctal_end
          thisOctal => octalArray(iOctal)%content
          do subcell = 1, thisOctal%maxChildren
             
             if (.not.thisOctal%hasChild(subcell)) then
                
                do iRay = 1, nRay
                   call getRay(grid, thisOCtal, subcell, position, direction, &
                        ds(iRay), phi(iRay), i0(1:thisMolecule%nTrans,iRay), &
                        thisMolecule)
                enddo
                iter = 0
                converged = .false.
                thisOctal%newMolecularLevel = thisOctal%molecularLevel
                do while (.not.converged)
                   iter = iter + 1
                   oldpops = thisOctal%molecularLevel(subcell,1:thisMolecule%nLevels)
                   do iTrans = 1, thisMolecule%nTrans
                      call calculateJbar(thisOctal, subcell, thisMolecule, nRay, ds(1:nRay), &
                           phi(1:nRay), i0(iTrans,1:nRay), iTrans, thisOctal%jnu(subcell,iTrans), &
                           thisOctal%newMolecularLevel(subcell,1:thisMolecule%nLevels))
                   enddo
                   call solveLevels(thisOctal%newMolecularLevel(subcell,1:thisMolecule%nLevels), &
                        thisOctal%jnu(subcell,1:thisMolecule%nTrans),  &
                        dble(thisOctal%temperature(subcell)), thisMolecule, thisOctal%nh2(subcell))
                   fac = maxval(abs((thisOctal%newMolecularLevel(subcell,1:thisMolecule%nLevels) - oldpops)/oldpops))
                   if (fac < 1.d-6) converged = .true.
                   if (iter == maxIter) converged = .true.
                enddo
             endif
          enddo
       end do

!$MPI if (.not.blockHandout) exit blockloop
!$MPI end do blockLoop        
!$MPI end if ! (my_rank /= 0)



!$MPI       if(my_rank == 0) write(*,*) "Updating MPI grids"


!$MPI     call MPI_BARRIER(MPI_COMM_WORLD, ierr) 
!$MPI
!$MPI     ! have to send out the 'octalsBelongRank' array
!$MPI     call MPI_BCAST(octalsBelongRank,SIZE(octalsBelongRank),  &
!$MPI                    MPI_INTEGER, 0, MPI_COMM_WORLD, ierr)
!$MPI     call MPI_BARRIER(MPI_COMM_WORLD, ierr) 
!$MPI
!$MPI     call countVoxels(grid%octreeRoot,nOctal,nVoxels)
!$MPI     allocate(tArrayd(1:nVoxels))
!$MPI     allocate(tempArrayd(1:nVoxels))
!$MPI     tArrayd = 0.d0
!$MPI     tempArrayd = 0.d0
!$MPI     do i = 1, thisMolecule%nLevels
!$MPI       tArrayd = 0.d0
!$MPI       call packMoleLevel(octalArray, nVoxels, tArrayd, octalsBelongRank, i)
!$MPI       call MPI_ALLREDUCE(tArrayd,tempArrayd,nVoxels,MPI_DOUBLE_PRECISION,&
!$MPI           MPI_SUM,MPI_COMM_WORLD,ierr)
!$MPI       tArrayd = tempArrayd
!$MPI       call unpackMoleLevel(octalArray, nVoxels, tArrayd, octalsBelongRank, i)
!$MPI     enddo
!$MPI     deallocate(tArrayd, tempArrayd)

!$MPI       if(my_rank == 0) write(*,*) "Done updating"



       maxFracChange = -1.d30
       call swapPops(grid%octreeRoot, maxFracChange)
       write(*,*) "Maximum fractional change this iteration",maxFracChange

!$MPI       if (my_rank == 0) &
            call writeAmrGrid("molecular_tmp.grid",.false.,grid)
!$MPI if (my_rank ==0 ) then
       write(*,*) "Dumping results"
       call dumpresults(grid, thisMolecule)
!$MPI endif

!$MPI       deallocate(octalsBelongRank)

    enddo

  end subroutine molecularLoop


  subroutine calculateJbar(thisOctal, subcell, thisMolecule, nRay, ds, phi, i0, iTrans, jbar, nPops)
    type(OCTAL), pointer :: thisOctal
    integer :: subcell
    type(MOLECULETYPE) :: thisMolecule
    integer :: nRay
    real(double) :: ds(:), phi(:), i0(:), nPops(:)
    integer :: iTrans
    real(double) :: jbar
    integer :: iRay
    real(double) :: nLower, nUpper
    real(double) :: jBarInternal, jBarExternal
    real(double) :: alphanu, jnu, etaline
    integer :: iUpper, iLower
    real(double) :: tau, snu, sumPhi

    jBarExternal = 0.d0
    jBarInternal = 0.d0

    iUpper = thisMolecule%iTransUpper(iTrans)
    iLower = thisMolecule%iTransLower(iTrans)

    sumPhi = 0.d0
    do iRay = 1, nRay
       alphanu = (hCgs*thisMolecule%transFreq(iTrans)/fourPi)
       nLower = nPops(iLower) * thisMolecule%abundance * thisOctal%nh2(subcell)
       nUpper = nPops(iUpper) * thisMolecule%abundance * thisOctal%nh2(subcell)
       
       alphanu = alphanu * (nLower * thisMolecule%einsteinBlu(iTrans) - &
            nUpper * thisMolecule%einsteinBul(iTrans)) * phi(iray)/thisMolecule%transFreq(iTrans)
       tau = alphaNu * ds(iray)

       etaLine = hCgs * thisMolecule%einsteinA(iTrans) * thisMolecule%transFreq(iTrans)
       etaLine = etaLine * thisOctal%nh2(subcell) * thisMolecule%abundance * nPops(iUpper)
       jnu = (etaLine/fourPi) * phi(iRay)/thisMolecule%transFreq(iTrans)
       
       if (alphanu /= 0.d0) then
          snu = jnu/alphanu
       else
          snu = tiny(snu)
       endif

       jBarExternal = jBarExternal + i0(iray) * exp(-tau) * phi(iRay)
       jBarInternal = jBarInternal + snu * (1.d0 - exp(-tau)) * phi(iRay)

       sumPhi = sumPhi + phi(iRay)
    enddo
    
!    jbar = (jBarExternal + jBarInternal)/dble(nRay)
     jbar = (jBarExternal + jBarInternal)/sumPhi

  end subroutine calculateJbar


  function intensityAlongRay(position, direction, grid, thisMolecule, iTrans, deltaV) result (i0)
    type(OCTALVECTOR) :: position, direction, startPosition
    type(GRIDTYPE) :: grid
    type(MOLECULETYPE) :: thisMolecule
    real(double) :: disttoGrid
    integer :: itrans
    real(double) :: i0
    type(OCTAL), pointer :: thisOctal, startOctal, fromOctal
    integer :: fromSubcell
    integer :: subcell
    real(double) :: ds, phi, r
    type(OCTALVECTOR) :: currentPosition, thisPosition, thisVel
    type(OCTALVECTOR) :: rayVel, startVel, endVel, endPosition
    real(double) :: alphanu, snu, jnu
    integer :: iLower , iUpper
    real(double) :: dv, deltaV
    integer :: i, icount
    real(double) :: distArray(200), tval
    integer :: nTau
    real(double) :: nLower, nUpper
    real(double) :: dTau, etaline, didtau, tau
    real(double) :: intensityIntegral
    real(double) :: dvAcrossCell

    distToGrid = distanceToGridFromOutside(grid, position, direction)

    if (distToGrid > 1.e29) then
       write(*,*) "ray does not intersect grid",position,direction
       i0 = 0.d0
       goto 666
    endif

    iUpper = thisMolecule%iTransUpper(iTrans)
    iLower = thisMolecule%iTransLower(iTrans)

    currentPosition = position + (distToGrid + 1.d-3*grid%halfSmallestSubcell) * direction

    i0 = 0.d0
    intensityIntegral = 0.0
    tau = 0.d0
    rayVel = OCTALVECTOR(0.d0, 0.d0, 0.d0)

    thisOctal => grid%octreeRoot
    icount = 0
    do while(inOctal(grid%octreeRoot, currentPosition))
       icount = icount + 1 

       call findSubcellLocal(currentPosition, thisOctal, subcell)
       call distanceToCellBoundary(grid, currentPosition, direction, tVal, sOctal=thisOctal)

       startVel = amrGridVelocity(grid%octreeRoot, currentPosition, startOctal = thisOctal, actualSubcell = subcell) 
       endPosition = currentPosition + tval * direction
       endVel = amrGridVelocity(grid%octreeRoot, endPosition)

       dvAcrossCell = ((startVel - rayVel).dot.direction) - ((endVel - rayVel).dot.direction)
       dvAcrossCell = abs(dvAcrossCell / thisOctal%microturb(subcell))

       nTau = max(2, nint(dvAcrossCell*10.d0))
       ntau = 5
       distArray(1) = 0.d0
       do i = 2, nTau
          
          distArray(i) = tval * dble(i-1)/dble(nTau-1)

          startOctal => thisOctal
          thisPosition = currentPosition + distArray(i)*direction
          thisVel = amrGridVelocity(grid%octreeRoot, thisPosition, startOctal = startOctal, actualSubcell = subcell) 
          thisVel= thisVel - rayVel


          dv = (thisVel .dot. direction) + deltaV

          alphanu = (hCgs*thisMolecule%transFreq(iTrans)/fourPi) * &
               phiProf(dv, thisOctal%microturb(subcell))/thisMolecule%transFreq(iTrans)

          nLower = thisOctal%molecularLevel(subcell,iLower) * thisMolecule%abundance * thisOctal%nh2(subcell)
          nUpper = thisOctal%molecularLevel(subcell,iUpper) * thisMolecule%abundance * thisOctal%nh2(subcell)

          alphanu = alphanu * (nLower * thisMolecule%einsteinBlu(iTrans) - &
               nUpper * thisMolecule%einsteinBul(iTrans))

          dTau = alphaNu *  (distArray(i)-distArray(i-1)) * 1.d10

          etaLine = hCgs * thisMolecule%einsteinA(iTrans) * thisMolecule%transFreq(iTrans)
          etaLine = etaLine * thisOctal%nh2(subcell) * thisMolecule%abundance * thisOctal%molecularLevel(subcell, iUpper)
          jnu = (etaLine/fourPi) * phiProf(dv, thisOctal%microturb(subcell))/thisMolecule%transFreq(iTrans)


          if (alphanu /= 0.d0) then
             snu = jnu/alphanu
          else
             snu = tiny(snu)
          endif

          i0 = i0 +  exp(-tau) * (1.d0-exp(-dtau))*snu
          tau = tau + dtau
       enddo
       currentPosition = currentPosition + (distArray(ntau)+1.d-3*grid%halfSmallestSubcell) * direction
    enddo
    i0 = i0 + bnu(thisMolecule%transFreq(iTrans), Tcbr) * exp(-tau) ! from far side
666 continue 
!    i0 = i0 + bnu(thisMolecule%transFreq(iTrans), Tcbr) ! from nearside

    ! convert to brightness T

    i0 = i0 * (cSpeed**2 / (2.d0 * thisMolecule%transFreq(iTrans)**2 * kerg))
  end function intensityAlongRay

  
  subroutine calculateMoleculeSpectrum(grid, thisMolecule, iTrans, viewVec, distance)
!$MPI    include 'mpif.h'

    type(GRIDTYPE) :: grid
    type(MOLECULETYPE) :: thisMolecule
    real(double) :: distance
    integer :: itrans
    integer :: nRay
    type(OCTALVECTOR) :: rayPosition(5000)
    real(double) :: da(5000), dOmega(5000)
    type(OCTALVECTOR) :: viewVec
    real(double) :: deltaV
    integer :: iv, iray
    integer :: nLambda
    real(double) :: flux, i0
    real(double), allocatable :: vArray(:), spec(:), tempArray(:)
    integer :: iv1, iv2, i
!$MPI    ! For MPI implementations
!$MPI    integer       ::   my_rank        ! my processor rank
!$MPI    integer       ::   np             ! The number of processes
!$MPI    integer       ::   ierr           ! error flag
!$MPI    logical       ::   rankComplete


!$MPI    ! FOR MPI IMPLEMENTATION=======================================================
!$MPI    !  Get my process rank # 
!$MPI    call MPI_COMM_RANK(MPI_COMM_WORLD, my_rank, ierr)
!$MPI  
!$MPI    ! Find the total # of precessor being used in this run
!$MPI    call MPI_COMM_SIZE(MPI_COMM_WORLD, np, ierr)

    call createRayGrid(nRay, rayPosition, da, dOmega, viewVec, distance, grid)

    nLambda = 50

    iv1 = 1
    iv2 = nLambda
 
!$MPI    iv1 = (my_rank) * (nLambda / (np)) + 1
!$MPI    iv2 = (my_rank+1) * (nLambda / (np))
!$MPI    if (my_rank == (np-1)) iv2 = nLambda


    allocate(spec(1:nLambda), vArray(1:nLambda))
    spec = 0.d0
    do iv = 1, nLambda
       vArray(iv) = 1.e5/cspeed * (2.d0*dble(iv-1)/dble(nLambda)-1.d0)
    enddo
    do iv = iv1, iv2
       deltaV  = vArray(iv)
       do iRay = 1, nRay
          i0 = intensityAlongRay(rayposition(iRay), viewvec, grid, thisMolecule, iTrans, deltaV)
          spec(iv) = spec(iv) + i0  * domega(iRay) / sum(domega(1:nray))
       enddo
    enddo
!$MPI     call MPI_BARRIER(MPI_COMM_WORLD, ierr) 
!$MPI     allocate(tempArray(1:nLambda))
!$MPI       call MPI_ALLREDUCE(spec,tempArray,nLambda,MPI_DOUBLE_PRECISION,&
!$MPI           MPI_SUM,MPI_COMM_WORLD,ierr)
!$MPI    spec(1:nLambda) = tempArray(1:nLambda)
!$MPI     deallocate(tempArray)

!$MPI    if (my_rank == 0) then
    open(42, file="spectrum.dat",status="unknown",form="formatted")
    do i = 1, nLambda
       write(42, *) vArray(i)*cspeed/1.d5, spec(i)
    enddo
    close(42)
!$MPI endif
    deallocate(vArray, spec)
  end subroutine calculateMoleculeSpectrum


  subroutine createRayGrid(nRay, rayPosition, da, dOmega, viewVec, distance, grid)
    type(GRIDTYPE) :: grid
    integer :: nRay
    type(OCTALVECTOR) :: rayPosition(:), thisPos, viewVec, xProj,yProj
    real(double) :: da(:), dOmega(:), distance
    real(double), allocatable :: rGrid(:), dr(:), phigrid(:), dphi(:)
    real(double) :: rMax
    integer :: nr, nphi, ir, iphi
    real(double) :: r1 , r2, phi1, phi2, phiOffset
    real(double) :: xPos, yPos, zPos, cosInc, azimuth
    
    rmax = 1.08d7
    nr = 100
    nphi = 10
    nray = 0

    allocate(rGrid(1:nr), dr(1:nr), phiGrid(1:nPhi), dphi(1:nPhi))

    do ir = 1, nr
       r1 = log10(rmax) * dble(ir-1)/dble(nr)
       r2 = log10(rmax) * dble(ir)/dble(nr)
       r1 = 10.d0**r1
       r2 = 10.d0**r2
       rgrid(ir) = 0.5d0 * (r1 + r2)
       dr(ir) = r2 - r1
    enddo
    do iphi = 1, nPhi
       phi1 = twoPi * dble(iphi-1)/dble(nPhi)
       phi2 = twoPi * dble(iphi)/dble(nPhi)
       phiGrid(iPhi) = 0.5d0 * (phi1 + phi2)
       dphi(iPhi) = phi2 - phi1
    enddo

    do ir = 1, nr
       r1 = rGrid(ir)
       call random_number(phiOffset)
       phiOffset = phiOffset * dphi(1)
       do iPhi = 1, nPhi
          phi1 = phiGrid(iPhi) + phiOffset
          if (phi1 > twoPi) phi1 = phi1 - twoPi

          xPos = r1 * sin(phi1)
          yPos = 0.d0
          zPos = r1 * cos(phi1)

          xProj =  OCTALVECTOR(0.d0, 0.d0, 1.d0)  .cross. viewVec
          call normalize(xProj)
          yProj = viewVec .cross. xProj
         call normalize(yProj)

          nRay = nRay + 1
         rayPosition(nray) =  (xPos * xProj) + (zPos * yProj)
         rayposition(nray) = rayPosition(nRay) + ((-1.d0*distance) * viewVec)

          da(nRay) = pi*( (r1 + dr(ir)/2.d0)**2 - (r1 - dr(ir)/2.d0)**2) * dphi(iPhi)/twoPi
          dOmega(nRay) = da(nRay) / (fourPi * distance**2)
       enddo
    enddo
  end subroutine createRayGrid

  subroutine createDataCube(cube, grid, viewVec, thisMolecule, iTrans)
!$MPI    include 'mpif.h'

    type(MOLECULETYPE) :: thisMolecule
    type(GRIDTYPE) :: grid
    type(DATACUBE) :: cube
    type(OCTALVECTOR) :: viewvec, rayPos, xProj, yProj
    real(double) :: distance = 250.d0*pctocm/1.d10
    real(double) :: deltaV
    integer :: iTrans
    integer :: i, j, k
    real(double) :: r, xval, yval
    integer :: nMonte, imonte, n
    real(double), allocatable :: tempArray(:), tempArray2(:)
    integer :: ix1, ix2
!$MPI    ! For MPI implementations
!$MPI    integer       ::   my_rank        ! my processor rank
!$MPI    integer       ::   np             ! The number of processes
!$MPI    integer       ::   ierr           ! error flag
!$MPI    logical       ::   rankComplete


!$MPI    ! FOR MPI IMPLEMENTATION=======================================================
!$MPI    !  Get my process rank # 
!$MPI    call MPI_COMM_RANK(MPI_COMM_WORLD, my_rank, ierr)
!$MPI  
!$MPI    ! Find the total # of precessor being used in this run
!$MPI    call MPI_COMM_SIZE(MPI_COMM_WORLD, np, ierr)

    nMonte = 1

    call initCube(cube, 100, 100, 50)
    call addSpatialAxes(cube, -grid%octreeRoot%subcellSize*0.1d0, +grid%octreeRoot%subcellSize*0.1d0, &
         -grid%octreeRoot%subcellSize*0.1d0, grid%octreeRoot%subcellSize*0.1d0)
    call addvelocityAxis(cube, -1.d0, 1.d0)

    xProj =  OCTALVECTOR(0.d0, 0.d0, 1.d0)  .cross. viewVec
    call normalize(xProj)
    yProj = viewVec .cross. xProj
    call normalize(yProj)

    ix1 = 1
    ix2 = cube%nx
 
!$MPI    ix1 = (my_rank) * (cube%nx / (np)) + 1
!$MPI    ix2 = (my_rank+1) * (cube%nx / (np))
!$MPI    if (my_rank == (np-1)) ix2 = cube%nx


    do i = ix1, ix2
       write(*,*) i
       do j = 1, cube%ny

          do iMonte = 1, nMonte
             if (nMonte > 1) then
                call random_number(r)
                xVal = cube%xAxis(i) + (r-0.5d0)*(cube%xAxis(2)-cube%xAxis(1))
                call random_number(r)
                yVal = cube%yAxis(j) + (r-0.5d0)*(cube%yAxis(2)-cube%yAxis(1))
             else
                xVal = cube%xAxis(i)
                yVal = cube%yAxis(j)
             endif
             rayPos =  (xval * xProj) + (yval * yProj)
             raypos = rayPos + ((-1.d0*distance) * viewVec)
             do k = 1, cube%nv
                deltaV = cube%vAxis(k)*1.d5/cSpeed
                cube%intensity(i,j,k) = intensityAlongRay(rayPos, viewVec, grid, thisMolecule, iTrans, deltaV)
             enddo
          enddo
          cube%intensity(i,j,1:cube%nv) = cube%intensity(i,j,1:cube%nv) / dble(nMonte)
       enddo
    enddo

!$MPI    n = (cube%nx*cube%ny*cube%nv)
!$MPI    allocate(tempArray(1:n), tempArray2(1:n))
!$MPI    tempArray = reshape(cube%intensity, (/  n /))

!$MPI     call MPI_BARRIER(MPI_COMM_WORLD, ierr) 

!$MPI       call MPI_ALLREDUCE(tempArray,tempArray2,n,MPI_DOUBLE_PRECISION,&
!$MPI           MPI_SUM,MPI_COMM_WORLD,ierr)

!$MPI    cube%intensity = reshape(tempArray2, (/ cube%nx, cube%ny, cube%nv /))
!$MPI    deallocate(tempArray, tempArray2)

  end subroutine createDataCube


  subroutine plotDataCube(cube, device)
    type(DATACUBE) :: cube
    character(len=*) :: device
    integer :: i, j
    integer :: pgbegin
    real, allocatable :: image(:,:)
    integer :: nx, ny
    real :: iMin, iMax
    real :: tr(6)
    real :: dx, dy
    real(double), allocatable :: spec(:)
    real :: vxs, vxe, vys, vye
    real :: x1, x2, y1, y2
    real :: sMax, Smin, range
    integer :: nstep 

    nx = cube%nx
    ny = cube%ny

    dx = (cube%Xaxis(nx) - cube%xAxis(1))/real(nx-1)
    dy = (cube%yAxis(ny) - cube%yAxis(1))/real(ny-1)

    tr(1) = cube%xAxis(1)-dx
    tr(2) = dx
    tr(3) = 0.
    tr(4) = cube%yAxis(1)-dy
    tr(5) = 0.
    tr(6) = dy



    allocate(image(1:nx, 1:ny))

    do i = 1, nx
       do j = 1, ny
          image(i,j) = log10(sum(cube%intensity(i,j,1:cube%nv)))
       enddo
    enddo
    iMin = MINVAL(image(1:nx,1:ny))
    iMax = MAXVAL(image(1:nx,1:ny))

    i =  pgbegin(0,device,1,1)
    call pgvport(0.1, 0.9, 0.1, 0.9)
    call pgwnad(real(cube%xAxis(1))-dx/2., real(cube%xAxis(nx))+dx/2., &
         real(cube%yAxis(1))-dy/2., real(cube%yAxis(ny))+dy/2.)

    call palette(3)

    call pgimag(image, nx, ny, 1, nx, 1, ny, imin, imax, tr)
       
    call pgbox('bcnst',0.0,0,'bcnst',0.0,0)

    call pgqvp(0, x1, x2, y1, y2)

    allocate(spec(1:cube%nv))

    nStep = nx / 5

    smin = 1.e30
    smax = -1.e30
    do i = 1, nx-1, nstep
       do j = 1, ny-1, nstep
          call getSpectrum(cube, i, i+nstep-1, j, j+nstep-1, spec)
          sMax = MAX(sMax,MAXVAL(spec))
          sMin = MIN(sMin,MINVAL(spec))
       enddo
    enddo

    range = sMax - sMin
    sMin = sMin - 0.2*range
    sMax = sMax + 0.2*range

    do i = 1, nx-1, nstep
       do j = 1, ny-1, nstep
          call getSpectrum(cube, i, i+nstep-1, j, j+nstep-1, spec)
          vxs = x1 + (x2-x1)*real(i-1)/real(nx)
          vxe = x1 + (x2-x1)*real(i+nstep-1)/real(nx)
          vys = y1 + (y2-y1)*real(j-1)/real(ny)
          vye = y1 + (y2-y1)*real(j+nstep-1)/real(ny)
          call pgsci(3)
          call pgvport(vxs, vxe, vys, vye)
!          call pgbox('bc',0.0,0,'bc',0.0,0)
          call pgwindow(real(cube%vAxis(1))-0.1, &
               real(cube%vAxis(cube%nv))+0.1, &
               smin, smax)
          call pgline(cube%nv, real(cube%vAxis), &
               real(spec))

          call pgsci(1)
       enddo
    enddo
          

    call pgend




  end subroutine plotDataCube
  
  subroutine getSpectrum(cube, ix1, ix2, iy1, iy2, spec)
    type(DATACUBE) :: cube
    integer :: ix1, ix2, iy1, iy2
    real(double) ::  spec(:)
    integer :: i,j, n
    n = 0
    spec = 0.d0
    do i = ix1, ix2
       do j = iy1, iy2
          n = n + 1
          spec(1:cube%nv) = spec(1:cube%nv) + cube%intensity(i,j,1:cube%nv)
       enddo
    enddo
    spec = spec / dble(n)
  end subroutine getSpectrum
    
!$MPI      subroutine packMoleLevel(octalArray, nTemps, tArray, octalsBelongRank, iLevel)
!$MPI    include 'mpif.h'
!$MPI        type(OCTALWRAPPER) :: octalArray(:)
!$MPI        integer :: octalsBelongRank(:)
!$MPI        integer :: nTemps
!$MPI        real(double) :: tArray(:)
!$MPI        integer :: iOctal, iSubcell, my_rank, ierr
!$MPI        integer :: iLevel
!$MPI        type(OCTAL), pointer :: thisOctal
!$MPI
!$MPI       call MPI_COMM_RANK(MPI_COMM_WORLD, my_rank, ierr)
!$MPI       !
!$MPI       ! Update the edens values of grid computed by all processors.
!$MPI       !
!$MPI       nTemps = 0
!$MPI       do iOctal = 1, SIZE(octalArray)
!$MPI
!$MPI          thisOctal => octalArray(iOctal)%content
!$MPI          
!$MPI          do iSubcell = 1, thisOctal%maxChildren
!$MPI              if (.not.thisOctal%hasChild(iSubcell)) then
!$MPI                 nTemps = nTemps + 1
!$MPI                 if (octalsBelongRank(iOctal) == my_rank) then
!$MPI                   tArray(nTemps) = thisOctal%newMolecularLevel(isubcell, iLevel)
!$MPI                 else 
!$MPI                   tArray(nTemps) = 0.d0
!$MPI                 endif
!$MPI              endif
!$MPI          end do
!$MPI       end do
!$MPI     end subroutine packMoleLevel

!$MPI      subroutine unpackMoleLevel(octalArray, nTemps, tArray, octalsBelongRank, iLevel)
!$MPI    include 'mpif.h'
!$MPI        type(OCTALWRAPPER) :: octalArray(:)
!$MPI        integer :: octalsBelongRank(:)
!$MPI        integer :: nTemps
!$MPI        real(double) :: tArray(:)
!$MPI        integer :: iOctal, iSubcell, my_rank, ierr
!$MPI        integer :: iLevel
!$MPI        type(OCTAL), pointer :: thisOctal
!$MPI
!$MPI       call MPI_COMM_RANK(MPI_COMM_WORLD, my_rank, ierr)
!$MPI       !
!$MPI       ! Update the edens values of grid computed by all processors.
!$MPI       !
!$MPI       nTemps = 0
!$MPI       do iOctal = 1, SIZE(octalArray)
!$MPI
!$MPI          thisOctal => octalArray(iOctal)%content
!$MPI          
!$MPI          do iSubcell = 1, thisOctal%maxChildren
!$MPI              if (.not.thisOctal%hasChild(iSubcell)) then
!$MPI                 nTemps = nTemps + 1
!$MPI                 thisOctal%newMolecularLevel(isubcell, iLevel) = tArray(nTemps) 
!$MPI              endif
!$MPI          end do
!$MPI       end do
!$MPI     end subroutine unpackMoleLevel


end module molecular_mod

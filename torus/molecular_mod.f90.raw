module molecular_mod

! written by tjh
! 21/11/06

  use kind_mod
  use constants_mod
  use utils_mod
  use messages_mod
  use grid_mod
  use math_mod
  use datacube_mod

!$MPI    use parallel_mod

  implicit none

! Define data structures used within code - MOLECULETYPE holds parameters unique to a particular molecule
! DATACUBE is used for data visualisation (intensity for x,y and v)

! Much of this code is our interpretation of the 2000 paper by F. v.d. Tak and M. Hogerheijde - and the 
! 2002 paper by G-J. v. Zadelhoff et al

  type MOLECULETYPE
     character(len=10) :: molecule
     real :: molecularweight
     real(double) :: abundance
     integer :: nLevels
     real(double), pointer :: energy(:)
     real(double), pointer :: g(:)
     real(double), pointer :: j(:)
     integer :: nTrans
     real(double), pointer :: einsteinA(:)
     real(double), pointer :: einsteinBlu(:)
     real(double), pointer :: einsteinBul(:)
     real(double), pointer :: transfreq(:)
     integer, pointer :: itransUpper(:)
     integer, pointer :: itransLower(:)
     real(double), pointer :: Eu(:)
     integer, pointer :: iCollUpper(:,:)
     integer, pointer :: iCollLower(:,:)
     integer :: nCollPart
     character(len=20), pointer :: collBetween(:)
     integer, pointer :: nCollTrans(:)
     integer, pointer :: nCollTemps(:)
     real(double), pointer :: collTemps(:,:)
     real(double), pointer :: collRates(:,:,:)
  end type MOLECULETYPE

contains
  ! Read in molecular parameters from file - note: abundance hard-coded here
  
  subroutine readMolecule(thisMolecule, molFilename)
    type(MOLECULETYPE) :: thisMolecule
    character(len=*) :: molFilename
    character(len=80) :: junk, message
    character(len=200):: dataDirectory, filename
    integer :: i, j, iLow, iUp, iPart
    real(double) :: a, freq, eu, c(20)

    thisMolecule%abundance = 1.d-9 ! fixed at benchmark value here

    call unixGetenv("TORUS_DATA", dataDirectory, i)
    filename = trim(dataDirectory)//"/"//molfilename

    open(30, file=filename, status="old", form="formatted")

    read(30,*) junk
    read(30,'(a)') thisMolecule%molecule

    call writeInfo("Reading data for molecule: "//trim(thisMolecule%molecule),IMPORTANT)
    read(30,*) junk
    read(30,*) thisMolecule%molecularWeight

    read(30,*) junk
    read(30,*) thisMolecule%nLevels

    allocate(thisMolecule%energy(1:thisMolecule%nLevels))
    allocate(thisMolecule%g(1:thisMolecule%nLevels))
    allocate(thisMolecule%j(1:thisMolecule%nLevels))

    read(30,*) junk
    do i = 1, thisMolecule%nLevels
       read(30,*) j, thisMolecule%energy(i), thisMolecule%g(i), thisMolecule%j(i)

       thisMolecule%energy(i) = thisMolecule%energy(i) / 8065.541  ! convert from per cm to ev - e/hc (CGS)
       
    enddo

    read(30,*) junk
    read(30,*) thisMolecule%nTrans

    allocate(thisMolecule%einsteinA(1:thisMolecule%nTrans))
    allocate(thisMolecule%einsteinBul(1:thisMolecule%nTrans))
    allocate(thisMolecule%einsteinBlu(1:thisMolecule%nTrans))
    allocate(thisMolecule%transfreq(1:thisMolecule%nTrans))
    allocate(thisMolecule%itransUpper(1:thisMolecule%nTrans))
    allocate(thisMolecule%itransLower(1:thisMolecule%nTrans))
    allocate(thisMolecule%eu(1:thisMolecule%nTrans))
    read(30,*) junk
    do i = 1, thisMolecule%nTrans
       read(30,*) j, iUp, iLow, a, freq, eu

       thisMolecule%einsteinA(i) = a
       thisMolecule%transfreq(i) = freq*1.d9
       thisMolecule%eu(i) = eu
       thisMolecule%itransUpper(i) = iUp
       thisMolecule%itransLower(i) = iLow

       thisMolecule%einsteinBul(i) = a * (cspeed**2)/(2.d0*hcgs*(freq*1.d9)**3) ! transform Aul -> Bul

       thisMolecule%einsteinBlu(i) = thisMolecule%einsteinBul(i) &
            * thisMolecule%g(iUp)/thisMolecule%g(iLow)

    enddo

    read(30,*) junk
    read(30,*) thisMolecule%nCollPart
    
    allocate(thisMolecule%nCollTrans(1:thisMolecule%nCollPart))
    allocate(thisMolecule%nCollTemps(1:thisMolecule%nCollPart))
    allocate(thisMolecule%collTemps(1:thisMolecule%nCollPart, 1:20))
    allocate(thisMolecule%collBetween(1:thisMolecule%nCollPart))

    
    do iPart = 1, thisMolecule%nCollPart

       read(30,*) junk
       read(30,*) thisMolecule%collBetween(iPart)
       
       read(30,*) junk
       read(30,*) thisMolecule%nCollTrans(iPart)

       read(30,*) junk
       read(30,*) thisMolecule%nCollTemps(iPart)


       read(30,*) junk
       read(30,*) thisMolecule%collTemps(iPart,1:thisMolecule%nCollTemps(ipart))

       allocate(thisMolecule%collRates(1:thisMolecule%nCollPart, &
            1:thisMolecule%nCollTrans(iPart), 1:thisMolecule%nCollTemps(ipart)))
       allocate(thisMolecule%iCollUpper(1:thisMolecule%nCollPart, 1:thisMolecule%nCollTrans(iPart)))
       allocate(thisMolecule%iCollLower(1:thisMolecule%nCollPart, 1:thisMolecule%nCollTrans(iPart)))
       thisMolecule%collRates = 0.d0
       read(30,*) junk
       do j = 1, thisMolecule%nCollTrans(iPart)
          read(30,*) i, thisMolecule%iCollUpper(ipart,j), &
               thisMolecule%iCollLower(ipart,j), c(1:thisMolecule%nCollTemps(iPart))
          thisMolecule%collRates(iPart, j, 1:thisMolecule%nCollTemps(iPart)) = c(1:thisMolecule%nCollTemps(iPart))
       enddo
    enddo
    close(30)
    call writeInfo("Done.", IMPORTANT)
  end subroutine readMolecule

! Same routine for benchmark molecule (slightly different file format)
  subroutine readBenchmarkMolecule(thisMolecule, molFilename)
    type(MOLECULETYPE) :: thisMolecule
    character(len=*) :: molFilename
    character(len=80) :: junk, message
    character(len=200):: dataDirectory, filename
    integer :: i, j, iLow, iUp, iPart
    real(double) :: a, freq, eu, c(20)

    thisMolecule%abundance = 1.d-9 ! fixed at benchmark value here


    call writeInfo("Opening file: "//trim(molfilename),TRIVIAL)
    open(30, file=molfilename, status="old", form="formatted")

    read(30,'(a)') thisMolecule%molecule
    call writeInfo("Reading data for molecule: "//trim(thisMolecule%molecule),IMPORTANT)

    read(30,*) thisMolecule%molecularWeight

    read(30,*) thisMolecule%nLevels, thisMolecule%nTrans

    allocate(thisMolecule%energy(1:thisMolecule%nLevels))
    allocate(thisMolecule%g(1:thisMolecule%nLevels))
    allocate(thisMolecule%j(1:thisMolecule%nLevels))

    allocate(thisMolecule%einsteinA(1:thisMolecule%nTrans))
    allocate(thisMolecule%einsteinBul(1:thisMolecule%nTrans))
    allocate(thisMolecule%einsteinBlu(1:thisMolecule%nTrans))
    allocate(thisMolecule%transfreq(1:thisMolecule%nTrans))
    allocate(thisMolecule%itransUpper(1:thisMolecule%nTrans))
    allocate(thisMolecule%itransLower(1:thisMolecule%nTrans))
    allocate(thisMolecule%eu(1:thisMolecule%nTrans))


    read(30,'(7f11.7)') thisMolecule%energy(1:thisMolecule%nLevels)

    thisMolecule%energy = thisMolecule%energy / 8065.541  ! per cm to ev
       

    read(30,*) thisMolecule%g(1:thisMolecule%nLevels)
    thisMolecule%j(1:thisMolecule%nLevels) = (thisMolecule%g(1:thisMolecule%nLevels) - 1.d0)/2.d0

    read(30,*) thisMolecule%itransUpper(1:thisMolecule%nTrans)
    read(30,*) thisMolecule%itransLower(1:thisMolecule%nTrans)

    read(30,*) thisMolecule%einsteinA(1:thisMolecule%nTrans)
 
    do i = 1, thisMolecule%nTrans

       thisMolecule%transFreq(i) = ((thisMolecule%energy(thisMolecule%iTransUpper(i)) - &
            thisMolecule%energy(thisMolecule%iTransLower(i)))/ergToEV)/hcgs
       thisMolecule%einsteinBul(i) = thisMolecule%einsteinA(i) * (cspeed**2)/(2.d0*hcgs*thisMolecule%transFreq(i)**3)

       thisMolecule%einsteinBlu(i) = thisMolecule%einsteinBul(i) &
            * thisMolecule%g(thisMolecule%iTransUpper(i))/thisMolecule%g(thisMolecule%iTransLower(i))

    enddo

    read(30,*) junk

    thisMolecule%nCollPart = 1 ! only one collision partner considered in benchmark
    iPart = 1 ! follows from ^

    allocate(thisMolecule%nCollTrans(1:thisMolecule%nCollPart))
    allocate(thisMolecule%nCollTemps(1:thisMolecule%nCollPart))


    allocate(thisMolecule%collTemps(1:thisMolecule%nCollPart, 1:4))

    read(30,*) thisMolecule%nCollTrans(1), thisMolecule%nCollTemps(1),thisMolecule%collTemps(1,1:4)

    allocate(thisMolecule%iCollUpper(1:thisMolecule%nCollPart, 1:thisMolecule%nCollTrans(iPart)))
    allocate(thisMolecule%iCollLower(1:thisMolecule%nCollPart, 1:thisMolecule%nCollTrans(iPart)))

    allocate(thisMolecule%collRates(1:thisMolecule%nCollPart, &
         1:thisMolecule%nCollTrans(iPart), 1:thisMolecule%nCollTemps(ipart)))

    read(30,*) thisMolecule%iCollUpper(1, 1:thisMolecule%nCollTrans(1))
    read(30,*) thisMolecule%iCollLower(1, 1:thisMolecule%nCollTrans(1))
    do i = 1, thisMolecule%nCollTemps(1)
       read(30,*) thisMolecule%collRates(iPart,  1:thisMolecule%nCollTrans(ipart), i)
    enddo

    close(30)
    call writeInfo("Done.", IMPORTANT)
  end subroutine readBenchmarkMolecule

! solves rate equation in matrix format - equation 10
  subroutine solveLevels(nPops, jnu,  temperature, thisMolecule, nh2)
    real(double) :: nPops(:)
    real(double) :: temperature
    real(double) :: jnu(:)
    real(double) :: nh2
    type(MOLECULETYPE) :: thisMolecule
    real(double), allocatable :: matrixA(:,:), matrixB(:), collMatrix(:,:), cTot(:)
    real(double) :: arateji, boltzFac
    integer :: nLevels
    integer :: iLower, iUpper, iLevel, i, j
    integer :: itrans, l, k, iPart
    real(double) :: collEx, colldeEx

    nLevels = thisMolecule%nLevels

    allocate(matrixA(1:nLevels+1,1:nLevels+1))
    allocate(matrixB(1:nLevels+1))

    matrixA = 1.d-30 ! Initialise rates to negligible to avoid divisions by zero
    matrixB = 0.d0 ! Solution vector - all components (except last) => equilibrium

    matrixA(nLevels+1,1:nLevels+1) = 1.d0 ! sum of all level populations
    matrixA(1:nLevels+1,nLevels+1) = 1.d-30 ! fix highest population to small non-zero value

    matrixB(nLevels+1) = 1.d0 ! Sum over all levels = 1 - Conservation constraint
    allocate(collMatrix(1:nLevels+1, 1:nLevels+1))

! This do loop calculates the contribution to transition rates of each level from every other level. NB emission is +ve here
    do iTrans = 1, thisMolecule%nTrans

       k = thisMolecule%iTransUpper(iTrans)
       l = thisMolecule%iTransLower(iTrans)
    

       matrixA(k,k) = matrixA(k,k) + thisMolecule%einsteinBul(iTrans) * jnu(iTrans) + thisMolecule%einsteinA(iTrans)
       matrixA(l,l) = matrixA(l,l) + thisMolecule%einsteinBlu(iTrans) * jnu(iTrans)
       matrixA(k,l) = matrixA(k,l) - thisMolecule%einsteinBlu(iTrans) * jnu(iTrans)
       matrixA(l,k) = matrixA(l,k) - thisMolecule%einsteinBul(iTrans) * jnu(iTrans) - thisMolecule%einsteinA(iTrans)

    enddo


    collMatrix = 0.d0
! Calculate contribution from collisions - loop over all collision partners and all molecular levels
    do iPart = 1, thisMolecule%nCollPart
       do iTrans = 1, thisMolecule%nCollTrans(iPart)
          
          k = thisMolecule%iCollUpper(iPart, iTrans)
          l = thisMolecule%iCollLower(iPart, iTrans)

          boltzFac =  exp(-abs(thisMolecule%energy(k)-thisMolecule%energy(l)) / (kev*temperature))
          colldeEx = collRate(thisMolecule, temperature, iPart, iTrans) * nh2! * (nh2 * thisMolecule%abundance)!!!! What's happened here?
          collEx = colldeEx * boltzFac * thisMolecule%g(k)/thisMolecule%g(l)


          collMatrix(l, k) = collMatrix(l, k) + collEx
          collMatrix(k, l) = collMatrix(k, l) + colldeEx

       enddo
    enddo

    allocate(cTot(1:thisMolecule%nLevels))
    cTot = 0.d0
    do k = 1, thisMolecule%nLevels
       do l = 1, thisMolecule%nLevels
          cTot(k) = cTot(k) + collMatrix(k,l) ! sum over all collisional rates out of each level
       enddo
    enddo

    do i = 1, thisMolecule%nLevels
          matrixA(i,i) = matrixA(i,i) + cTot(i)
       do j = 1, thisMolecule%nLevels
          if (i /= j) then
             matrixA(i,j) = matrixA(i,j) - collMatrix(j, i)
          endif
       enddo
    enddo

! finished creating equation 10, now solve it to find new level populations
  call luSlv(matrixA, matrixB, nLevels+1)

  nPops(1:nLevels) = matrixB(1:nLevels)


  
  deallocate(matrixA, matrixB, collMatrix, cTot)

  end subroutine solveLevels

! Calculate collision rates between partners for given temperature
  real(double) function collRate(thisMolecule, temperature, iPart, iTrans)
    type(MOLECULETYPE) :: thisMolecule
    real(double) :: temperature, r
    integer :: i, iTrans, k, iPart

    collRate = 0.d0

       
    call locate(thisMolecule%collTemps(iPart,1:thisMolecule%nCollTemps(iPart)), &
         thisMolecule%nCollTemps(iPart), temperature, k)

    r = (temperature - thisMolecule%collTemps(iPart,k)) / &
         (thisMolecule%collTemps(iPart,k+1) - thisMolecule%collTemps(iPart, k))

    collRate = collRate + thisMolecule%collRates(iPart, iTrans, k) + &
         r * ( thisMolecule%collRates(iPart, iTrans, k+1) -  thisMolecule%collRates(iPart, iTrans, k))

  end function collRate

! This subroutine solves eq.10 for all octals recursively from the bottom up (i.e. from smallest octal -> largest)
  recursive subroutine  solveAllPops(grid, thisOctal, thisMolecule)
    type(GRIDTYPE) :: grid
    type(MOLECULETYPE) :: thisMolecule
    type(octal), pointer   :: thisOctal
    type(octal), pointer  :: child 
    integer :: subcell, i, iUpper, iLower
    real(double) :: etaLine
  
    do subcell = 1, thisOctal%maxChildren
       if (thisOctal%hasChild(subcell)) then
          ! find the child
          do i = 1, thisOctal%nChildren, 1 ! What's this?
             if (thisOctal%indexChild(i) == subcell) then
                child => thisOctal%child(i)
                call solveAllpops(grid, child, thisMolecule)
                exit
             end if
          end do
       else ! once octal has no more children, solve for current parameter set
          call solveLevels(thisOctal%molecularLevel(subcell,1:thisMolecule%nLevels), &
               thisOctal%jnu(subcell,1:thisMolecule%nTrans),  &
               dble(thisOctal%temperature(subcell)), thisMolecule, thisOctal%nh2(subcell))
       endif
    enddo
  end subroutine solveAllPops

! this subroutine calculates the maximum fractional change in the first 6 (consider changing?) energy levels
! NB 
  recursive subroutine  swapPops(thisOctal, maxFracChange)
    type(GRIDTYPE) :: grid
    type(MOLECULETYPE) :: thisMolecule
    type(octal), pointer   :: thisOctal
    type(octal), pointer  :: child 
    integer :: subcell, i, iUpper, iLower
    real(double) :: maxFracChange, temp
  
    do subcell = 1, thisOctal%maxChildren
       if (thisOctal%hasChild(subcell)) then
          ! find the child
          do i = 1, thisOctal%nChildren, 1
             if (thisOctal%indexChild(i) == subcell) then
                child => thisOctal%child(i)
                call swapPops(child, maxFracChange)
                exit
             end if
          end do
       else
!          where(thisOctal%molecularLevel(subcell,:) /= 0.d0)
             temp = MAXVAL(abs((thisOctal%newMolecularLevel(subcell,1:6) - &
                  thisOctal%molecularLevel(subcell,1:6)) / &
                  thisOctal%molecularLevel(subcell,1:6)))
!          end where
          if (temp > maxFracChange) then
             maxFracChange = temp ! update maxFracChange if fractional change is great => not converged yet
          endif
          thisOctal%molecularLevel(subcell,:) = &
               thisOctal%newmolecularLevel(subcell,:) ! update molecular levels
       endif
    enddo
  end subroutine swapPops

!recursive subroutine  distancefromOctalCentretoImage(thisOctal, maxFracChange)
!    type(GRIDTYPE) :: grid
!    type(MOLECULETYPE) :: thisMolecule
!    type(octal), pointer   :: thisOctal
!    type(octal), pointer  :: child 
!    integer :: subcell, i, iUpper, iLower
!    real(double) :: maxFracChange, temp
!  
!    do subcell = 1, thisOctal%maxChildren
!       if (thisOctal%hasChild(subcell)) then
!          ! find the child
!          do i = 1, thisOctal%nChildren, 1
!             if (thisOctal%indexChild(i) == subcell) then
!                child => thisOctal%child(i)
!                call swapPops(child, maxFracChange)
!                exit
!             end if
!          end do
!       else

!!! stuff to do in here

!write(*,*) thisOctal%subcellcentre
!
!       endif
!    enddo
!  end subroutine distanceto...

! This subroutine allocates memory to the octal for storing molecular level data *if* none currently exists then
! stores the non-zero local emission coefficient   
  recursive subroutine  allocateMolecularLevels(grid, thisOctal, thisMolecule)
    type(GRIDTYPE) :: grid
    type(MOLECULETYPE) :: thisMolecule
    type(octal), pointer   :: thisOctal
    type(octal), pointer  :: child 
    integer :: subcell, i, iUpper, iLower
    real(double) :: etaLine
  
  do subcell = 1, thisOctal%maxChildren
       if (thisOctal%hasChild(subcell)) then
          ! find the child
          do i = 1, thisOctal%nChildren, 1
             if (thisOctal%indexChild(i) == subcell) then
                child => thisOctal%child(i)
                call allocateMolecularLevels(grid, child, thisMolecule)
                exit
             end if
          end do
       else

          if (.not.associated(thisOctal%molecularLevel)) then
             allocate(thisOctal%molecularLevel(1:thisOctal%maxChildren, 1:thisMolecule%nLevels))
          endif
          thisOctal%molecularLevel = 1.d-30

          if (.not.associated(thisOctal%newmolecularLevel)) then
             allocate(thisOctal%newmolecularLevel(1:thisOctal%maxChildren, 1:thisMolecule%nLevels))
          endif
          thisOctal%newmolecularLevel = 1.d-30

          if (.not.associated(thisOctal%jnu)) then
             allocate(thisOctal%jnu(1:thisOctal%maxChildren, 1:thisMolecule%nTrans))
          endif
          do i = 1, thisMolecule%nTrans
             thisOctal%jnu(subcell,i) = bnu(thisMolecule%transFreq(i), dble(thisOctal%temperature(subcell)))
          enddo
          thisOctal%jnu = 1.d-30
       endif
    enddo
  end subroutine allocateMolecularLevels

! Equation 9 - calculating the doppler broadening due to a turbulent velocity field (b - constant locally)
! NB b here = b*nu0/c in the paper
  function phiProf(dv, b) result (phi)
    real(double) :: dv, b
    real(double) :: fac, phi
    phi = 1.d0 / (b * sqrt(Pi))
    fac = dv**2 / b**2
    phi = phi * exp(-fac)
  end function phiProf

! Make a 'ray' with a random position - then use it to update intensity and opacity
  subroutine getRay(grid, fromOctal, fromSubcell, position, direction, ds, phi, i0, thisMolecule)
    type(MOLECULETYPE) :: thisMolecule
    type(GRIDTYPE) :: grid
    type(OCTAL), pointer :: thisOctal, startOctal, fromOctal
    integer :: fromSubcell
    integer :: subcell
    real(double) :: ds, phi, i0(:), r, phi1, phi2
    integer :: iTrans
    type(OCTALVECTOR) :: position, direction, currentPosition, thisPosition, thisVel
    type(OCTALVECTOR) :: rayVel, startVel, endVel, endPosition
    real(double) :: alphanu, snu, jnu
    integer :: iLower , iUpper
    real(double) :: dv, deltaV
    integer :: i
    real(double) :: distArray(200), tval
    integer :: nTau
    real(double) :: nLower, nUpper
    real(double) :: dTau, etaline, didtau
    real(double), allocatable :: tau(:)
    real(double) :: intensityIntegral
    real(double) :: dvAcrossCell, projVel
    integer :: iCount

    allocate(tau(1:thisMolecule%nTrans))
    
    position = randomPositionInCell(fromOctal, fromsubcell)

    icount = 1
    thisOctal => grid%octreeRoot
    call findSubcellLocal(position, thisOctal, subcell)


    direction = randomUnitVector()
    call random_number(r)

    rayVel = amrGridVelocity(grid%octreeRoot, position, startOctal = thisOctal, actualSubcell = subcell) ! systematic velocity at rays current position

    call random_number(r)

    deltaV = 4.3 * thisOctal%microturb(subcell) * (r-0.5d0) ! random frequency near line spectrum peak. 
    ! 4.3 corresponds to the width where the peak of the line profile has dropped to 1% of it's peak
    ! microturulence is assumed gaussian - b is FULL WIDTH

    deltaV = deltaV +  (rayVel .dot. direction) ! transform to take account of grid velocity

    projVel = deltaV - (rayVel .dot. direction) ! transorm back to velocity relative to local flow

    phi1 = phiProf(projVel, thisOctal%microturb(subcell)) ! doppler broadening dependent on local (projected) velocity 

    call distanceToCellBoundary(grid, position, direction, ds, sOctal=thisOctal)

    currentPosition = position + ds * direction

    phi2 = phi1 ! assume constant turbulence
    if (inOctal(grid%octreeRoot, currentPosition)) then ! check that we're still on the grid
       thisVel = amrGridVelocity(grid%octreeRoot, currentPosition, startOctal = thisOctal) 
       projVel = deltaV - (thisVel.dot.direction)
       
       phi2 = phiProf(projVel, thisOctal%microturb(subcell))
    else
       phi2 = phi1 ! if fell off grid then assume phi is unchanged
    endif

    phi  = (phi1 + phi2)/2.d0
!    if (modulus(thisVel) /= 0.d0) &
!    write(*,*) phi1,phi2,phi
    ds = ds * 1.d10 ! convert from cm to torus units

    i0 = 0.d0
    intensityIntegral = 0.0
    tau = 0.d0

    do while(inOctal(grid%octreeRoot, currentPosition))

       call findSubcellLocal(currentPosition, thisOctal, subcell)
       call distanceToCellBoundary(grid, currentPosition, direction, tVal, sOctal=thisOctal)

       startVel = amrGridVelocity(grid%octreeRoot, currentPosition, startOctal = thisOctal, actualSubcell = subcell) 
       endPosition = currentPosition + tval * direction
       endVel = amrGridVelocity(grid%octreeRoot, endPosition)

       dvAcrossCell = ((startVel - rayVel).dot.direction) - ((endVel - rayVel).dot.direction) ! start - end
       dvAcrossCell = abs(dvAcrossCell / thisOctal%microturb(subcell))

       nTau = min(max(2, nint(dvAcrossCell * 20.d0)),200) ! selects dVacrossCell as being between 0.1 and 10 (else nTau bounded by 2 and 200)
!       write(*,*) ntau

       distArray(1) = 0.d0
       do i = 2, nTau
          
          distArray(i) = tval * dble(i-1)/dble(nTau-1)

          startOctal => thisOctal
          thisPosition = currentPosition + distArray(i)*direction
          thisVel = amrGridVelocity(grid%octreeRoot, thisPosition, startOctal = startOctal, actualSubcell = subcell) 


          dv = deltaV - (thisVel .dot. direction)
!          write(*,*) icount,dv*cspeed/1.d5,modulus(thisPosition)
          icount = icount + 1

          do iTrans = 1, thisMolecule%nTrans
             alphanu = (hCgs*thisMolecule%transFreq(iTrans)/fourPi) * &
                  phiProf(dv, thisOctal%microturb(subcell))/thisMolecule%transFreq(iTrans) ! Multiply by transfreq then divide by transFreq??

             iUpper = thisMolecule%iTransUpper(iTrans)
             iLower = thisMolecule%iTransLower(iTrans)
             
             nLower = thisOctal%molecularLevel(subcell,iLower) * thisMolecule%abundance * thisOctal%nh2(subcell)
             nUpper = thisOctal%molecularLevel(subcell,iUpper) * thisMolecule%abundance * thisOctal%nh2(subcell)

             alphanu = alphanu * (nLower * thisMolecule%einsteinBlu(iTrans) - &
                  nUpper * thisMolecule%einsteinBul(iTrans)) ! Equation 8

             dTau = alphaNu *  (distArray(i)-distArray(i-1)) * 1.d10 ! optical depth, dTau = alphanu*ds - between eqs (3) and (4)

             etaLine = hCgs * thisMolecule%einsteinA(iTrans) * thisMolecule%transFreq(iTrans)
             etaLine = etaLine * thisOctal%nh2(subcell) * thisMolecule%abundance * thisOctal%molecularLevel(subcell, iUpper) 
             jnu = (etaLine/fourPi) * phiProf(dv, thisOctal%microturb(subcell))/thisMolecule%transFreq(iTrans) ! jnu, emission coefficient - equation 7


             if (alphanu /= 0.d0) then
                snu = jnu/alphanu ! Source function 
             else
                snu = tiny(snu)
             endif

             i0(iTrans) = i0(iTrans) +  exp(-tau(iTrans)) * (1.d0-exp(-dtau))*snu ! summed radiation intensity from line integral + 2nd term is local radiation field 
             tau(iTrans) = tau(iTrans) + dtau ! contribution to optical depth from this line integral
          enddo
       enddo
       currentPosition = currentPosition + (distArray(ntau)+1.d-3*grid%halfSmallestSubcell) * direction ! FUDGE - make sure that new position is in new cell
    enddo
    do iTrans = 1, thisMolecule%nTrans
       i0(iTrans) = i0(iTrans) + bnu(thisMolecule%transFreq(iTrans), Tcbr) * exp(-tau(iTrans)) ! check this?
    enddo
    deallocate(tau)
  end subroutine getRay

! sample level populations at logarithmically spaced annuli
  subroutine dumpResults(grid, thisMolecule)
    type(GRIDTYPE) :: grid
    type(MOLECULETYPE) :: thisMolecule
    integer :: nr
    real(double) :: r, ang
    integer :: i
    real(double) :: pops(10)
    type(OCTAL), pointer :: thisOctal
    integer :: subcell
    integer :: j
    real(double) :: x, z
    type(OCTALVECTOR) :: posvec
    real(double) :: router, rinner, jnu
    
    rinner = 1.e6
    router  = 4.6e7
    
    nr = 20 ! number of rays used to sample distribution
    open(31,file="results.dat",status="unknown",form="formatted")
    do i = 1, nr
       r = log10(rinner) + dble(i-1)/dble(nr-1)*(log10(router) - log10(rinner))
       r = 10.d0**r ! log(radius) -> radius
       pops = 0.d0
       jnu = 0.d0
       do j = 1 , 20
          call random_number(ang)
          ang = ang * pi
          z = r*cos(ang)
          x = r*sin(ang)
          posVec = OCTALVECTOR(x, 0.d0, z) ! get put in octal on grid
          thisOctal => grid%octreeroot
          call findSubcellLocal(posVec, thisOctal,subcell) 
          pops = pops + thisOctal%molecularLevel(subcell,1:10) ! interested in first 10 levels
          jnu = jnu + thisOctal%jnu(subcell,1) 
       enddo
       pops = pops / 20.d0 ! normalised level population at the 20 random positions 
       jnu = jnu / 20.d0 ! normalised emission coefficient
       write(31,*) real(r*1.d10), real(pops(1:6)),jnu ! real-time check that everything is fine
    enddo
    close(31)
  end subroutine dumpResults

! Does a lot of work - do more rays whilst problem not converged -            
  subroutine molecularLoop(grid, thisMolecule)

    use input_variables, only : blockhandout, debug ! ??
!$MPI    include 'mpif.h'

    type(GRIDTYPE) :: grid
    type(MOLECULETYPE) :: thisMolecule
    type(OCTALVECTOR) :: position, direction
    integer :: nOctal, iOctal, subcell
    real(double), allocatable :: ds(:), phi(:), i0(:,:), tau(:)
    integer :: nRay
    type(octalWrapper), allocatable :: octalArray(:) ! array containing pointers to octals
    type(OCTAL), pointer :: thisOctal
    integer, parameter :: maxIter = 100, maxRay = 100000
    logical :: popsConverged, gridConverged 
    integer :: iRay, iTrans, iter,i 
    integer :: iStage
    real(double), allocatable :: oldpops(:)
    real(double) :: fac
!$MPI    ! For MPI implementations
!$MPI    integer       ::   my_rank        ! my processor rank
!$MPI    integer       ::   np             ! The number of processes
!$MPI    integer       ::   ierr           ! error flag
!$MPI    logical       ::   rankComplete

     logical :: dcAllocated
     integer, dimension(:), allocatable :: octalsBelongRank
     real(double), allocatable :: tArrayd(:),tempArrayd(:)
     integer :: nVoxels
     integer :: ioctal_beg, ioctal_end, tag = 0
     real(double) :: maxFracChange
     logical :: fixedRays
     integer :: isize
     integer, allocatable :: iseed(:)
     real(double) :: tolerance

! blockhandout must be off for fixed ray case, otherwise setting the
! seed is not enough to ensure the same directions are done for
! each cell every iteration

     blockHandout = .false. 

!$MPI    ! FOR MPI IMPLEMENTATION=======================================================
!$MPI    !  Get my process rank # 
!$MPI    call MPI_COMM_RANK(MPI_COMM_WORLD, my_rank, ierr)
!$MPI  
!$MPI    ! Find the total # of precessor being used in this run
!$MPI    call MPI_COMM_SIZE(MPI_COMM_WORLD, np, ierr)

    call allocateMolecularLevels(grid, grid%octreeRoot, thisMolecule)


    call solveAllPops(grid, grid%octreeRoot, thisMolecule)
!$MPI if (my_rank ==0 ) then
    write(*,*) "Dumping results",log10(bnu(thisMolecule%transFreq(1),2.782d0)) ! can use cbr constant?
    call dumpresults(grid, thisMolecule)
!$MPI endif
    nRay = 100 ! number of rays used to establish estimate of jnu and pops

    allocate(oldPops(1:thisMolecule%nLevels))

    allocate(octalArray(grid%nOctals))
    nOctal = 0
    call getOctalArray(grid%octreeRoot,octalArray, nOctal)

    call random_seed

    !$MPI       if (my_rank == 0) &
    call writeAmrGrid("molecular_tmp.grid",.false.,grid)

    
    call random_seed(size=iSize)
    allocate(iSeed(1:iSize))
    call random_seed(get=iSeed)
!$MPI     call MPI_BARRIER(MPI_COMM_WORLD, ierr) 
!$MPI     call MPI_BCAST(iSeed, iSize, MPI_INTEGER, 0, MPI_COMM_WORLD, ierr)

    nRay = 100 ! ?!

    do iStage = 1, 2 ! fixed rays to reduce variance between cells or 2) random rays to ensure sufficient spatial sampling


       if (iStage == 1) then
          fixedRays = .true.
          tolerance = 1.d-2
       else
          fixedRays = .false.
          tolerance = 1.d-4
       endif

       gridConverged = .false.

       do while (.not.gridConverged)

          allocate(ds(1:nRay))
          allocate(phi(1:nRay))
          allocate(i0(1:thisMolecule%nTrans, 1:nRay))
          allocate(tau(1:nRay))
          
          
          if (fixedRays) then
             call random_seed(put=iseed)   ! same seed for fixed rays
          else
             call random_seed
          endif

          ! default loop indicies
          ioctal_beg = 1
          ioctal_end = SIZE(octalArray)       
          


!$MPI    
!$MPI    ! we will use an array to store the rank of the process
!$MPI    !   which will calculate each octal's variables
!$MPI    allocate(octalsBelongRank(size(octalArray)))
!$MPI    
!$MPI    if (my_rank == 0) then
!$MPI       print *, ' '
!$MPI       print *, 'molecular  computed by ', np-1, ' processors.'
!$MPI       print *, ' '
!$MPI       call mpiBlockHandout(np,octalsBelongRank,blockDivFactor=1,tag=tag,&
!$MPI                            maxBlockSize=10,setDebug=.false.)
!$MPI    
!$MPI    endif
!$MPI    ! ============================================================================





!$MPI if (my_rank /= 0) then
!$MPI  blockLoop: do     
!$MPI call mpiGetBlock(my_rank,iOctal_beg,iOctal_end,rankComplete,tag,setDebug=.false.)
!$MPI   if (rankComplete) exit blockLoop 


! iterate over all octals, all rays, solving the system self-consistently
          do iOctal = ioctal_beg, ioctal_end
             if (debug) write(*,*) iOctal,ioctal_beg,ioctal_end
             thisOctal => octalArray(iOctal)%content
             do subcell = 1, thisOctal%maxChildren
                
                if (.not.thisOctal%hasChild(subcell)) then
                   
                   do iRay = 1, nRay
                      call getRay(grid, thisOCtal, subcell, position, direction, &
                           ds(iRay), phi(iRay), i0(1:thisMolecule%nTrans,iRay), &
                           thisMolecule) ! does the hard work - populates i0 etc.
                   enddo
                   iter = 0
                   popsConverged = .false.
                   thisOctal%newMolecularLevel(subcell,:) = thisOctal%molecularLevel(subcell,:)
                   do while (.not.popsConverged)
                      iter = iter + 1
                      oldpops = thisOctal%newmolecularLevel(subcell,1:thisMolecule%nLevels) ! retain old pops before calculating new one
                      do iTrans = 1, thisMolecule%nTrans
                         call calculateJbar(thisOctal, subcell, thisMolecule, nRay, ds(1:nRay), &
                              phi(1:nRay), i0(iTrans,1:nRay), iTrans, thisOctal%jnu(subcell,iTrans), &
                              thisOctal%newMolecularLevel(subcell,1:thisMolecule%nLevels)) ! calculate updated Jbar
                      enddo
                      call solveLevels(thisOctal%newMolecularLevel(subcell,1:thisMolecule%nLevels), &
                           thisOctal%jnu(subcell,1:thisMolecule%nTrans),  &
                           dble(thisOctal%temperature(subcell)), thisMolecule, thisOctal%nh2(subcell))
!                      fac = maxval(abs((thisOctal%newMolecularLevel(subcell,1:thisMolecule%nLevels) - oldpops)/oldpops)) ! convergence criterion
                      fac = maxval(abs((thisOctal%newMolecularLevel(subcell,1:6) - oldpops(1:6))/oldpops(1:6))) ! convergence criterion
                      if (fac < 1.d-4) popsConverged = .true.
                      if (iter == maxIter) then
                         popsConverged = .true.
                         call writeWarning("Maximum number of iterations reached in pop solver")
                      endif
                   enddo
                endif
             enddo
          end do

!$MPI if (.not.blockHandout) exit blockloop
!$MPI end do blockLoop        
!$MPI end if ! (my_rank /= 0)




!$MPI     call MPI_BARRIER(MPI_COMM_WORLD, ierr) 
!$MPI       if(my_rank == 0) write(*,*) "Updating MPI grids"

!$MPI
!$MPI     ! have to send out the 'octalsBelongRank' array
!$MPI     call MPI_BCAST(octalsBelongRank,SIZE(octalsBelongRank),  &
!$MPI                    MPI_INTEGER, 0, MPI_COMM_WORLD, ierr)
!$MPI     call MPI_BARRIER(MPI_COMM_WORLD, ierr) 
!$MPI
!$MPI     call countVoxels(grid%octreeRoot,nOctal,nVoxels)
!$MPI     allocate(tArrayd(1:nVoxels))
!$MPI     allocate(tempArrayd(1:nVoxels))
!$MPI     tArrayd = 0.d0
!$MPI     tempArrayd = 0.d0
!$MPI     do i = 1, thisMolecule%nLevels
!$MPI       tArrayd = 0.d0
!$MPI       call packMoleLevel(octalArray, nVoxels, tArrayd, octalsBelongRank, i)
!$MPI       call MPI_ALLREDUCE(tArrayd,tempArrayd,nVoxels,MPI_DOUBLE_PRECISION,&
!$MPI           MPI_SUM,MPI_COMM_WORLD,ierr)
!$MPI       tArrayd = tempArrayd
!$MPI       call unpackMoleLevel(octalArray, nVoxels, tArrayd, octalsBelongRank, i)
!$MPI     enddo
!$MPI     deallocate(tArrayd, tempArrayd)

!$MPI       if(my_rank == 0) write(*,*) "Done updating"



          maxFracChange = -1.d30 ! negative to ensure comparison?
          call swapPops(grid%octreeRoot, maxFracChange)
          write(*,*) "Maximum fractional change this iteration",maxFracChange
          write(*,*) "Fractional change",maxFracChange,"tolerance",tolerance , &
               "fixed rays",fixedrays,"nray",nray

          if (maxFracChange < tolerance) then
             gridConverged = .true.
          endif

          
          !$MPI       if (my_rank == 0) &
          call writeAmrGrid("molecular_tmp.grid",.false.,grid)
          !$MPI if (my_rank ==0 ) then
          write(*,*) "Dumping results"
          call dumpresults(grid, thisMolecule) ! find radial pops on final grid
          !$MPI endif

!$MPI       deallocate(octalsBelongRank)

          deallocate(ds, phi, i0, tau)
          
          if (.not.gridConverged) then
             if (.not.fixedRays) nRay = nRay * 2 !double number of rays if convergence criterion not met and not using fixed rays - revise!!! Can get away with estimation?
          endif
          if (nRay > maxRay) then
             nRay = maxRay  ! stop when it's not feasible to do more rays - should never get here
             call writeWarning("Maximum number of rays exceeded - capping")
          endif
       enddo
    enddo
    write(*,*) "mole loop done."
    stop
  end subroutine molecularLoop


  subroutine calculateJbar(thisOctal, subcell, thisMolecule, nRay, ds, phi, i0, iTrans, jbar, nPops)
    type(OCTAL), pointer :: thisOctal
    integer :: subcell
    type(MOLECULETYPE) :: thisMolecule
    integer :: nRay
    real(double) :: ds(:), phi(:), i0(:), nPops(:)
    integer :: iTrans
    real(double) :: jbar
    integer :: iRay
    real(double) :: nLower, nUpper
    real(double) :: jBarInternal, jBarExternal
    real(double) :: alphanu, jnu, etaline
    integer :: iUpper, iLower
    real(double) :: tau, snu, sumPhi

    jBarExternal = 0.d0
    jBarInternal = 0.d0

    iUpper = thisMolecule%iTransUpper(iTrans)
    iLower = thisMolecule%iTransLower(iTrans)
! commented elsewhere in the code... is it possible to stick this in a module and reuse?
    sumPhi = 0.d0
    do iRay = 1, nRay
       alphanu = (hCgs*thisMolecule%transFreq(iTrans)/fourPi)
       nLower = nPops(iLower) * thisMolecule%abundance * thisOctal%nh2(subcell)
       nUpper = nPops(iUpper) * thisMolecule%abundance * thisOctal%nh2(subcell)
       
       alphanu = alphanu * (nLower * thisMolecule%einsteinBlu(iTrans) - &
            nUpper * thisMolecule%einsteinBul(iTrans)) * phi(iray)/thisMolecule%transFreq(iTrans)
       tau = alphaNu * ds(iray)

       etaLine = hCgs * thisMolecule%einsteinA(iTrans) * thisMolecule%transFreq(iTrans)
       etaLine = etaLine * thisOctal%nh2(subcell) * thisMolecule%abundance * nPops(iUpper)
       jnu = (etaLine/fourPi) * phi(iRay)/thisMolecule%transFreq(iTrans)
       if (alphanu /= 0.d0) then
          snu = jnu/alphanu
       else
          snu = tiny(snu)
       endif

       jBarExternal = jBarExternal + i0(iray) * exp(-tau) * phi(iRay)
       jBarInternal = jBarInternal + snu * (1.d0 - exp(-tau)) * phi(iRay)

       sumPhi = sumPhi + phi(iRay)
    enddo
    
!    jbar = (jBarExternal + jBarInternal)/dble(nRay)
     jbar = (jBarExternal + jBarInternal)/sumPhi

  end subroutine calculateJbar


  function intensityAlongRay(position, direction, grid, thisMolecule, iTrans, deltaV) result (i0)
    use input_variables, only : debug
    type(OCTALVECTOR) :: position, direction, startPosition
    type(GRIDTYPE) :: grid
    type(MOLECULETYPE) :: thisMolecule
    real(double) :: disttoGrid
    integer :: itrans
    real(double) :: i0
    type(OCTAL), pointer :: thisOctal, startOctal, fromOctal
    integer :: fromSubcell
    integer :: subcell
    real(double) :: ds, phi, r
    type(OCTALVECTOR) :: currentPosition, thisPosition, thisVel
    type(OCTALVECTOR) :: rayVel, startVel, endVel, endPosition
    real(double) :: alphanu, snu, jnu
    integer :: iLower , iUpper
    real(double) :: dv, deltaV
    integer :: i, icount
    real(double) :: distArray(200), tval
    integer :: nTau
    real(double) :: nLower, nUpper
    real(double) :: dTau, etaline, didtau, tau
    real(double) :: intensityIntegral
    real(double) :: dvAcrossCell


    distToGrid = distanceToGridFromOutside(grid, position, direction)

    if (distToGrid > 1.e29) then
       write(*,*) "ray does not intersect grid",position,direction
       i0 = 0.d0
       goto 666
    endif

    iUpper = thisMolecule%iTransUpper(iTrans)
    iLower = thisMolecule%iTransLower(iTrans)
!    if (debug) write(*,*) "mod(direction)",modulus(direction)
!    if (debug) write(*,*) "position",position
!    if (debug) write(*,*) "direction",direction
!    if (debug) write(*,*) "disttogrid",disttogrid
!
    currentPosition = position + (distToGrid + grid%halfSmallestSubcell) * direction
!    if (debug) write(*,*) "currentposbef",currentPosition,sqrt(currentPosition%x**2 + currentPosition%y**2), currentposition%z
!    if (debug) write(*,*) "halfsmallest",grid%halfSmallestSubcell
    currentPosition = position + (distToGrid + 20.d0 * grid%halfSmallestSubcell) * direction
!    if (debug) write(*,*) "currentposaft",currentPosition,sqrt(currentPosition%x**2 + currentPosition%y**2), &
!         currentPosition%z
    i0 = 0.d0
    intensityIntegral = 0.0
    tau = 0.d0
    rayVel = OCTALVECTOR(0.d0, 0.d0, 0.d0)

    thisOctal => grid%octreeRoot
    icount = 0
    do while(inOctal(grid%octreeRoot, currentPosition))
       icount = icount + 1 

       call findSubcellLocal(currentPosition, thisOctal, subcell)
       call distanceToCellBoundary(grid, currentPosition, direction, tVal, sOctal=thisOctal)

       startVel = amrGridVelocity(grid%octreeRoot, currentPosition, startOctal = thisOctal, actualSubcell = subcell) 
       endPosition = currentPosition + tval * direction
       endVel = amrGridVelocity(grid%octreeRoot, endPosition)

       dvAcrossCell = ((startVel - rayVel).dot.direction) - ((endVel - rayVel).dot.direction)
       dvAcrossCell = abs(dvAcrossCell / thisOctal%microturb(subcell))

       nTau = max(2, nint(dvAcrossCell*10.d0))
       ntau = 5
       distArray(1) = 0.d0
       do i = 2, nTau
          
          distArray(i) = tval * dble(i-1)/dble(nTau-1)

          startOctal => thisOctal
          thisPosition = currentPosition + distArray(i)*direction
          thisVel = amrGridVelocity(grid%octreeRoot, thisPosition, startOctal = startOctal, actualSubcell = subcell) 
          thisVel= thisVel - rayVel

          dv = (thisVel .dot. direction) + deltaV

          alphanu = (hCgs*thisMolecule%transFreq(iTrans)/fourPi) * &
               phiProf(dv, thisOctal%microturb(subcell))/thisMolecule%transFreq(iTrans)
          
          nLower = thisOctal%molecularLevel(subcell,iLower) * thisMolecule%abundance * thisOctal%nh2(subcell)
          nUpper = thisOctal%molecularLevel(subcell,iUpper) * thisMolecule%abundance * thisOctal%nh2(subcell)

          alphanu = alphanu * (nLower * thisMolecule%einsteinBlu(iTrans) - &
               nUpper * thisMolecule%einsteinBul(iTrans))

          dTau = alphaNu *  (distArray(i)-distArray(i-1)) * 1.d10

          etaLine = hCgs * thisMolecule%einsteinA(iTrans) * thisMolecule%transFreq(iTrans)
          etaLine = etaLine * thisOctal%nh2(subcell) * thisMolecule%abundance * thisOctal%molecularLevel(subcell, iUpper)
          jnu = (etaLine/fourPi) * phiProf(dv, thisOctal%microturb(subcell))/thisMolecule%transFreq(iTrans)
          if (alphanu /= 0.d0) then
             snu = jnu/alphanu
          else
             snu = tiny(snu)
          endif

          i0 = i0 +  exp(-tau) * (1.d0-exp(-dtau))*snu
!           if (debug) write(*,*) "i0",i0,"tau",tau,"dtau",dtau,"snu",snu
          tau = tau + dtau
       enddo
       currentPosition = currentPosition + (distArray(ntau)+1.d-3*grid%halfSmallestSubcell) * direction
    enddo
    i0 = i0 + bnu(thisMolecule%transFreq(iTrans), Tcbr) * exp(-tau) ! from far side
!    if (debug) write(*,*) "bound condition",i0,bnu(thisMolecule%transFreq(iTrans), Tcbr) * exp(-tau)
666 continue 

    ! convert to brightness T
    
    i0 = i0 * (cSpeed**2 / (2.d0 * thisMolecule%transFreq(iTrans)**2 * kerg))

  end function intensityAlongRay

  function makeImageGrid(unitvec,npixels,imageside,grid,thisMolecule,iTrans,deltaV,tester,cube) result (imagegrid)

    type(GRIDTYPE) :: grid
    type(MOLECULETYPE) :: thisMolecule
    integer :: itrans
    type(OCTALVECTOR) :: viewVec, posvec
    real(double) :: flux, i0
    type(OCTALVECTOR) :: imagebasis1, imagebasis2, pixelcorner,newposvec
    type(OCTALVECTOR), INTENT(IN) :: unitvec
    integer :: npixels
    integer :: nsubpixels
    real :: imagegrid(npixels,npixels)
    integer :: i,j
    real(double) :: imageside,pixelside, r1,dtgfo,distance
    real(double) :: max
    real(double) :: deltaV
    integer :: tester
    type(datacube) :: cube

    imagebasis1 = unitVec .cross. OCTALVECTOR(0.d0,0.d0,1.d0) ! gridvector
    imagebasis2 = imagebasis1 .cross. unitVec ! gridvector perp
    call normalize(imagebasis1)
    call normalize(imagebasis2)
    
!   call normalize(posvec)
    
    pixelside = imageside / npixels

    imagebasis1 = imagebasis1 * pixelside ! rescale basis vectors so that stepsize is simplified 
    imagebasis2 = imagebasis2 * pixelside
    viewvec = (-1.d0) * unitvec ! look *towards* origin from posvec   
    posvec = unitvec * 5.d0 * grid%octreeroot%subcellsize ! now the grid will be far away!

!    dtgfo = distancetogridfromoutside(grid,posvec,viewvec)
    
    !write(*,*) posvec, "posvec", viewvec, "viewvec"
    !write(*,*) imagebasis1, "imagebasis1"
    !write(*,*) imagebasis2, "imagebasis2"
    
    pixelcorner = posvec - (dble(npixels)/2.d0)*(imagebasis2 - imagebasis1) + imagebasis1 ! fudge at the end to 'fit in' with the do loop
    
    if (tester .gt. 0) then 
       nsubpixels = tester
    else
       nsubpixels = 4
    endif
   
    do j = 1,npixels
       if (j == 1) then 
          pixelcorner = pixelcorner - imagebasis1
       else
          pixelcorner = pixelcorner - (imagebasis1 + dble(npixels)*imagebasis2)
       endif
       do i = 1,npixels

          imagegrid(i,j) = PixelIntensity(nsubpixels,pixelside,viewvec,pixelcorner,imagebasis1,imagebasis2,grid,thisMolecule,&
               iTrans,deltaV,tester,i,j,cube) / pixelside**2 ! should normalise to ~1...

          pixelcorner = pixelcorner + 1.d0 * imagebasis2
       enddo
    enddo

end function makeImageGrid

function PixelIntensity(nsubpixels,pixelside,viewvec,pixelcorner,&
                          imagebasis1,imagebasis2,grid,thisMolecule,iTrans,deltaV,tester,index1,index2,cube)&
                          result(totalpixelintensity)

    type(GRIDTYPE) :: grid
    type(MOLECULETYPE) :: thisMolecule
    integer :: itrans
    type(OCTALVECTOR) :: viewVec
    real(double) :: flux, i0, totalpixelintensity,distance
    type(OCTALVECTOR) :: imagebasis1, imagebasis2, pixelbasis1, pixelbasis2, pixelcorner, newposvec
    integer :: nsubpixels,subpixels
    real(double),allocatable :: subpixelgrid(:,:),testgrid(:,:)
    integer :: i,j
    real(double) :: pixelside,subpixelsize,max
    integer :: failed
    real(double) :: acc, imax
    real(double) :: deltaV
    type(DATACUBE) :: cube
    integer :: tester
    integer :: index1, index2

    failed = 0
    acc = 1d-1
    subpixels = nsubpixels
    cube%converged(index1,index2,cube%nv) = 1

700 allocate(subpixelgrid(1:subpixels,1:subpixels))
    allocate(testgrid(0:subpixels+1,0:subpixels+1))
    
    cube%nsubpixels(index1,index2,cube%nv) = subpixels
    
    pixelbasis1 = imagebasis1 / dble(subpixels)
    pixelbasis2 = imagebasis2 / dble(subpixels)
    newposvec = pixelcorner + (pixelbasis1 + pixelbasis2) / 2.d0
    subpixelsize = (pixelside/subpixels)**2
    subpixelgrid = 0.d0
    totalpixelintensity = 0.d0
    
    do j = 1,subpixels
       if (j==1) then 
          newposvec = newposvec - pixelbasis1 
       else
          newposvec = newposvec - (pixelbasis1 + dble(subpixels)*pixelbasis2)
       endif
           
       do i = 1,subpixels
          i0 = intensityalongray(newposvec,viewvec,grid,thisMolecule,itrans,deltaV)
 
          subpixelgrid(i,j) = i0 * subpixelsize
          totalpixelintensity = totalpixelintensity + subpixelgrid(i,j) ! assumes constant instrument function
          newposvec = newposvec + pixelbasis2
       enddo
    enddo

 if(tester == 0) then

    max = maxval(subpixelgrid(:,:))
    
    testgrid(1:subpixels,1:subpixels) = subpixelgrid / max
    testgrid(0,1:subpixels) = testgrid(1,1:subpixels)
    testgrid(1:subpixels,0) = testgrid(1:subpixels,1)
    testgrid(subpixels+1,1:subpixels) = testgrid(subpixels,1:subpixels)
    testgrid(1:subpixels,subpixels+1) = testgrid(1:subpixels,subpixels)
  
    do i = 1,subpixels
       do j = 1,subpixels
          if(failed /= 1) then
             if(testgrid(i,j) > 1.d-2) then
                if((abs(testgrid(i-1,j) - testgrid(i,j)) > acc .or. & ! Look at nearest neighbours for change (is there a better way of doing this?)
                     abs(testgrid(i,j-1) - testgrid(i,j)) > acc .or. &
                     abs(testgrid(i+1,j) - testgrid(i,j)) > acc .or. &
                     abs(testgrid(i,j+1) - testgrid(i,j)) > acc)) then 
                   !write(*,*) "Test failed",i,j,testgrid(i-1,j),testgrid(i,j-1),testgrid(i+1,j),testgrid(i,j+1), testgrid(i,j) 
                   
                   if(subpixels < 15) then 
                      subpixels = subpixels * 2
                      !write(*,*) "Trying",subpixels,"subpixels"
                   else
                      failed = 1
                      !write(*,*) "Sad :( because reached maximum resolution without achieving 'convergence'"
                      cube%converged(index1,index2,cube%nv) = 0 ! Write convergence info to last line (to be moved later) to save passing even more parameters 
                   endif             
                
                deallocate(subpixelgrid)
                deallocate(testgrid)
                if (failed == 0) goto 700 ! I used a goto loop and loved it. Seems the most natural way of doing this to me
             endif
          endif
       endif
    enddo
 enddo
       
endif

  end function PixelIntensity
  
  subroutine calculateMoleculeSpectrum(grid, thisMolecule, iTrans, viewVec, distance)
!$MPI    include 'mpif.h'

    type(GRIDTYPE) :: grid
    type(MOLECULETYPE) :: thisMolecule
    real(double) :: distance
    integer :: itrans
    integer :: nRay
    type(OCTALVECTOR) :: rayPosition(5000)
    real(double) :: da(5000), dOmega(5000), r
    type(OCTALVECTOR) :: viewVec
    real(double) :: deltaV
    integer :: iv, iray
    integer :: nLambda
    real(double) :: flux, i0
    real(double), allocatable :: vArray(:), spec(:), tempArray(:)
    integer :: iv1, iv2, i,j
    integer :: npixels,nv
    real(double) :: imageside
    type(OCTALVECTOR) :: unitvec, posvec
!   type(DATACUBE) :: mycube,cube16,cube4,cube2,varcube,diffcube42,diffcubevar4,diffcubevar2,diffcube16var,diffcube164,thecube
    type(DATACUBE) ::  cube
    integer :: tester ! tests subpixels per pixel - change this variable name!

    real :: value
    integer,allocatable :: somegrid(:,:)

!$MPI    ! For MPI implementations
!$MPI    integer       ::   my_rank        ! my processor rank
!$MPI    integer       ::   np             ! The number of processes
!$MPI    integer       ::   ierr           ! error flag
!$MPI    logical       ::   rankComplete


!$MPI    ! FOR MPI IMPLEMENTATION=======================================================
!$MPI    !  Get my process rank # 
!$MPI    call MPI_COMM_RANK(MPI_COMM_WORLD, my_rank, ierr)
!$MPI  
!$MPI    ! Find the total # of precessor being used in this run
!$MPI    call MPI_COMM_SIZE(MPI_COMM_WORLD, np, ierr)
       
    unitvec = randomunitvector()
    !unitvec = OCTALVECTOR(1.d0,0.d0,0.d0) ! Allows our choice of unit vector
    imageside = 5D7
    Npixels = 20
    nv = 20
    itrans = 4

    allocate(somegrid(1:npixels,1:npixels))
    somegrid = 0
    value = (4.6d7/(imageside/dble(npixels)))/2.d0
    value = 50d0
    write(*,*) "VALUE", value

    do i = 1, npixels
       do j = 1, npixels
          if (sqrt((i-npixels/2.d0)**2 + (j-npixels/2.d0)**2) < value+5d-1) then
             if (sqrt((i-npixels/2.d0)**2+(j-npixels/2.d0)**2) < (value-5d-1)) then
                somegrid(i,j) = somegrid(i,j) + 2
                somegrid(j,i) = somegrid(j,i) + 2
                somegrid(npixels+1 - i,npixels+1 - j) = somegrid(npixels+1 - i,npixels+1 - j) + 2
                somegrid(npixels+1 - j,npixels+1 - i) = somegrid(npixels+1 - j,npixels+1 - i) + 2
             else
                somegrid(i,j) = somegrid(i,j) + 1
                somegrid(j,i) = somegrid(j,i) + 1
                somegrid(npixels+1 - i,npixels+1 - j) = somegrid(npixels+1 - i,npixels+1 - j) + 1
                somegrid(npixels+1 - j,npixels+1 - i) = somegrid(npixels+1 - j,npixels+1 - i) + 1
             endif
          else
             somegrid(i,j) = somegrid(i,j) + 0
             somegrid(j,i) = somegrid(j,i) + 0
             somegrid(npixels+1 - i,npixels+1 - j) = somegrid(npixels+1 - i,npixels+1 - j) + 0
             somegrid(npixels+1 - j,npixels+1 - i) = somegrid(npixels+1 - j,npixels+1 - i) + 0
          endif
       enddo
    enddo
    
    do i=1,npixels
       do j=1,npixels
          if (somegrid(i,j) > 1) then
             somegrid(i,j) = 1
          else
             somegrid(i,j) = 0
             endif
       enddo
    enddo

    write(*,*) somegrid
    tester = 0
    call createimage(cube, grid, imageside, npixels, nv, unitvec, thismolecule, itrans, tester)
    !write(*,*) cube%weight(1:npixels,1:npixels)
  !  write(*,*) "AAAAAAAAAAAAAAAAAAAA"
    cube%weight(1:npixels,1:npixels) = somegrid
    !write(*,*) somegrid
 !   write(*,*) "BBBBBBBBBBBBBBBBBBBB"
   ! write(*,*) cube%weight(1:npixels,1:npixels)
!    write(*,*) "CCCCCCCCCCCCCCCCCCCC"
    call plotDataCube(cube, 'thecube.ps/vcps')

    write(*,*) "End"
    !write(*,*) "CONVO",cube%converged(:,:,:)
    !write(*,*) "subs",cube%nsubpixels(:,:,:)
    stop

    call createRayGrid(nRay, rayPosition, da, dOmega, viewVec, distance, grid)

    nLambda = 50

    iv1 = 1
    iv2 = nLambda
 
!$MPI    iv1 = (my_rank) * (nLambda / (np)) + 1
!$MPI    iv2 = (my_rank+1) * (nLambda / (np))
!$MPI    if (my_rank == (np-1)) iv2 = nLambda

    allocate(spec(1:nLambda), vArray(1:nLambda))
    spec = 0.d0
    do iv = 1, nLambda
       vArray(iv) = 1.e5/cspeed * (2.d0*dble(iv-1)/dble(nLambda)-1.d0)
 enddo
    do iv = iv1, iv2
       deltaV  = vArray(iv)
       write(*,*) iv
       do iRay = 1, nRay
          i0 = intensityAlongRay(rayposition(iRay), viewvec, grid, thisMolecule, iTrans, deltaV)
          spec(iv) = spec(iv) + i0  * domega(iRay) / sum(domega(1:nray))
       enddo
    enddo

!$MPI     call MPI_BARRIER(MPI_COMM_WORLD, ierr) 
!$MPI     allocate(tempArray(1:nLambda))
!$MPI       call MPI_ALLREDUCE(spec,tempArray,nLambda,MPI_DOUBLE_PRECISION,&
!$MPI           MPI_SUM,MPI_COMM_WORLD,ierr)
!$MPI    spec(1:nLambda) = tempArray(1:nLambda)
!$MPI     deallocate(tempArray)

!$MPI    if (my_rank == 0) then
    open(42, file="spectrum.dat",status="unknown",form="formatted")
    do i = 1, nLambda
       write(42, *) vArray(i)*cspeed/1.d5, spec(i)
    enddo
    close(42)
!$MPI endif
    deallocate(vArray, spec)
  end subroutine calculateMoleculeSpectrum

  subroutine createimage(cube, grid, imageside, npixels, nv, unitvec, thisMolecule, iTrans, tester)
!$MPI    include 'mpif.h'

    type(MOLECULETYPE) :: thisMolecule
    type(GRIDTYPE) :: grid
    type(DATACUBE) :: cube
    type(OCTALVECTOR) :: unitvec
    real(double) :: distance = 250.d0*pctocm/1.d10
    real(double) :: deltaV
    integer :: iTrans
    integer :: i, j, k
    real(double) :: r, xval, yval
    integer :: nMonte, imonte, n
    real(double), allocatable :: tempArray(:), tempArray2(:)
    integer :: ix1, ix2, iv
    real(double) :: imageside
    integer :: npixels,nv
    integer :: tester
    
!$MPI    ! For MPI implementations
!$MPI    integer       ::   my_rank        ! my processor rank
!$MPI    integer       ::   np             ! The number of processes
!$MPI    integer       ::   ierr           ! error flag
!$MPI    logical       ::   rankComplete

!$MPI    ! FOR MPI IMPLEMENTATION=======================================================
!$MPI    !  Get my process rank # 
!$MPI    call MPI_COMM_RANK(MPI_COMM_WORLD, my_rank, ierr)
!$MPI  
!$MPI    ! Find the total # of precessor being used in this run
!$MPI    call MPI_COMM_SIZE(MPI_COMM_WORLD, np, ierr)
    
    call initCube(cube, npixels, npixels, nv)
    call addSpatialAxes(cube, -imageside/2.d0,imageside/2.d0,-imageside/2.d0,imageside/2.d0)
    call addvelocityAxis(cube, 1.d0, -1.d0) ! velocities in km/s from +ve (redder, away) to -ve (bluer,towards)
 
!$MPI    ix1 = (my_rank) * (cube%nx / (np)) + 1
!$MPI    ix2 = (my_rank+1) * (cube%nx / (np))
!$MPI    if (my_rank == (np-1)) ix2 = cube%nx

    do iv = 1,cube%nv
       deltaV = (cube%vAxis(iv)*1.d5/cSpeed) ! velocities in fraction of c
       WRITE(*,*) "DELTAV",deltaV
       cube%intensity(:,:,iv) = makeImageGrid(unitvec,npixels,imageside,grid,thisMolecule,itrans,deltaV,tester,cube)
       cube%converged(:,:,iv) = cube%converged(:,:,cube%nv)
       cube%nsubpixels(:,:,iv) = cube%nsubpixels(:,:,cube%nv)
    enddo

!    do i = ix1, ix2
!       write(*,*) i
!	write(*,*) "You are here"
!       do j = 1, cube%ny
!
!          do iMonte = 1, nMonte
!             if (nMonte > 1) then
!                call random_number(r)
!                xVal = cube%xAxis(i) + (r-0.5d0)*(cube%xAxis(2)-cube%xAxis(1))
!                call random_number(r)
!!                yVal = cube%yAxis(j) + (r-0.5d0)*(cube%yAxis(2)-cube%yAxis(1))
!             else
!                xVal = cube%xAxis(i)
!                yVal = cube%yAxis(j)
!             endif
!             rayPos =  (xval * xProj) + (yval * yProj)
!             raypos = rayPos + ((-1.d0*distance) * viewVec)
!             do k = 1, cube%nv
!                deltaV = cube%vAxis(k)*1.d5/cSpeed
!                cube%intensity(i,j,k) = intensityAlongRay(rayPos, viewVec, grid, thisMolecule, iTrans, deltaV)
!             enddo
!          enddo
!          cube%intensity(i,j,1:cube%nv) = cube%intensity(i,j,1:cube%nv) / dble(nMonte)
!       enddo
!    enddo

!$MPI    n = (cube%nx*cube%ny*cube%nv)
!$MPI    allocate(tempArray(1:n), tempArray2(1:n))
!$MPI    tempArray = reshape(cube%intensity, (/  n /))

!$MPI     call MPI_BARRIER(MPI_COMM_WORLD, ierr) 

!$MPI       call MPI_ALLREDUCE(tempArray,tempArray2,n,MPI_DOUBLE_PRECISION,&
!$MPI           MPI_SUM,MPI_COMM_WORLD,ierr)

!$MPI    cube%intensity = reshape(tempArray2, (/ cube%nx, cube%ny, cube%nv /))
!$MPI    deallocate(tempArray, tempArray2)

  end subroutine createimage

  subroutine createRayGrid(nRay, rayPosition, da, dOmega, viewVec, distance, grid)
    type(GRIDTYPE) :: grid
    integer :: nRay
    type(OCTALVECTOR) :: rayPosition(:), thisPos, viewVec, xProj,yProj
    real(double) :: da(:), dOmega(:), distance
    real(double), allocatable :: rGrid(:), dr(:), phigrid(:), dphi(:)
    real(double) :: rMax
    integer :: nr, nphi, ir, iphi
    real(double) :: r1 , r2, phi1, phi2, phiOffset
    real(double) :: xPos, yPos, zPos, cosInc, azimuth

    rmax = 1.08d7
    nr = 100
    nphi = 10
    nray = 0


    allocate(rGrid(1:nr), dr(1:nr), phiGrid(1:nPhi), dphi(1:nPhi))

    do ir = 1, nr
       r1 = log10(rmax) * dble(ir-1)/dble(nr)
       r2 = log10(rmax) * dble(ir)/dble(nr)
       r1 = 10.d0**r1
       r2 = 10.d0**r2
       rgrid(ir) = 0.5d0 * (r1 + r2)
       dr(ir) = r2 - r1
    enddo
    do iphi = 1, nPhi
       phi1 = twoPi * dble(iphi-1)/dble(nPhi)
       phi2 = twoPi * dble(iphi)/dble(nPhi)
       phiGrid(iPhi) = 0.5d0 * (phi1 + phi2)
       dphi(iPhi) = phi2 - phi1
    enddo

    do ir = 1, nr
       r1 = rGrid(ir)
       call random_number(phiOffset)
       phiOffset = phiOffset * dphi(1)
       do iPhi = 1, nPhi
          phi1 = phiGrid(iPhi) + phiOffset
          if (phi1 > twoPi) phi1 = phi1 - twoPi

          xPos = r1 * sin(phi1)
          yPos = 0.d0
          zPos = r1 * cos(phi1)

          xProj =  OCTALVECTOR(0.d0, 0.d0, 1.d0)  .cross. viewVec
          call normalize(xProj)
          yProj = viewVec .cross. xProj
         call normalize(yProj)

          nRay = nRay + 1
         rayPosition(nray) =  (xPos * xProj) + (zPos * yProj)
         rayposition(nray) = rayPosition(nRay) + ((-1.d0*distance) * viewVec)

          da(nRay) = pi*( (r1 + dr(ir)/2.d0)**2 - (r1 - dr(ir)/2.d0)**2) * dphi(iPhi)/twoPi
          dOmega(nRay) = da(nRay) / (fourPi * distance**2)
       enddo
    enddo
  end subroutine createRayGrid

  subroutine createDataCube(cube, grid, viewVec, thisMolecule, iTrans)
!$MPI    include 'mpif.h'

    type(MOLECULETYPE) :: thisMolecule
    type(GRIDTYPE) :: grid
    type(DATACUBE) :: cube
    type(OCTALVECTOR) :: viewvec, rayPos, xProj, yProj
    real(double) :: distance = 250.d0*pctocm/1.d10
    real(double) :: deltaV
    integer :: iTrans
    integer :: i, j, k
    real(double) :: r, xval, yval
    integer :: nMonte, imonte, n
    real(double), allocatable :: tempArray(:), tempArray2(:)
    integer :: ix1, ix2
!$MPI    ! For MPI implementations
!$MPI    integer       ::   my_rank        ! my processor rank
!$MPI    integer       ::   np             ! The number of processes
!$MPI    integer       ::   ierr           ! error flag
!$MPI    logical       ::   rankComplete


!$MPI    ! FOR MPI IMPLEMENTATION=======================================================
!$MPI    !  Get my process rank # 
!$MPI    call MPI_COMM_RANK(MPI_COMM_WORLD, my_rank, ierr)
!$MPI  
!$MPI    ! Find the total # of precessor being used in this run
!$MPI    call MPI_COMM_SIZE(MPI_COMM_WORLD, np, ierr)

    nMonte = 1

    call initCube(cube, 100, 100, 50)
    call addSpatialAxes(cube, -grid%octreeRoot%subcellSize*0.1d0, +grid%octreeRoot%subcellSize*0.1d0, &
         -grid%octreeRoot%subcellSize*0.1d0, grid%octreeRoot%subcellSize*0.1d0)
    call addvelocityAxis(cube, -1.d0, 1.d0)

    xProj =  OCTALVECTOR(0.d0, 0.d0, 1.d0)  .cross. viewVec
    call normalize(xProj)
    yProj = viewVec .cross. xProj
    call normalize(yProj)
    ix1 = 1
    ix2 = cube%nx
 
!$MPI    ix1 = (my_rank) * (cube%nx / (np)) + 1
!$MPI    ix2 = (my_rank+1) * (cube%nx / (np))
!$MPI    if (my_rank == (np-1)) ix2 = cube%nx


    do i = ix1, ix2
       write(*,*) i
	write(*,*) "You are here"
       do j = 1, cube%ny

          do iMonte = 1, nMonte
             if (nMonte > 1) then
                call random_number(r)
                xVal = cube%xAxis(i) + (r-0.5d0)*(cube%xAxis(2)-cube%xAxis(1))
                call random_number(r)
                yVal = cube%yAxis(j) + (r-0.5d0)*(cube%yAxis(2)-cube%yAxis(1))
             else
                xVal = cube%xAxis(i)
                yVal = cube%yAxis(j)
             endif
             rayPos =  (xval * xProj) + (yval * yProj)
             raypos = rayPos + ((-1.d0*distance) * viewVec)
             do k = 1, cube%nv
                deltaV = cube%vAxis(k)*1.d5/cSpeed
                cube%intensity(i,j,k) = intensityAlongRay(rayPos, viewVec, grid, thisMolecule, iTrans, deltaV)
             enddo
          enddo
          cube%intensity(i,j,1:cube%nv) = cube%intensity(i,j,1:cube%nv) / dble(nMonte)
       enddo
    enddo

!$MPI    n = (cube%nx*cube%ny*cube%nv)
!$MPI    allocate(tempArray(1:n), tempArray2(1:n))
!$MPI    tempArray = reshape(cube%intensity, (/  n /))

!$MPI     call MPI_BARRIER(MPI_COMM_WORLD, ierr) 

!$MPI       call MPI_ALLREDUCE(tempArray,tempArray2,n,MPI_DOUBLE_PRECISION,&
!$MPI           MPI_SUM,MPI_COMM_WORLD,ierr)

!$MPI    cube%intensity = reshape(tempArray2, (/ cube%nx, cube%ny, cube%nv /))
!$MPI    deallocate(tempArray, tempArray2)

  end subroutine createDataCube
    
!$MPI      subroutine packMoleLevel(octalArray, nTemps, tArray, octalsBelongRank, iLevel)
!$MPI    include 'mpif.h'
!$MPI        type(OCTALWRAPPER) :: octalArray(:)
!$MPI        integer :: octalsBelongRank(:)
!$MPI        integer :: nTemps
!$MPI        real(double) :: tArray(:)
!$MPI        integer :: iOctal, iSubcell, my_rank, ierr
!$MPI        integer :: iLevel
!$MPI        type(OCTAL), pointer :: thisOctal
!$MPI
!$MPI       call MPI_COMM_RANK(MPI_COMM_WORLD, my_rank, ierr)
!$MPI       !
!$MPI       ! Update the edens values of grid computed by all processors.
!$MPI       !
!$MPI       nTemps = 0
!$MPI       do iOctal = 1, SIZE(octalArray)
!$MPI
!$MPI          thisOctal => octalArray(iOctal)%content
!$MPI          
!$MPI          do iSubcell = 1, thisOctal%maxChildren
!$MPI              if (.not.thisOctal%hasChild(iSubcell)) then
!$MPI                 nTemps = nTemps + 1
!$MPI                 if (octalsBelongRank(iOctal) == my_rank) then
!$MPI                   tArray(nTemps) = thisOctal%newMolecularLevel(isubcell, iLevel)
!$MPI                 else 
!$MPI                   tArray(nTemps) = 0.d0
!$MPI                 endif
!$MPI              endif
!$MPI          end do
!$MPI       end do
!$MPI     end subroutine packMoleLevel

!$MPI      subroutine unpackMoleLevel(octalArray, nTemps, tArray, octalsBelongRank, iLevel)
!$MPI    include 'mpif.h'
!$MPI        type(OCTALWRAPPER) :: octalArray(:)
!$MPI        integer :: octalsBelongRank(:)
!$MPI        integer :: nTemps
!$MPI        real(double) :: tArray(:)
!$MPI        integer :: iOctal, iSubcell, my_rank, ierr
!$MPI        integer :: iLevel
!$MPI        type(OCTAL), pointer :: thisOctal
!$MPI
!$MPI       call MPI_COMM_RANK(MPI_COMM_WORLD, my_rank, ierr)
!$MPI       !
!$MPI       ! Update the edens values of grid computed by all processors.
!$MPI       !
!$MPI       nTemps = 0
!$MPI       do iOctal = 1, SIZE(octalArray)
!$MPI
!$MPI          thisOctal => octalArray(iOctal)%content
!$MPI          
!$MPI          do iSubcell = 1, thisOctal%maxChildren
!$MPI              if (.not.thisOctal%hasChild(iSubcell)) then
!$MPI                 nTemps = nTemps + 1
!$MPI                 thisOctal%newMolecularLevel(isubcell, iLevel) = tArray(nTemps) 
!$MPI              endif
!$MPI          end do
!$MPI       end do
!$MPI     end subroutine unpackMoleLevel

end module molecular_mod

!!! USEFUL COMMENTED CODE HERE FOR A WHILE

    !tester = 2    
    !call createimage(cube2, grid, imageside, npixels, nv, unitvec, thismolecule, itrans, tester)
    
    !tester = 4    
    !call createimage(cube4, grid, imageside, npixels, nv, unitvec, thismolecule, itrans, tester)

    !call initCube(diffcube42, npixels, npixels, nv)
    !call addSpatialAxes(diffcube42, -imageside/2.d0,imageside/2.d0,-imageside/2.d0,imageside/2.d0)
    !call addvelocityAxis(diffcube42, -1.d0, 1.d0)

    !diffcube42%intensity(:,:,:) = cube4%intensity(:,:,:) - cube2%intensity(:,:,:)

!    call plotDataCube(cube4, 'cube4.ps/vcps')
 !   call plotDataCube(cube2, 'cube2.ps/vcps')
  !  call plotDataCube(diffcube42, 'diffcube42.ps/vcps')
 
!    tester = 0
!    call createimage(varcube, grid, imageside, npixels, nv, unitvec, thismolecule, itrans, tester)
    
   ! call initCube(diffcubevar4, npixels, npixels, nv)
    !call addSpatialAxes(diffcubevar4, -imageside/2.d0,imageside/2.d0,-imageside/2.d0,imageside/2.d0)
    !call addvelocityAxis(diffcubevar4, -1.d0, 1.d0)

!    call initCube(diffcubevar2, npixels, npixels, nv)
 !   call addSpatialAxes(diffcubevar2, -imageside/2.d0,imageside/2.d0,-imageside/2.d0,imageside/2.d0)
  !  call addvelocityAxis(diffcubevar2, -1.d0, 1.d0)
 
   ! diffcubevar4%intensity(:,:,:) = varcube%intensity(:,:,:) - cube4%intensity(:,:,:)
    !diffcubevar2%intensity(:,:,:) = varcube%intensity(:,:,:) - cube2%intensity(:,:,:)

!    call plotDataCube(varcube, 'thecube.ps/vcps')
!    call plotDataCube(diffcubevar4, 'diffcubevar4.ps/vcps')
 !   call plotDataCube(diffcubevar2, 'diffcubevar2.ps/vcps')

  !  tester = 16
   ! call createimage(cube16, grid, imageside, npixels, nv, unitvec, thismolecule, itrans, tester)

!    call initCube(diffcube16var, npixels, npixels, nv)
 !   call addSpatialAxes(diffcube16var, -imageside/2.d0,imageside/2.d0,-imageside/2.d0,imageside/2.d0)
  !  call addvelocityAxis(diffcube16var, -1.d0, 1.d0)

!    call initCube(diffcube164, npixels, npixels, nv)
 !   call addSpatialAxes(diffcube164, -imageside/2.d0,imageside/2.d0,-imageside/2.d0,imageside/2.d0)
  !  call addvelocityAxis(diffcube164, -1.d0, 1.d0)
 
!    diffcube16var%intensity(:,:,:) = cube16%intensity(:,:,:) - varcube%intensity(:,:,:)
 !   diffcube164%intensity(:,:,:) = cube16%intensity(:,:,:) - cube4%intensity(:,:,:)

  !  call plotDataCube(cube16, 'cube16.ps/vcps')
   ! call plotDataCube(diffcube16var, 'diffcube16var.ps/vcps')
    !call plotDataCube(diffcube164, 'diffcube164.ps/vcps')

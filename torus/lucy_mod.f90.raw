module lucy_mod

  use constants_mod
  use grid_mod
  use dust_mod
  use vector_mod
  use phasematrix_mod
  use amr_mod
  use source_mod
  use spectrum_mod
  use parallel_mod
  use timing
  use diffusion_mod
  use messages_mod

  implicit none


contains


  subroutine lucyRadiativeEquilibrium(grid, miePhase, nDustType, nMuMie, nLambda, lamArray, temperature, nLucy)

    type(GRIDTYPE) :: grid
    type(OCTALVECTOR) :: uHat, uNew
    type(OCTALVECTOR) :: rVec
    integer :: nlucy
    integer :: nDustType
    integer,intent(in) :: nLambda, nMuMie
    type(PHASEMATRIX):: miePhase(1:nDustType,1:nLambda, 1:nMuMie)
    real :: lamArray(:)
    real(oct), allocatable :: distanceGrid(:, :, :)
    real(oct) :: r
    integer, parameter :: nFreq = 100
    integer :: i, j, k
    real(oct) :: freq(nFreq), dnu(nFreq), probDistPlanck(nFreq), probDistJnu(nFreq)
    real(oct) :: temperature
    integer :: nMonte, iMonte, nScat, nAbs
    real(oct) :: thisFreq,  logFreqStart, logFreqEnd
    real(oct) :: albedo
    logical :: escaped
    integer :: i1, i2, i3
    real(oct) :: t1, t2, t3
    real(oct) :: thisLam
    integer :: iLam
    integer :: nInf
    real(oct) :: t
    integer :: nt
    real(oct) :: ang
    integer :: iIter, nIter = 5
    real(oct) :: kabs
    real(oct) ::  kappaP, norm
    real(oct) :: adot, V, epsOverDeltaT
    real(oct) :: newT, deltaT
    real(oct) :: meanDeltaT
    real(oct) :: dx, dy, tr(6), fg, bg
    real(double) :: dummy(1)
    real(oct), allocatable :: tempImage(:,:)
    integer :: nDT
    real(oct) :: totalEmission
    type(vector) :: vec_tmp

    allocate(tempImage(1:grid%nx,1:grid%ny))


    logFreqStart = log10((cSpeed / (lamArray(nLambda)*1.e-8)))
    logFreqEnd =  log10((cSpeed / (lamArray(1)*1.e-8)))
    write(*,*) logFreqStart, logFreqEnd
    do i = 1, nFreq
       freq(i) = logFreqStart + (dble(i-1)/dble(nFreq-1))*(logFreqEnd-logFreqStart)
       freq(i) = 10.**freq(i)
    enddo
    write(*,*) "Lam",(cSpeed/freq(1))*1.e8,(cSpeed/freq(nFreq))*1.e8

    do i = 2, nFreq-1
       dnu(i) = 0.5*((freq(i+1)+freq(i))-(freq(i)+freq(i-1)))
    enddo
    dnu(1) = freq(2)-freq(1)
    dnu(nFreq) = freq(nFreq)-freq(nFreq-1)



    call setupFreqProb(temperature, freq, dnu, nFreq, ProbDistPlanck)


    write(*,'(a)') "Computing lucy radiative equilibrium..."


    allocate(distanceGrid(1:grid%nx, 1:grid%ny, 1:grid%nz))


    do iIter = 1, nIter
       distanceGrid = 0.d0
       write(*,*) "Iteration",iIter
       nInf = 0
       nScat = 0
       nAbs = 0
       nMonte = nLucy

       do iMonte = 1, nMonte
          escaped = .false.
          call random_number(r)
          call locate(probDistPlanck, nFreq, r, j)
          thisFreq = freq(j) + (freq(j+1) - freq(j))* &
               (r - probDistPlanck(j))/(probDistPlanck(j+1)-probDistPlanck(j))


          rVec  = real(grid%rCore, kind=oct) * randomUnitOctalVector()
!          uHat = fromPhotosphereVector(rVec)
          ! -- using a new routine in source_mod.f90 (RK)
          uHat = random_direction_from_sphere(rVec)
          if ( (rVec .dot. uHat) < 0.) uHat = (-1.d0) * uHat

          do while(.not.escaped)
             call toNextEvent(grid, rVec, uHat, escaped, distanceGrid, thisFreq, nLambda, lamArray)
                
             if (escaped) nInf = nInf + 1

             if (.not. escaped) then

                thisLam = (cSpeed / thisFreq) * 1.e8
                call locate(lamArray, nLambda, real(thisLam), iLam)

                call getIndices(grid, rVec, i1, i2, i3, t1, t2, t3)
                if (.not.grid%oneKappa) then
                   albedo = grid%kappaSca(i1,i2,i3,iLam)/(grid%kappaSca(i1,i2,i3,iLam)+grid%kappaAbs(i1,i2,i3,iLam))
                else
                   albedo = grid%oneKappaSca(1,iLam) / (grid%oneKappaSca(1,iLam)+grid%oneKappaAbs(1,iLam))
                endif
                call random_number(r)
                if (r < albedo) then
                   vec_tmp=uhat 
                   uNew = newDirectionMie(vec_tmp, real(thisLam), lamArray, nLambda, miePhase, nDustType, nMuMie, dummy)

                   nScat = nScat + 1
                   uHat = uNew

                else
                   nAbs = nAbs + 1
                   probDistJnu(1) = 0.d0
                   do i = 2, nFreq
                      thisLam = (cSpeed / freq(i)) * 1.e8
                      call hunt(lamArray, nLambda, real(thisLam), iLam)
                      if ((ilam >=1).and.(ilam <= nlambda)) then
                         if (.not.grid%oneKappa) then
                            kabs = grid%kappaAbs(i1,i2,i3,iLam)
                         else
                            kabs = grid%oneKappaAbs(1,iLam) * grid%rho(i1,i2,i3)
                         endif
                         probDistJnu(i) = probDistJnu(i-1) + &
                             (bnu(freq(i),dble(grid%temperature(i1,i2,i3)))) &
                                                     * kabs * dnu(i)
                      endif
                   enddo
                   probDistJnu(1:nFreq) = probDistJnu(1:nFreq) / probDistJnu(nFreq)
                   call random_number(r)
                   call locate(probDistJnu, nFreq, r, j)
                   if (j == nFreq) j = nFreq -1
                   thisFreq = freq(j) + (freq(j+1) - freq(j))* &
                        (r - probDistJnu(j))/(probDistJnu(j+1)-probDistJnu(j))
                   uHat = randomUnitVector()
                endif

             endif
          enddo
       enddo
       write(*,'(a,f7.2)') "Photons done.",real(ninf)/real(nmonte)
       write(*,'(a,f7.3)') "Mean number of scatters per photon: ",real(nScat)/real(nMonte)
       write(*,'(a,f7.3)') "Mean number of absorbs  per photon: ",real(nAbs)/real(nMonte)


       V = (dble(grid%xAxis(2)-grid%xAxis(1))*dble(grid%yAxis(2)-grid%yAxis(1))*dble(grid%zAxis(2)-grid%zAxis(1)))


       epsOverDeltaT = (dble(grid%lCore)) / dble(nInf)

       meanDeltaT = 0.
       nDT = 0


       totalEmission = 0.
       do i1 = 1, grid%nx
          do i2 = 1, grid%ny
             do i3 = 1, grid%nz
                if (grid%inUse(i1,i2,i3)) then
                   adot = epsoverDeltaT * (1.d0 / v) * distancegrid(i1,i2,i3) / 1.d30
                   kappaP = 0.d0
                   norm = 0.d0
                   do i = 1, nFreq
                      thisLam = (cSpeed / freq(i)) * 1.e8
                      call hunt(lamArray, nLambda, real(thisLam), iLam)
                      if ((iLam >=1) .and. (iLam <= nLambda)) then
                         if (.not.grid%oneKappa) then
                            kabs = grid%kappaAbs(i1,i2,i3,iLam)
                         else
                            kabs = grid%oneKappaAbs(1,iLam) * grid%rho(i1,i2,i3)
                         endif

                         kappaP = kappaP + kabs * &
                              bnu(freq(i),dble(grid%temperature(i1,i2,i3)))  * dnu(i)
                         norm = norm + bnu(freq(i),dble(grid%temperature(i1,i2,i3)))  * dnu(i)
                      endif
                   enddo
                   kappaP = kappaP / norm /1.d10


                   newT = (pi / stefanBoltz) * aDot / (fourPi * kappaP)
                   newT = newT**0.25

                   deltaT = newT - grid%temperature(i1,i2,i3)
                   grid%temperature(i1,i2,i3) = max(1.e-3,grid%temperature(i1,i2,i3) + 0.8 * real(deltaT))
                   nDT = nDT  + 1
                   meanDeltaT = meanDeltaT + deltaT
                   kappaP = 0.d0
                   norm = 0.d0
                   do i = 1, nFreq
                      thisLam = (cSpeed / freq(i)) * 1.e8
                      call hunt(lamArray, nLambda, real(thisLam), iLam)
                      if ((iLam >=1) .and. (iLam <= nLambda)) then
                         if (.not.grid%oneKappa) then
                            kabs = grid%kappaAbs(i1,i2,i3,iLam)
                         else
                            kabs = grid%oneKappaAbs(1,iLam) * grid%rho(i1,i2,i3)
                         endif
                         kappaP = kappaP + kabs * &
                              bnu(freq(i),dble(grid%temperature(i1,i2,i3))) * dnu(i)
                         norm = norm + bnu(freq(i),dble(grid%temperature(i1,i2,i3))) * dnu(i)
                      endif
                   enddo
                   kappaP = kappaP / norm /1.e10
                   grid%etaCont(i1,i2,i3) = fourPi * kappaP * (stefanBoltz/pi) * (grid%temperature(i1,i2,i3)**4)
                   totalEmission = totalEmission + grid%etaCont(i1,i2,i3) * V

                endif
             enddo
          enddo
       enddo

       write(*,*) meanDeltaT / real(nDT)

       write(*,*) "Emissivity of dust / core", totalEmission /grid%lCore * 1.e30

       do i = 1, grid%nx
          do j = 1, grid%ny
             tempImage(i,j) = grid%temperature(i,j,grid%nz/2)
          enddo
       enddo

       dx = grid%xAxis(2) - grid%xAxis(1)
       dy = grid%yAxis(2) - grid%yAxis(1) 
       tr(1) =  - dx + grid%xAxis(1)
       tr(2) = dx
       tr(3) = 0.
       tr(4) =  - dy + grid%yAxis(1)
       tr(5) = 0.
       tr(6) = dy

       bg = MAXVAL(tempImage, mask=grid%inUse(1:grid%nx,1:grid%ny,grid%nz/2))
       fg = MINVAL(tempImage, mask=grid%inUse(1:grid%nx,1:grid%ny,grid%nz/2))
       call pgbegin(0,"/xs",1,1)

       call pgvport(0.1,0.9,0.1,0.9)

       call pgwnad(grid%xAxis(1), grid%xAxis(grid%nx), grid%yAxis(1), grid%yAxis(grid%ny))
       call palette(3)
       call pgimag(tempImage, grid%nx, grid%ny, 1, grid%nx, 1, grid%ny, fg, bg, tr)
       call pgwedg("RI", 0.,10., fg,bg," ")
       call pgbox('bcnst',0,0,'bcnst',0,0)
       call pgend
    enddo
    open(21,file="r.dat",status="unknown",form="formatted")
    do i = 1, 100
       r = grid%xAxis(grid%nx) * real(i-1)/99.
       t = 0
       nT = 0
       do j = 1, 100
          ang = twoPi * real(j-1)/100.
          rVec = OCTALVECTOR(r*cos(ang), r*sin(ang),0.)
          call getIndices(grid, rVec, i1, i2, i3, t1, t2, t3)
          if (grid%inUse(i1,i2,i3)) then
             nT = nT + 1
             t = t + grid%temperature(i1,i2,i3)
          endif
       enddo
       if (nt > 0) then
          t = t / real(nt)
          write(21,*) r / grid%rCore, t
       endif
    enddo
    close(21)

    open(22,file="temps.dat",status="unknown",form="unformatted")
    do i = 1, grid%nx
       do j = 1, grid%ny
          do k = 1, grid%nz
             write(22) grid%temperature(i,j,k), grid%etaCont(i,j,k)
          enddo
       enddo
    enddo
    close(22)


  end subroutine lucyRadiativeEquilibrium

  subroutine lucyRadiativeEquilibriumAMR(grid, miePhase, nDustType, nMuMie, nLambda, lamArray, &
       source, nSource, nLucy, massEnvelope, tthresh, percent_undersampled_min, twoD, maxIter)
    use input_variables, only : rinner, router, variableDustSublimation, zoomFactor, blockhandout
    use input_variables, only : smoothFactor, doSmoothGrid, lambdasmooth, plot_maps
    implicit none
!$MPI include 'mpif.h'
    type(GRIDTYPE) :: grid
    integer :: nSource
    integer :: iSmoothLam
    logical :: gridConverged
    integer :: nDustType
    type(SOURCETYPE) :: source(nsource), thisSource
    integer :: nLucy
    logical :: twoD
    ! threshold value for undersampled cell in percent (for stopping iteration).
    real, intent(in) :: percent_undersampled_min  
    type(OCTALVECTOR) ::  uHat, uNew, rVec, rHat, olduHat
    type(OCTALVECTOR) :: octVec,avedirection
    type(OCTAL), pointer :: thisOctal, sOctal, tempOctal
    integer :: tempSubcell
    integer, intent(in)  :: nLambda, nMuMie
    type(PHASEMATRIX):: miePhase(1:nDustType,1:nLambda, 1:nMuMie)
!    real  :: lamArray(:)
    real  :: lamArray(nLambda)
    real(oct) :: r
    real :: massEnvelope, scaleFac
    real :: tauMax
    real(oct) :: totalMass
    integer :: nFreq
    integer :: i, j
    real(oct) :: freq(2000), dnu(2000), probDistJnu(2000)
!    real(oct) :: probDistPlanck(nFreq)
    real(double) :: kappaScadb, kappaAbsdb
    integer :: nDiffusion
    integer :: nDiffusion_sub
    integer :: nMonte, iMonte, nScat, nAbs
    integer :: thisPhotonAbs
    real(oct) :: thisFreq
    real(oct) :: albedo
    logical :: escaped
    real(oct) :: t1
    real(oct) :: thisLam,wavelength
    integer :: iSource
    integer :: nRemoved
    real :: Tthresh
    integer :: iLam
    integer :: nInf
    integer :: iIter, nIter
    real(oct) ::   epsOverDeltaT
    real(oct) :: meanDeltaT
    integer :: nDT, nUndersampled
    real(oct) :: totalEmission
    integer :: subcell
    logical :: leftHandBoundary
    logical :: debugOutput
    real :: treal
    real(oct) :: lCore
    real      :: kabs
    type(vector) :: vec_tmp
    real :: dummy(1)
    real(oct)::  dT_sum ! [Kelvins]  the sum of the temperature change
    real(oct)::  dT_min ! [kelvins]  the minimum change of temperature
    real(oct)::  dT_max ! [kelvins]  the maximum change of temperature
    real(oct)::  dT_over_T_max ! [kelvins]  the maximum fractional change of temperature
    character(len=30) :: tfilename1, tfilename2, dustfile
    character(len=80) :: ofile, message
    logical, save :: first_time_to_open_file = .true.
    real :: totFrac
    integer :: nFrac
    integer, parameter :: LU_OUT = 42
    integer :: iIter_grand
    real(oct)::  dT_mean_new, dT_mean_old ! [Kelvins]
    logical :: converged
    real:: percent_undersampled
    integer :: nAbs_sub, nScat_sub, nInf_sub  ! For OpenMP
    integer :: nKilled
    integer :: maxIter
    integer       :: imonte_beg, imonte_end  ! the index boundary for the photon loops.
    real(double), allocatable :: kAbsArray(:)
    logical :: photonInDiffusionZone
    logical :: doingDustSublimation
    real :: diffusionZoneTemp, temp
    logical :: outputFlag, directPhoton, smoothconverged
    integer :: noctals, nvoxels, nCellsInDiffusion
    integer :: omp_get_num_threads, omp_get_thread_num

!$MPI    ! For MPI implementations
!$MPI  ! For MPI implementations =====================================================
!$MPI  integer ::   my_rank        ! my processor rank
!$MPI  integer ::   n_proc         ! The number of processes
!$MPI  integer ::   ierr           ! error flag
!$MPI  integer ::   n_rmdr, m      !
!$MPI  integer ::   mphotons       ! number of photons (actual) 
!$MPI  integer ::   tempInt        !
!$MPI  real, dimension(:), allocatable :: tempRealArray
!$MPI  real, dimension(:), allocatable :: tempRealArray2
!$MPI  integer, dimension(:), allocatable :: photonBelongsRank
!$MPI  integer, parameter :: tag = 0
!$MPI  logical :: rankComplete
!$MPI    ! data space to store values from all processors
!$MPI    real, save, allocatable  :: buffer_real(:)     
!$MPI    logical, save  :: first_time = .true.
!$MPI
!!$MPI    ! find the number of the processors for the first time.    
!!$MPI    if (first_time) then
!$MPI       call MPI_COMM_SIZE(MPI_COMM_WORLD, n_proc, ierr)
!!$MPI       allocate(buffer_real(n_proc))
!!$MPI       first_time = .false.
!!$MPI    end if
!$MPI
!$MPI       allocate(buffer_real(n_proc))
!$MPI
!$MPI    ! FOR MPI IMPLEMENTATION=======================================================
!$MPI    !  Get my process rank # 
!$MPI    call MPI_COMM_RANK(MPI_COMM_WORLD, my_rank, ierr)
!$MPI  
!$MPI    ! Find the total # of precessor being used in this run
!$MPI    call MPI_COMM_SIZE(MPI_COMM_WORLD, n_proc, ierr)
!$MPI    
!$MPI    if (my_rank .eq. 0) then
!$MPI       print *, ' '
!$MPI       print *, 'Lucy radiative equilibrium routine computed by ', n_proc, ' processors.'
!$MPI       print *, ' '
!$MPI    endif
!$MPI    
!$MPI    ! ============================================================================

    allocate(kabsArray(1:nLambda))



    nMonte = nLucy
    nFreq = nLambda
    do i = 1, nFreq
       freq(nFreq-i+1) = cSpeed / (lamArray(i)*1.e-8)
    enddo


    do i = 2, nFreq-1
       dnu(i) = 0.5*((freq(i+1)+freq(i))-(freq(i)+freq(i-1)))
    enddo
    dnu(1) = freq(2)-freq(1)
    dnu(nFreq) = freq(nFreq)-freq(nFreq-1)

! if we are in two-D then we make a quick remap of the density grid
! to ensure that we don't have numerical effects due to sampling
! differences as a function of azimuth

    if (twoD) then
       call remapDistanceGrid(grid%octreeRoot, grid)
       call zeroDistanceGrid(grid%octreeRoot)       ! distance grid in the first instance is used to store the total cell
                                                    ! volume corresponding to the mapping of the 3d -> 2d
       call setupCellVolumes(grid%octreeRoot,grid)  ! these volumes are set up here
       call normCellVolumes(grid%octreeRoot,grid)   ! etaLine is used as a placeholder for a fractional volume in the
                                                    ! 3d to 2d mapping
    endif



      outputFlag = .true.
!$MPI if (my_rank/=0) outputFlag = .false.

!$MPI if (my_rank==0) &
      call writeAMRgrid("lucy_first_grid.dat", .false., grid)



!    call setupFreqProb(temperature, freq, dnu, nFreq, ProbDistPlanck)

!$MPI    if(my_rank == 0) &
    call writeInfo("Computing lucy radiative equilibrium in AMR...",TRIVIAL)


    lCore = 0.d0
    do i = 1, nSource
       lCore = lCore + source(i)%luminosity
    enddo
!$MPI    if(my_rank == 0) &
    write(message,'(a,1pe12.5)') "Total souce luminosity (lsol): ",lCore/lSol
    call writeInfo(message, TRIVIAL)

    if (grid%geometry == "shakara") then
	if (nDustType > 1) then
           call fillDustShakara(grid, grid%octreeRoot)
        endif
	if (variableDustsublimation) then
           call stripDustAway(grid%octreeRoot,1.d-10)
        endif
    endif

    if ((grid%geometry == "ppdisk").and.(nDustType > 1)) then
       call fillDustUniform(grid, grid%octreeRoot)
    endif

    if (grid%geometry == "wr104") then
       call fillDustUniform(grid, grid%octreeRoot)
       call stripDustAway(grid%octreeRoot, 1.d-10)
    endif



    nCellsInDiffusion = 0
    call defineDiffusionOnRosseland(grid,grid%octreeRoot, ndiff=nCellsInDiffusion)
    write(message,*) "Number of cells in diffusion zone: ", nCellsInDiffusion
    call writeInfo(message,IMPORTANT)


    iIter_grand = 0
    nRemoved = 1
    converged = .false.
    dT_mean_new = 10.0d0
    dT_mean_old = 10.0d0

    doingDustSublimation = .false.
    if (variableDustSublimation) doingDustSublimation = .true.

    do while (.not.converged)
       ! ensure we do at least three iterations
       ! before removing the high temperature cells.
       if (iIter_grand>1) then
          nIter = 1
       else
          nIter = 1
       end if

!       if (doingDustSublimation) then
!          nMonte = 10000000
!          if (iIter_grand == 0) then
!             nIter = 3
!          else
!             nIter = 1 !2
!          endif
!       endif



    do iIter = 1, nIter


       iIter_grand =  iIter_grand + 1  ! total number of iterations so far


!       write(tfilename1, '(a,i2.2,a)') "lucy_iter_",iIter_grand,".gif/gif"
!       write(tfilename2, '(a,i2.2,a)') "lucy_iter_zoom",iIter_grand,".gif/gif"

       call locate(lamArray, nLambda, 5500.,ilam)

       ! Plotting the intermidiate temperature steps

       if (plot_maps) then

!$MPI    if(my_rank == 0)  then
       call plot_AMR_values(grid, "rho", "x-z", real(grid%octreeRoot%centre%y), &
            "rho_temp_xz.ps/vcps", .true., .false., &
            0, dummy, dummy, dummy, real(grid%octreeRoot%subcellsize), .false.) 

!       write(dustfile,'(a,i3.3,a)') "dusttype",iIter_grand,".gif/gif"
!       call plot_AMR_values(grid, "dusttype", "x-z", 0., &
!            dustfile, .false., .false., &
!           0, dummy, dummy, dummy, real(grid%octreeRoot%subcellsize), .false., boxfac=zoomFactor, &
!           xStart=1600., xEnd=2200., yStart=-300., yEnd=300.)

       call plot_AMR_values(grid, "dusttype", "x-z", 0., &
            "dusttype.ps/vcps", .false., .false., &
           0, dummy, dummy, dummy, real(grid%octreeRoot%subcellsize), .false., boxfac=zoomFactor)
       call plot_AMR_values(grid, "dusttype", "x-z", 0., &
            "dusttype_full.ps/vcps", .false., .false., &
           0, dummy, dummy, dummy, real(grid%octreeRoot%subcellsize), .false.)

       if (grid%geometry == "shakara") then
          call dullemondplot(grid, rinner, router, 0.4, nSource, source)
          call nattaplot(grid, nSource, source)
       endif

       call plot_AMR_values(grid, "rho", "x-z", real(grid%octreeRoot%centre%y), &
            "rho_temp_zoom.ps/vcps", .true., .false., &
            0, dummy, dummy, dummy, real(grid%octreeRoot%subcellsize), .false.,boxfac=zoomFactor) 
       call plot_AMR_values(grid, "rho", "x-y", real(grid%octreeRoot%centre%y), &
            "rho_temp_xy.ps/vcps", .true., .false., &
            0, dummy, dummy, dummy, real(grid%octreeRoot%subcellsize), .false.) 
       call plot_AMR_values(grid, "temperature", "x-z", real(grid%octreeRoot%centre%y), &
            "lucy_temp_xz.ps/vcps", .true., .false., &
            0, dummy, dummy, dummy, real(grid%octreeRoot%subcellsize), .false.) 
       call plot_AMR_values(grid, "temperature", "x-z", real(grid%octreeRoot%centre%y), &
            "lucy_zoom_xz.ps/vcps", .true., .false., &
            0, dummy, dummy, dummy, real(grid%octreeRoot%subcellsize), .false.,boxfac=zoomFactor) 
       call plot_AMR_values(grid, "etaCont", "x-z", real(grid%octreeRoot%centre%y), &
            "etacont_zoom_xz.ps/vcps", .true., .false., &
            0, dummy, dummy, dummy, real(grid%octreeRoot%subcellsize), .false.,boxfac=zoomFactor) 
       call plot_AMR_values(grid, "tau", "x-z", real(grid%octreeRoot%centre%y), &
            "tau.ps/vcps", .true., .false., &
            0, dummy, dummy, dummy, real(grid%octreeRoot%subcellsize), .false.,ilam=ilam) 
       call plot_AMR_values(grid, "tau", "x-z", real(grid%octreeRoot%centre%y), &
            "tau_zoom_xz.ps/vcps", .true., .false., &
            0, dummy, dummy, dummy, real(grid%octreeRoot%subcellsize), .false.,boxfac=zoomFactor,ilam=ilam) 
!       call plot_AMR_values(grid, "temperature", "x-z", real(grid%octreeRoot%centre%y), &
!            tfilename1, .true., .false., &
!            0, dummy, dummy, dummy, real(grid%octreeRoot%subcellsize), .false.,boxfac=zoomFactor) 
!       call plot_AMR_values(grid, "temperature", "x-z", real(grid%octreeRoot%centre%y), &
!            tfilename2, .true., .false., &
!            0, dummy, dummy, dummy, real(grid%octreeRoot%subcellsize), .false.,boxfac=zoomFactor)
       call plot_AMR_values(grid, "temperature", "x-y", real(grid%octreeRoot%centre%z), &
            "lucy_temp_xy.ps/vcps", .true., .false., &
            0, dummy, dummy, dummy, real(grid%octreeRoot%subcellsize), .false.) 
       call plot_AMR_values(grid, "temperature", "y-z", real(grid%octreeRoot%centre%x), &
            "lucy_temp_yz.ps/vcps", .true., .false., &
            0, dummy, dummy, dummy, real(grid%octreeRoot%subcellsize), .false.) 
       call polardump(grid)
!$MPI    end if

    endif


!$MPI       if (my_rank == 1) &
       call tune(6, "One Lucy Rad Eq Itr")  ! start a stopwatch
       
       call zeroDistanceGrid(grid%octreeRoot)
!$MPI       if (my_rank == 0) then
       write(message,*) "Iteration",iIter_grand,",",nmonte," photons"
       call writeInfo(message, TRIVIAL)
!$MPI       end if




!$OMP PARALLEL DEFAULT(NONE) &
!$OMP PRIVATE(iMonte, iSource, thisSource, rVec, uHat, rHat) &
!$OMP PRIVATE(escaped, wavelength, thisFreq, thisLam, iLam, octVec) &
!$OMP PRIVATE(thisOctal, albedo, r) &
!$OMP PRIVATE(vec_tmp, uNew, Treal, subcell, probDistJnu) &
!$OMP PRIVATE(kabs,i, j, T1) &
!$OMP PRIVATE(nAbs_sub, nScat_sub, nInf_sub, nDiffusion_sub, thisPhotonAbs) &
!$OMP PRIVATE(twoD, photonInDiffusionZone, leftHandBoundary, directPhoton) &
!$OMP PRIVATE(diffusionZoneTemp, kappaAbsdb, sOctal, kappaScadb, kAbsArray) &
!$OMP PRIVATE(oldUHat) &
!$OMP SHARED(grid, nLambda, lamArray,miePhase, nMuMie, nDustType) &
!$OMP SHARED(imonte_beg, imonte_end, source, nsource) &
!$OMP SHARED(dnu, nFreq, freq, nMonte) &
!$OMP SHARED(nAbs, nScat, nInf, nDiffusion, nKilled, avedirection) 

       call resetDirectGrid(grid%octreeRoot)
 
       nInf_sub = 0
       nScat_sub = 0
       nAbs_sub = 0
       nDiffusion_sub = 0
       nInf = 0
       nScat = 0
       nAbs = 0
       nDiffusion = 0
       nKilled = 0

       imonte_beg=1; imonte_end=nMonte  ! default value

!!$MPI       ! Set the range of index for a photon loop used later.     
!!$MPI       n_rmdr = MOD(nMonte,np)
!!$MPI       m = nMonte/np
!!$MPI
!!$MPI       if (my_rank .lt. n_rmdr ) then
!!$MPI          imonte_beg = (m+1)*my_rank + 1
!!$MPI          imonte_end = imonte_beg + m
!!$MPI       else
!!$MPI          imonte_beg = m*my_rank + 1 + n_rmdr
!!$MPI          imonte_end = imonte_beg + m -1
!!$MPI       end if
!!$MPI   !    print *, ' '
!!$MPI   !    print *, 'imonte_beg = ', imonte_beg
!!$MPI   !    print *, 'imonte_end = ', imonte_end
!!$MPI  
!!$MPI      
!!$MPI       !  Just for safety.
!!$MPI       if (imonte_end .gt. nMonte .or. imonte_beg < 1) then
!!$MPI          print *, 'Index out of range: i_beg and i_end must be ' 
!!$MPI          print *, ' 0< index < ', nMonte , '    ... [lucy_mod::lucyRadiativeEquilibriumAMR]'
!!$MPI          print *, 'imonte_beg = ', imonte_beg
!!$MPI          print *, 'imonte_end = ', imonte_end
!!$MPI          stop
!!$MPI       end if




!$MPI  !====================================================================================
!$MPI  ! Splitting the innerPhoton loop for multiple processors.
!$MPI  if (my_rank == 0) then
!$MPI     print *, ' '
!$MPI     print *, 'photonLoop computed by ', n_proc-1, ' processors.'
!$MPI     print *, ' '
!$MPI  endif
!$MPI  if (my_rank == 0) then
!$MPI     ! we will use an array to store the rank of the process
!$MPI     !   which will calculate each photon
!$MPI     allocate(photonBelongsRank(nMonte))
!$MPI    
!$MPI     call mpiBlockHandout(n_proc,photonBelongsRank,blockDivFactor=100,tag=tag,&
!$MPI                          setDebug=.false.)
!$MPI     deallocate(photonBelongsRank) ! we don't really need this here. 
!$MPI  end if
!$MPI  !====================================================================================

!$MPI    
!$MPI    
!$MPI  if (my_rank /= 0) then
!$MPI    mpiBlockLoop: do  
!$MPI      call mpiGetBlock(my_rank,imonte_beg, imonte_end,rankComplete,tag,setDebug=.false.)  
!$MPI      if (rankComplete) exit mpiBlockLoop  
!$MPI    

       avedirection = OCTALVECTOR(0.d0, 0.d0, 0.d0)


!$OMP DO SCHEDULE(runtime)
       photonloop: do iMonte = imonte_beg, imonte_end


!$MPI !  if (MOD(i,n_proc) /= my_rank) cycle photonLoop

!$MPI !  if (MOD(i,n_proc) /= my_rank) goto 999

          thisPhotonAbs = 0

          call randomSource(source, nSource, iSource)
          thisSource = source(iSource)
          call getPhotonPositionDirection(thisSource, rVec, uHat,rHat)
          directPhoton = .true.


          call amrGridValues(grid%octreeRoot, rVec, foundOctal=tempOctal, &
            foundSubcell=tempsubcell)

          if (tempOctal%diffusionApprox(tempsubcell)) then
             call randomWalk(grid, tempOctal, tempSubcell, thisOctal, Subcell, temp)
             directPhoton = .false.
             rVec = subcellCentre(thisOctal, subcell)
          endif

          avedirection = avedirection + uHat
          escaped = .false.
          call getWavelength(thisSource%spectrum, wavelength)
          thisFreq = cSpeed/(wavelength / 1.e8)


          do while(.not.escaped)

             call toNextEventAMR(grid, rVec, uHat, escaped, thisFreq, nLambda, lamArray, twoD,imonte, &
                  photonInDiffusionZone, diffusionZoneTemp, leftHandBoundary, directPhoton)


             If (escaped) nInf_sub = nInf_sub + 1

             if (photonInDiffusionZone) then
                nDiffusion_sub = nDiffusion_sub + 1
             endif
                


             if (.not. escaped) then

                thisLam = (cSpeed / thisFreq) * 1.e8
                call locate(lamArray, nLambda, real(thisLam), iLam)
                octVec = rVec 
                call amrGridValues(grid%octreeRoot, octVec, foundOctal=thisOctal, foundsubcell=subcell,iLambda=iLam, &
                     kappaSca=kappaScadb, kappaAbs=kappaAbsdb, grid=grid)
                sOctal => thisOctal

                if (thisOctal%diffusionApprox(subcell)) then
                   write(*,*) "photon in diffusion zone",photonindiffusionzone
                endif

                if (kappaScadb+kappaAbsdb /= 0.0d0) then
                   albedo = kappaScadb / (kappaScadb + kappaAbsdb)
                else
                   albedo = 0.5
                end if

                directPhoton = .false.
                
                ! photon is always absorbed/reprocessed if it has come from diffusion zone


                if (PhotonInDiffusionZone) albedo = 0. 

	        albedo = min(albedo,0.9999d0)

                call random_number(r)

                ! scattering case
                if (r < albedo) then 


                   vec_tmp = uhat
                   uNew = newDirectionMie(vec_tmp, real(thisLam), lamArray, nLambda, miePhase, nDustType, nMuMie, &
                        thisOctal%dustTypeFraction(subcell, 1:nDusttype))
                   nScat_sub = nScat_sub + 1
                   uHat = uNew

                else

                   call amrGridValues(grid%octreeRoot, octVec, startOctal=sOctal, foundOctal=thisOctal, &
                        foundSubcell=subcell, temperature=treal,grid=grid, kappaAbsArray=kAbsArray)
                   t1 = dble(treal)

                   ! if the photon has come from the diffusion zone then it has to be
                   ! reprocessed using the appropriate temperature

                  if (photonInDiffusionZone) then
                      t1 = dble(diffusionZoneTemp)
                  endif

                   nAbs_sub = nAbs_sub + 1
                   thisPhotonAbs = thisPhotonAbs + 1
                   if (thisPhotonAbs > 50000) then
                      nKilled = nKilled + 1
                      cycle photonLoop
                   endif

                   probDistJnu(1) = 0.d0
                   do i = 2, nFreq
                      thisLam = (cSpeed / freq(i)) * 1.e8
                      call hunt(lamArray, nLambda, real(thisLam), iLam)
                      if ((ilam >=1).and.(ilam <= nlambda)) then

                         ! tjh added on 7/4/05 - stop direct addressing of octal kappa arrays
                         ! to allow implemntation of gas opacities...

!                         call amrGridValues(grid%octreeRoot, octVec, startOctal=thisOctal, &
!                              actualSubcell=subcell, kappaAbs=kabs, ilambda=ilam, grid=grid)

!                         if (.not.grid%oneKappa) then
!                            kabs = thisOctal%kappaAbs(subcell,ilam)
!                         else
!                            kabs = grid%oneKappaAbs(thisOctal%dustType(subcell),iLam) * thisOctal%rho(subcell)
!                         endif
                         probDistJnu(i) = probDistJnu(i-1) + &
                              bnu(freq(i),t1) * dble(kabsArray(ilam)) * dnu(i)
                         probDistJnu(i) = max(probDistJnu(i),1.d-50)
                      endif
                   enddo
                   if (probDistJnu(nFreq) /= 0.d0) then
                      do i = 1, nFreq
                         probDistJnu(i) = probDistJnu(i) / probDistJnu(nFreq)
                      enddo
                      call random_number(r)
                      call locate(probDistJnu, nFreq, r, j)
                      if (j == nFreq) j = nFreq -1
                      thisFreq = freq(j) + (freq(j+1) - freq(j))* &
                           (r - probDistJnu(j))/(probDistJnu(j+1)-probDistJnu(j))
!                      write(*,*) cSpeed/thisFreq/angstromtocm
                   endif


                   oldUhat = uHat
                   uHat = randomUnitVector()

                   ! make sure diffused photon is moving out of diffusion zone

                   if (photonInDiffusionZone) then
                      if ((oldUhat.dot.uHat)  > 0.) then
                         uHat = (-1.d0) * uHat
                      endif
                   endif

                endif

             endif
          enddo

       enddo photonLoop

!$MPI if (.not.blockHandout) exit mpiblockloop        
!$MPI    end do mpiBlockLoop  
!$MPI  end if ! (my_rank /= 0)


!$OMP END DO
!$OMP CRITICAL (update)
      nScat = nScat_sub  + nScat   ! sum from each thread for OpenMP
      nInf = nInf_sub    + nInf    ! sum from each thread for OpenMP
      nAbs = nAbs_sub    + nAbs    ! sum from each thread for OpenMP
      nDiffusion = nDiffusion_sub   + nDiffusion    ! sum from each thread for OpenMP
!$OMP END CRITICAL (update)

!$OMP BARRIER
!$OMP END PARALLEL




!$MPI       ! Summing the value in octal computed by each processors.
!$MPI       ! This is a recursive function which involves the many 
!$MPI       ! comunications between processors. It may take a while....
!$MPI       ! (Maybe faster to pack the values in 1D arrays and distribute.)
!$MPI
!$MPI       if(my_rank == 1) call tune(6, "  Lucy Loop Update ")  ! start a stopwatch
!$MPI       if(my_rank == 0) write(*,*) "Calling update_octal_MPI"
!$MPI    !   call update_octal_MPI(grid%octreeRoot, grid)

!$MPI       call MPI_BARRIER(MPI_COMM_WORLD, ierr)


!$MPI       call updateGridMPI(grid)
!$MPI       if(my_rank == 0) write(*,*) "Done update."

!$MPI       if(my_rank == 1) call tune(6, "  Lucy Loop Update ")  ! stop a stopwatch
!$MPI
!$MPI       ! collect some statical info from each node.
!$MPI       call MPI_ALLGATHER(REAL(nInf), 1, MPI_REAL, buffer_real, 1, MPI_REAL, MPI_COMM_WORLD, ierr)
!$MPI       call MPI_BARRIER(MPI_COMM_WORLD, ierr)
!$MPI       nInf = INT(SUM(buffer_real))
!$MPI
!$MPI       call MPI_ALLGATHER(REAL(nScat), 1, MPI_REAL, buffer_real, 1, MPI_REAL, MPI_COMM_WORLD, ierr)
!$MPI       call MPI_BARRIER(MPI_COMM_WORLD, ierr)
!$MPI       nScat = INT(SUM(buffer_real))
!$MPI
!$MPI       call MPI_ALLGATHER(REAL(nAbs), 1, MPI_REAL, buffer_real, 1, MPI_REAL, MPI_COMM_WORLD, ierr)
!$MPI       call MPI_BARRIER(MPI_COMM_WORLD, ierr)
!$MPI       nAbs = INT(SUM(buffer_real))
!$MPI
!$MPI       call MPI_ALLGATHER(REAL(nKilled), 1, MPI_REAL, buffer_real, 1, MPI_REAL, MPI_COMM_WORLD, ierr)
!$MPI       call MPI_BARRIER(MPI_COMM_WORLD, ierr)
!$MPI       nKilled = INT(SUM(buffer_real))
!$MPI
!$MPI       call MPI_ALLGATHER(REAL(nDiffusion), 1, MPI_REAL, buffer_real, 1, MPI_REAL, MPI_COMM_WORLD, ierr)
!$MPI       call MPI_BARRIER(MPI_COMM_WORLD, ierr)
!$MPI       nDiffusion = INT(SUM(buffer_real))
!$MPI
!$MPI       
!$MPI       if(my_rank == 0) then
          write(message,'(a,f7.2)') "Photons done.",real(ninf)/real(nmonte)
          call writeInfo(message,TRIVIAL)
          write(message,'(a,f13.3)') "Mean number of scatters per photon: ",real(nScat)/real(nMonte)
          call writeInfo(message,IMPORTANT)
          write(message,'(a,f13.3)') "Mean number of absorbs  per photon: ",real(nAbs)/real(nMonte)
          call writeInfo(message,IMPORTANT)
          write(message,'(a,f13.3)') "Fraction of photons killed: ",real(nKilled)/real(nMonte)
          call writeInfo(message,IMPORTANT)
!$MPI       end if




       epsOverDeltaT = (lCore) / dble(nInf)

       meanDeltaT = 0.
       nDT = 0
       nUndersampled = 0


       totalEmission = 0.

! If we are doing the computation in 2D then we need to remap the distancegrid before
! calculating the temperature corrections

       if (twoD) then
          write(*,*) "! Remapping the distance grid attributes..."
          call remapDistanceGrid(grid%octreeRoot, grid)
          call resetDistanceGrid(grid%octreeRoot)
          write(*,*) "done."
       endif


       call calculateTemperatureCorrections(.true., grid%octreeRoot, totalEmission, epsOverDeltaT, &
       nFreq, freq, dnu, lamarray, nLambda, grid, nDt, nUndersampled,  &
       dT_sum, dT_min, dT_max, dT_over_T_max)

!$MPI       if (my_rank==0) &
       call plot_AMR_values(grid, "crossings", "x-z", real(grid%octreeRoot%centre%y), &
            "crossings.ps/vcps", .true., .false., &
            0, dummy, dummy, dummy, real(grid%octreeRoot%subcellsize), .false., boxfac=zoomfactor) 

       call plot_AMR_values(grid, "direct", "x-z", real(grid%octreeRoot%centre%y), &
            "direct.ps/vcps", .false., .true., &
            0, dummy, dummy, dummy, real(grid%octreeRoot%subcellsize), .false., boxfac=zoomFactor)


       if (twoD) then
          write(*,*) "! Remapping the distance grid attributes..."
          call remapDistanceGrid(grid%octreeRoot, grid)
          call resetDistanceGrid(grid%octreeRoot)
          write(*,*) "done."
       endif


       percent_undersampled  = 100.*real(nUndersampled-nCellsInDiffusion)/real(nDt)
       dT_mean_old = dT_mean_new  ! save this for the next iteration
       dT_mean_new = dT_sum/real(nDt)


!$MPI       if (my_rank==0) then
       write(message,*) "Number of photons entering diffusion zone", ndiffusion
       call writeInfo(message, TRIVIAL)
       write(message,*) "Mean change in temperature    : ", dT_mean_new , " Kelvins"
       call writeInfo(message, TRIVIAL)
       write(message,*) "Minimum change in temperature : ", dT_min, " Kelvins"
       call writeInfo(message, TRIVIAL)
       write(message,*) "Maximum change in temperature : ", dT_max, " Kelvins"
       call writeInfo(message, TRIVIAL)
       write(message,*) "Maximum fractional change in temperature : ", dT_over_T_max
       call writeInfo(message, TRIVIAL)
       write(message,'(a,i8)') "Number of undersampled cells: ",nUndersampled-nCellsinDiffusion
       call writeInfo(message, TRIVIAL)
       write(message,'(a,f8.2)') "Percentage of undersampled cells: ",percent_undersampled
       call writeInfo(message, TRIVIAL)
       write(message,*) "Emissivity of dust / core", totalEmission /lCore * 1.e30
       call writeInfo(message, TRIVIAL)
       write(message,*) "Total emission",totalEmission
       call writeInfo(message, TRIVIAL)



       
       !
       ! writing the info above to a file.
10     format(a3, a12, 3(2x, a12),     4(2x, a12),     (2x, a12))
11     format(3x, i12, 3(2x, 1PE12.4), 4(2x, 1PE12.4), (2x, i12))
       if (first_time_to_open_file) then
          open(unit=LU_OUT, file='convergence_lucy.dat', status='replace')
          first_time_to_open_file=.false.
          write(LU_OUT, 10) "#", "iteration", "Mean dT [K]", "Min dT [K]", "Max dT [K]", &
               "% bad cells", "Eta dust/*", "Eta Total", "Max dT/T", "nMonte"
       else
          open(unit=LU_OUT, file='convergence_lucy.dat', status='old', position='append')
       end if

       write(LU_OUT, 11) iIter_grand, dT_sum/real(nDt), dT_min, dT_max, & 
            100.*real(nUndersampled-nCellsInDiffusion)/real(nDt), totalEmission /lCore *1.e30, &
            totalEmission, dT_over_T_max, nMonte
       
       close(LU_OUT)
!$MPI    end if   





!$MPI if (my_rank==1) &       
       call tune(6, "One Lucy Rad Eq Itr")  ! stop a stopwatch

       debugoutput = .true.
!$MPI if (my_rank==0)  then
!$MPI    debugOutput = .true.       
!$MPI  else
!$MPI    debugOutput = .false.
!$MPI endif

!       do i = 1, 1
!          call estimateTempofUndersampled(grid, grid%octreeRoot)
!          call updateTemps(grid, grid%octreeRoot)
!       enddo

!$MPI  if (my_rank == 1) &
       call tune(6, "Gauss-Seidel sweeps")
       call defineDiffusionOnRosseland(grid,grid%octreeRoot)
!$MPI       if (my_rank==0) &
       call plot_AMR_values(grid, "crossings", "x-z", real(grid%octreeRoot%centre%y), &
            "crossings.ps/vcps", .true., .false., &
            0, dummy, dummy, dummy, real(grid%octreeRoot%subcellsize), .false., boxfac=zoomfactor)

       nCellsInDiffusion = 0
       call defineDiffusionOnUndersampled(grid%octreeroot, nDiff=nCellsInDiffusion)

       call solveArbitraryDiffusionZones(grid)


       call defineDiffusionOnRosseland(grid,grid%octreeRoot, nDiff=nCellsInDiffusion)
!       call unsetOnDirect(grid%octreeRoot)
       write(message,*) "Number of cells in diffusion zone: ", nCellsInDiffusion
       call writeInfo(message,IMPORTANT)

!$MPI  if (my_rank == 1) &
       call tune(6, "Gauss-Seidel sweeps")


!       call writeInfo("Starting adaptive smooth...",TRIVIAL)
!       do
!          smoothConverged = .true.
!          call directPhotonSmooth(grid%octreeRoot, grid, smoothConverged, inheritProps = .true., interpProps = .false.)
!          if (smoothConverged) exit
!       end do
!       call writeInfo("Finished.",TRIVIAL)
       nCellsinDiffusion = 0
       call recountDiffusionCells(grid%octreeRoot, nCellsInDiffusion)


       if (grid%geometry.eq."wr104") then
              totalMass = 0.
               call findTotalMass(grid%octreeRoot, totalMass)
	        scaleFac = massEnvelope / totalMass
                if (writeoutput) write(*,'(a,1pe12.5)') "Density scale factor: ",scaleFac
                call scaleDensityAMR(grid%octreeRoot, scaleFac)

          call sublimateDustWR104(grid%octreeRoot)
       endif



!$MPI if (my_rank==0) &
      call writeAMRgrid("lucy_grid_tmp.dat", .false., grid)
      call writeInfo("Grid written",TRIVIAL)

   enddo

!       if (.not.(variableDustSublimation.and.doingDustSublimation)) then
!          if (grid%octreeRoot%twoD) then
!             call defineDiffusionZone(grid, outputFlag, .false.)
!          endif
!       endif


!       call writeInfo("Getting temperatures in diffusion zone", TRIVIAL)
!       call throughoutMidplanediff(grid, epsOverDeltat, debugoutput)
!       call writeInfo("Done.", TRIVIAL)


!       if ((grid%geometry == "shakara").and.(nDustType > 1)) then
!          call fillDustShakara(grid, grid%octreeRoot)
!       endif

       if ((grid%geometry == "ppdisk").and.(nDustType > 1)) then
          call fillDustUniform(grid, grid%octreeRoot)
       endif

       if (variableDustSublimation) then
          totFrac = 0.
          nFrac = 0
          tauMax = 1.e30
          call sublimateDust(grid, grid%octreeRoot, totFrac, nFrac, tauMax)
          if ((nfrac /= 0).and.(writeoutput)) then
             write(*,*) "Average absolute change in sublimation fraction: ",totFrac/real(nfrac)
          endif
!          if ((iIter_grand>=1).and.(iIter_grand <=20)) then

             call locate(grid%lamArray, nLambda,lambdasmooth,ismoothlam)

             if (iiter_grand > 3) then

!                if (writeoutput) write(*,*) "Unrefining very optically thin octals..."
!                gridconverged = .false.
!                do while(.not.gridconverged)
!                   gridconverged = .true.
!                   call unrefineThinCells(grid%octreeRoot, grid, ismoothlam, gridconverged)
!                end do
!                if (writeoutput) then
!                   write(*,*) "done."
!                   call plot_AMR_values(grid, "rho", "x-z", real(grid%octreeRoot%centre%y), &
!                        "unrefine.ps/vcps", .true., .false., &
!                        0, dummy, dummy, dummy, real(grid%octreeRoot%subcellsize), .false.) 
!                endif

                call writeInfo("Smoothing adaptive grid structure for optical depth...", TRIVIAL)
                do j = iSmoothLam, iSmoothlam !nLambda, 5
                   do
                      gridConverged = .true.
                      call myTauSmooth(grid%octreeRoot, grid, j, gridConverged, inheritProps = .false., interpProps = .true.)
                      
                      if (gridConverged) exit
                   end do
                enddo
                call writeInfo("...grid smoothing complete", TRIVIAL)
                
                call writeInfo("Smoothing adaptive grid structure (again)...", TRIVIAL)
                do
                   gridConverged = .true.
                   call myScaleSmooth(smoothFactor, grid%octreeRoot, grid, &
                        gridConverged,  inheritProps = .false., interpProps = .true.)
                   if (gridConverged) exit
                end do
                call writeInfo("...grid smoothing complete", TRIVIAL)


          endif

          nCellsInDiffusion = 0
          call defineDiffusionOnRosseland(grid,grid%octreeRoot, ndiff=nCellsInDiffusion)
          write(message,*) "Number of cells in diffusion zone: ", nCellsInDiffusion
          call writeInfo(message,IMPORTANT)

       endif


!          if (grid%octreeRoot%twoD) then
!             call defineDiffusionZone(grid, outputFlag, .false.)
!          endif




!    nRemoved = 0
!    if (iIter_Grand > 3) then
!!$MPI if (my_rank==0) & 
!       write(*,*) "Removing dust with T > Tthresh: ",Tthresh
!       call removeDust(grid%octreeRoot, Tthresh, nRemoved)
!    endif
!
!!$MPI if (my_rank==0) & 
!    write(message,*) "Number of cells removed: ",nRemoved
!    call writeInfo(message, TRIVIAL)


    if (grid%geometry == "wr104") then

       totalMass = 0.
       call findTotalMass(grid%octreeRoot, totalMass)
       scaleFac = massEnvelope / totalMass
!$MPI if (my_rank==0) & 
       write(*,'(a,1pe12.5)') "Density scale factor: ",scaleFac
       call scaleDensityAMR(grid%octreeRoot, scaleFac)
    endif


    !
    ! check the convergence
    !
    if (percent_undersampled>percent_undersampled_min) then
       converged = .false.
       nMonte = nMonte*2  ! increases the number of iterations!
    elseif (nRemoved > 3   &
         .or. iIter_grand < maxIter &
         .or. (dT_mean_new-dT_mean_old)/((dT_mean_new+dT_mean_old)/2.0) > 0.05) then
       converged = .false.
    else 
       converged = .true.
    end if

    if (doingDustSublimation) then
       if (iIter_grand < 4) then
          converged = .false.
       endif
    endif
       


!    converged = .true.
!    write(*,*) "FORCING CONVERGENCE FOR TESTS!!!!"


!    !
!    ! Write grid structure to a tmp file.
!    !
!$MPI if (my_rank==0) then
      call writeAMRgrid("lucy_grid_tmp.dat", .false., grid)
!$MPI end if
       
   enddo


!$MPI deallocate(buffer_real)

  deallocate(kAbsArray)

  end subroutine lucyRadiativeEquilibriumAMR


  subroutine setupFreqProb(temperature, freq, dnu, nFreq, probDist)

    ! Lucy 1999, A&A, 344, 282 Equation 3

    real(oct) :: temperature
    integer :: nFreq
    real(oct) :: freq(*)
    real(oct) :: probDist(*)
    real(oct) :: dnu(*)

    integer :: i


    
    probDist(1:nFreq) = 0.
    do i = 2, nFreq
       probDist(i) = probDist(i-1) + bnu(dble(freq(i)),dble(temperature)) * dnu(i)

    enddo

    probDist(1:nFreq) = probDist(1:nFreq) / probDist(nFreq)

  end subroutine setupFreqProb


 subroutine toNextEvent(grid, rVec, uHat,  escaped, distanceGrid, thisFreq, nLambda, lamArray)


   type(GRIDTYPE) :: grid
   type(OCTALVECTOR) :: rVec, uHat
   integer :: i1, i2, i3
   real(oct) :: t1, t2, t3
   real(oct) :: tval, tau, r
   real :: lamArray(*)
   integer :: nLambda
   logical :: stillinGrid
   logical :: escaped
   real(oct) :: thisTau
   real(oct) :: kabs, ksca
   real(oct) :: thisFreq
   real(oct) :: distanceGrid(1:grid%nx, 1:grid%ny, 1:grid%nz)
   real(oct) :: thisLam
   integer :: iLam

    stillinGrid = .true.
    escaped = .false.


    thisLam = (cSpeed / thisFreq) * 1.e8
    call hunt(lamArray, nLambda, real(thisLam), iLam)
    if ((ilam < 1).or.(ilam > nlambda)) then
       write(*,*) "ilam errro",ilam
    endif

    call random_number(r)
    tau = -log(r)
    call getIndices(grid, rVec, i1, i2, i3, t1, t2, t3)
    call intersectCube(grid, rVec, i1, i2, i3, uHat, tVal)

    if (.not.grid%oneKappa) then
       kabs = grid%kappaAbs(i1,i2,i3,iLam)
       ksca = grid%kappaSca(i1,i2,i3,iLam)
    else
       kabs = grid%oneKappaAbs(1,iLam) * grid%rho(i1,i2,i3)
       ksca = grid%oneKappaSca(1,iLam) * grid%rho(i1,i2,i3)
    endif

    thisTau = tVal * (kabs + ksca)

    do while(stillinGrid .and. (tau > thisTau)) 
       rVec = rVec + tVal * uHat


       if ((rVec%x > grid%xAxis(grid%nx)).or. &
           (rVec%y > grid%yAxis(grid%ny)).or. &
           (rVec%z > grid%zAxis(grid%nz)).or. &
           (rVec%x < grid%xAxis(1)).or. &
           (rVec%y < grid%yAxis(1)).or. &
           (rVec%z < grid%zAxis(1))) then
          stillinGrid = .false.
          escaped = .true.
          if (.not.grid%oneKappa) then
             kabs = grid%kappaAbs(i1,i2,i3,iLam)
          else
             kabs = grid%oneKappaAbs(1,iLam) * grid%rho(i1,i2,i3)
          endif
          distanceGrid(i1,i2,i3) = distanceGrid(i1,i2,i3) + tVal * kabs
       endif


       if (stillinGrid) then
          call random_number(r)
          tau = -log(r)
          call getIndices(grid, rVec, i1, i2, i3, t1, t2, t3)
          call intersectCube(grid, rVec, i1, i2, i3, uHat, tVal)
          if (.not.grid%oneKappa) then
             kabs = grid%kappaAbs(i1,i2,i3,iLam)
             ksca = grid%kappaSca(i1,i2,i3,iLam)
          else
             kabs = grid%oneKappaAbs(1,iLam) * grid%rho(i1,i2,i3)
             ksca = grid%oneKappaSca(1,iLam) * grid%rho(i1,i2,i3)
          endif
          thisTau = tVal * (kabs+ksca)
          if (tVal == 0.) then
             escaped = .true.
             stillingrid = .false.
          endif
       endif
    enddo

    if (.not.escaped) then
       call getIndices(grid, rVec, i1, i2, i3, t1, t2, t3)
       call intersectCube(grid, rVec, i1, i2, i3, uHat, tVal)

       if ((tVal*tau/thisTau) > 2.*(grid%xAxis(2)-grid%xAxis(1))) then
          write(*,*) "tval*tau/thistau too big", tval*tau/thisTau
       else
          if (.not.grid%oneKappa) then
             kabs = grid%kappaAbs(i1,i2,i3,iLam)
          else
             kabs = grid%oneKappaAbs(1,iLam) * grid%rho(i1,i2,i3)
          endif
          distanceGrid(i1,i2,i3) = distanceGrid(i1,i2,i3) + (tVal*tau/thisTau) * kabs
       endif
       

       if (tau > thisTau) then
          write(*,*) "tau > thistau"
          stop
       endif
       
       rVec = rVec + (tVal*tau/thisTau) * uHat
    endif




 end subroutine toNextEvent


  subroutine intersectCube(grid, posVec, i1,i2,i3,direction, tval)
   use vector_mod
   use grid_mod
   implicit none
   type(GRIDTYPE) :: grid
   type(OCTALVECTOR) :: direction
   type(OCTALVECTOR) :: posVec, norm(6), p3(6)
   real(oct) :: t(6),tval,denom(6)
   integer :: i,j
   logical :: ok, thisOk(6)
   integer :: i1, i2, i3

   ok = .true.

   norm(1) = VECTOR(1., 0., 0.)
   norm(2) = VECTOR(0., 1., 0.)
   norm(3) = VECTOR(0., 0., 1.)
   norm(4) = VECTOR(-1., 0., 0.)
   norm(5) = VECTOR(0., -1., 0.)
   norm(6) = VECTOR(0., 0., -1.)

   p3(1) = VECTOR(grid%xAxis(i1+1), 0., 0.)
   p3(2) = VECTOR(0.,grid%yAxis(i2+1),0.)
   p3(3) = VECTOR(0.,0.,grid%zAxis(i3+1))
   p3(4) = VECTOR(grid%xAxis(i1), 0., 0.)
   p3(5) = VECTOR(0.,grid%yAxis(i2),0.)
   p3(6) = VECTOR(0.,0.,grid%zAxis(i3))

   thisOk = .true.
   
   do i = 1, 6

      denom(i) = norm(i) .dot. direction
      if (denom(i) /= 0.) then
         t(i) = (norm(i) .dot. (p3(i)-posVec))/denom(i)
      else
         thisOk(i) = .false.
         t(i) = 0.
      endif
      if (t(i) < 0.) thisOk(i) = .false.
!      if (denom > 0.) thisOK(i) = .false.
 enddo




  
  j = 0
  do i = 1, 6
    if (thisOk(i)) j=j+1
  enddo

  if (j == 0) ok = .false.
   
  if (.not.ok) then
     write(*,*) i1, i2, i3
     write(*,*) direction%x,direction%y,direction%z
     write(*,*) t(1:6)
     stop
  endif

  tval = minval(t, mask=thisOk)
  tval = max(tval * 1.001d0,dble((grid%xAxis(2)-grid%xAxis(1))/1000.))


  if (tval == 0.) then
     write(*,*) i1, i2, i3,tval
     write(*,*) posVec
     write(*,*) grid%xAxis(i1),grid%yAxis(i2),grid%zAxis(i3)
     write(*,*) grid%xAxis(i1+1),grid%yAxis(i2+1),grid%zAxis(i3+1)
     write(*,*) direction%x,direction%y,direction%z
     write(*,*) t(1:6)
     stop
  endif

  if (tval > 2.*(grid%xAxis(2)-grid%xAxis(1))) then
!     write(*,*) "tval too big",tval,i1,i2,i3,posvec
!     write(*,*) "direction",direction
!     write(*,*) t(1:6)
!     write(*,*) denom(1:6)
  endif


  end subroutine intersectCube 


  recursive subroutine zeroDistanceGrid(thisOctal)
  type(octal), pointer   :: thisOctal
  type(octal), pointer  :: child 
  integer :: subcell, i
  
  do subcell = 1, thisOctal%maxChildren
       if (thisOctal%hasChild(subcell)) then
          ! find the child
          do i = 1, thisOctal%nChildren, 1
             if (thisOctal%indexChild(i) == subcell) then
                child => thisOctal%child(i)
                call zeroDistanceGrid(child)
                exit
             end if
          end do
       else
          thisOctal%distanceGrid(subcell) = 0.d0
          thisOctal%nCrossings(subcell) = 0
          thisOctal%undersampled(subcell) = .false.
          thisOCtal%nDiffusion(subcell) = 0.
       endif
    enddo
  end subroutine zeroDistanceGrid


  recursive subroutine calculateTemperatureCorrections(this_is_root, thisOctal, totalEmission, &
       epsOverDeltaT, nFreq, freq, dnu, lamarray, nLambda, grid, nDt, nUndersampled,  &
       dT_sum, dT_min, dT_max, dT_over_T_max)

    use input_variables, only : minCrossings
    logical, intent(in) :: this_is_root    ! T if thisOctal is a root node.
    real(oct) :: totalEmission
    type(octal), pointer   :: thisOctal
    type(octal), pointer  :: child 
    type(gridtype) :: grid
    integer :: subcell, i
    real(oct) :: V, epsOverDeltaT
    real(oct) :: adot
    real(oct) :: kappaP, norm
    real(oct) :: thisLam
    integer :: ilam, nLambda
    real(oct) :: newT, deltaT
    integer, intent(inout) :: nDt
    real(oct), intent(inout) :: dT_sum ! [Kelvins]  the sum of the temperature change
    real(oct), intent(inout) :: dT_min ! [kelvins]  the minimum change of temperature
    real(oct), intent(inout) :: dT_max ! [kelvins]  the maximum change of temperature
    ! [kelvins]  the maximum fractional change of temperature
    real(oct), intent(inout) :: dT_over_T_max 

    real :: kabs
    real(double) :: kabsArray(1000)
    real :: lamArray(*)
    integer :: nFreq
    real(oct) :: freq(*)
    real(oct) :: dnu(*)
    integer :: nUndersampled
    integer, save  :: nwarning = 0
    integer, parameter :: nmaxwarning = 20
    real(double) :: r1, r2
    type(OCTALVECTOR) :: rVec

    if(this_is_root) then !initialize some values
       dT_sum = 0.0
       dT_min = 1.0e10
       dT_max = 0.0
       nDT = 0
       dT_over_T_max = 0.0
    end if
    

    do subcell = 1, thisOctal%maxChildren
       if (thisOctal%hasChild(subcell)) then
          ! find the child
          do i = 1, thisOctal%nChildren, 1
             if (thisOctal%indexChild(i) == subcell) then
                child => thisOctal%child(i)
                call calculateTemperatureCorrections(.false., child, totalEmission, epsOverDeltaT, &
                     nFreq, freq, dnu, lamarray, nLambda, grid, nDt, nUndersampled, &
                     dT_sum, dT_min, dT_max, dT_over_T_max)
                exit
             end if
          end do
       else
          if (thisOctal%inFlow(subcell)) then
             v = cellVolume(thisOctal, subcell)
             adot = epsoverDeltaT * (thisOctal%distancegrid(subcell)/v) / 1.d30
             kappaP = 0.d0
             norm = 0.d0

             call amrGridValues(grid%octreeRoot, subcellCentre(thisOctal,subcell), startOctal=thisOctal, &
                  actualSubcell=subcell, kappaAbsArray=kabsArray, grid=grid)
             do i = 1, nFreq
                thisLam = (cSpeed / freq(i)) * 1.d8
                call hunt(lamArray, nLambda, real(thisLam), iLam)
                if ((iLam >=1) .and. (iLam <= nLambda)) then

                   ! tjh added on 7/4/05 - stop direct addressing of octal kappa arrays
                   ! to allow implemntation of gas opacities...
                   
!                   call amrGridValues(grid%octreeRoot, subcellCentre(thisOctal,subcell), startOctal=thisOctal, &
!                        actualSubcell=subcell, kappaAbs=kabs, ilambda=ilam, grid=grid)

!                   if (.not.grid%oneKappa) then
!                      kabs = thisOctal%kappaAbs(subcell,iLam)
!                   else
!                      kabs = grid%oneKappaAbs(thisOctal%dustType(subcell),iLam) * thisOctal%rho(subcell)
!                   endif
                   kappaP = kappaP + dble(kabsArray(ilam)) * &
                        dble(bnu(dble(freq(i)),dble(thisOctal%temperature(subcell))))  * dble(dnu(i))
                   norm = norm + dble(bnu(dble(freq(i)),dble(thisOctal%temperature(subcell))))  * dble(dnu(i))
                endif
             enddo
             if (norm /= 0.d0) then
                kappaP = kappaP / norm /1.d10
             else
                kappaP = 0.d0
             endif
             
             
             if (kappaP /= 0.d0) then
                newT = dble(pi / stefanBoltz) * aDot / (dble(fourPi) * kappaP)
                newT = newT**0.25d0
             else
                newT = thisOctal%temperature(subcell)
             endif
             deltaT = newT - thisOctal%temperature(subcell)
             if ((deltaT > 20000.).and.(thisOctal%nCrossings(subcell) .ge. minCrossings)) then
                if (nwarning < nmaxwarning) then
                   write(*,*) "Warning:: deltaT > 20000 kelvins calculateTemperatureCorrections.", &
                        deltaT, thisOctal%nCrossings(subcell), &
                        modulus(subcellcentre(thisOctal,subcell))/grid%rinner,thisOctal%rho(subcell), &
                        dble(1./grid%rinner)*subcellcentre(thisOctal,subcell) 
                   write(*,*) "kappap",kappap,"adot",adot
                   nwarning = nwarning + 1
                elseif (nwarning == nmaxwarning) then
                   write(*,*) " "
                   write(*,*) " ==> Suppressing the further delatT > 1000 Kelvins  wanrning .... "
                   write(*,*) " "
                   nwarning = nwarning + 1
                else
                   continue
                end if                   
                !                write(*,*) deltaT, thisOctal%temperature(subcell), newT
                !                write(*,*) adot,kappap,thisOctal%rho(subcell)
             endif
             thisOctal%oldTemperature(subcell) = thisOctal%temperature(subcell)
             if (thisOctal%nCrossings(subcell) .ge. minCrossings) then
                thisOctal%temperature(subcell) = max(2.8,thisOctal%temperature(subcell) + real(0.8 * deltaT))
             else
                deltaT = 0.
                nUnderSampled = nUndersampled + 1
                thisOctal%undersampled(subcell) = .true.
             endif
             kappaP = 0.d0
             norm = 0.d0
             if (.not.grid%oneKappa) then
                kabsArray(1:nlambda) = thisOctal%kappaAbs(subcell,1:nlambda)
             else
                call amrGridValues(grid%octreeRoot, subcellCentre(thisOctal,subcell), startOctal=thisOctal, &
                     actualSubcell=subcell, kappaAbsArray=kabsArray, grid=grid)
             endif

             do i = 1, nFreq
                thisLam = (cSpeed / freq(i)) * 1.e8
                call hunt(lamArray, nLambda, real(thisLam), iLam)
                if ((iLam >=1) .and. (iLam <= nLambda)) then
                   kappaP = kappaP + dble(kabsArray(ilam)) * &
                        dble(bnu(dble(freq(i)),dble(thisOctal%temperature(subcell)))) * dble(dnu(i)) 
                   norm = norm + dble(bnu(dble(freq(i)),dble(thisOctal%temperature(subcell)))) * dble(dnu(i)) 
                endif
             enddo
             if (norm /= 0.d0) then
                kappaP = kappaP / norm / 1.d10
             else
                kappaP = TINY(kappaP)
             endif
             thisOctal%etaCont(subcell) = fourPi * kappaP * (stefanBoltz/pi) * &
                  (thisOctal%temperature(subcell)**4)
             totalEmission = totalEmission + thisOctal%etaCont(subcell) * V
             nDT = nDT  + 1
             dT_sum = dT_sum + ABS(deltaT)
             dT_min = MIN(deltaT, dT_min)
             dT_max = MAX(deltaT, dT_max)
             if (newT>0.0) dT_over_T_max = MAX(ABS(deltaT)/newT, dT_over_T_max)
          else 
             thisOctal%etaCont(subcell) = 0.
          endif
       endif
    enddo
  end subroutine calculateTemperatureCorrections

  subroutine intersectCubeAMR(grid, posVec, direction, tval)
   implicit none
   type(GRIDTYPE), intent(in)    :: grid
   type(OCTALVECTOR), intent(in) :: posVec
   type(OCTALVECTOR), intent(in) :: direction
   real(oct), intent(out) :: tval
   !
   type(OCTALVECTOR) :: norm(6), p3(6)
   type(OCTAL),pointer :: thisOctal
   type(OCTALVECTOR) :: subcen, point
   integer :: subcell
   
   real(oct) :: t(6),denom(6)
   integer :: i,j
   logical :: ok, thisOk(6)


   point = posVec

   call amrGridValues(grid%octreeRoot, point, foundOctal=thisOctal, foundSubcell=subcell, grid=grid)
   subcen =  subcellCentre(thisOctal,subcell)
   ok = .true.

   norm(1) = OCTALVECTOR(1.0d0, 0.d0, 0.0d0)
   norm(2) = OCTALVECTOR(0.0d0, 1.0d0, 0.0d0)
   norm(3) = OCTALVECTOR(0.0d0, 0.0d0, 1.0d0)
   norm(4) = OCTALVECTOR(-1.0d0, 0.0d0, 0.0d0)
   norm(5) = OCTALVECTOR(0.0d0, -1.0d0, 0.0d0)
   norm(6) = OCTALVECTOR(0.0d0, 0.0d0, -1.0d0)

   p3(1) = OCTALVECTOR(subcen%x+thisOctal%subcellsize/2.0d0, subcen%y, subcen%z)
   p3(2) = OCTALVECTOR(subcen%x, subcen%y+thisOctal%subcellsize/2.0d0 ,subcen%z)
   p3(3) = OCTALVECTOR(subcen%x,subcen%y,subcen%z+thisOctal%subcellsize/2.0d0)
   p3(4) = OCTALVECTOR(subcen%x-thisOctal%subcellsize/2.0d0, subcen%y,  subcen%z)
   p3(5) = OCTALVECTOR(subcen%x,subcen%y-thisOctal%subcellsize/2.0d0, subcen%z)
   p3(6) = OCTALVECTOR(subcen%x,subcen%y,subcen%z-thisOctal%subcellsize/2.0d0)

   thisOk = .true.

   do i = 1, 6

      denom(i) = norm(i) .dot. direction
      if (denom(i) /= 0.0d0) then
         t(i) = (norm(i) .dot. (p3(i)-posVec))/denom(i)
      else
         thisOk(i) = .false.
         t(i) = 0.0d0
      endif
      if (t(i) < 0.) thisOk(i) = .false.
!      if (denom > 0.) thisOK(i) = .false.
 enddo

  
  j = 0
  do i = 1, 6
    if (thisOk(i)) j=j+1
  enddo

  if (j == 0) ok = .false.
   
  if (.not.ok) then
     write(*,*) "Error: j=0 (no intersection???) in lucy_mod::intersectCubeAMR. "
     write(*,*) direction%x,direction%y,direction%z
     write(*,*) t(1:6)
     stop
  endif

  tval = minval(t, mask=thisOk)
  tval = max(tval * 1.001d0,dble(thisOctal%subCellSize/1000.))


  if (tval == 0.) then
     write(*,*) posVec
     write(*,*) direction%x,direction%y,direction%z
     write(*,*) t(1:6)
     stop
  endif

  if (tval > sqrt(3.)*thisOctal%subcellsize) then
!     write(*,*) "tval too big",tval/(sqrt(3.)*thisOctal%subcellSize)
!     write(*,*) "direction",direction
!     write(*,*) t(1:6)
!     write(*,*) denom(1:6)
  endif


  end subroutine intersectCubeAMR

  subroutine intersectCubeAMR2D(grid, posVec, direction, tval, sOctal)

! this is to find a cell intersection for a 2D AMR grid
! which is essentially a 2D-grid that projects into
! a 3D cylindrical coordinate system


   implicit none
   type(GRIDTYPE), intent(in)    :: grid
   type(OCTAL), pointer :: sOctal
   type(OCTALVECTOR), intent(in) :: posVec
   type(OCTALVECTOR), intent(inout) :: direction
   real(oct), intent(out) :: tval
   !
   type(OCTALVECTOR) :: norm(6), p3(6)
   type(OCTAL),pointer :: thisOctal
   type(OCTALVECTOR) :: subcen, point
   real :: dx, dz ! directions in cylindrical coords
   integer :: subcell
   real(double) :: compX, compZ,currentX,currentZ
   real(double) :: distToZBoundary, distToXboundary
   real(oct) :: r1,r2,d,cosmu,x1,x2,distTor1,distTor2, theta, mu
   integer :: i,j
   logical :: ok, thisOk(6)
   type(OCTALVECTOR) :: xHat, zHAt

   point = posVec

   call amrGridValues(grid%octreeRoot, point, startOctal=sOctal,foundOctal=thisOctal, foundSubcell=subcell, grid=grid)
   subcen =  subcellCentre(thisOctal,subcell)
   ok = .true.


   r1 = subcen%x - thisOctal%subcellSize/2.d0
   r2 = subcen%x + thisOctal%subcellSize/2.d0
   d = sqrt(point%x**2+point%y**2)
   xHat = VECTOR(point%x, point%y,0.d0)
   call normalize(xHat)

   cosmu =((-1.d0)*xHat).dot.direction
   call solveQuadDble(1.d0, -2.d0*d*cosmu, d**2-r2**2, x1, x2, ok)
   if (.not.ok) then
      write(*,*) "Quad solver failed in intersectcubeamr2d"
      direction = randomUnitVector()
      x1 = thisoctal%subcellSize/2.d0
      x2 = 0.d0
   endif
   distTor2 = max(x1,x2)

   theta = asin(max(-1.d0,min(1.d0,r1 / d)))
   cosmu = xHat.dot.direction
   mu = acos(max(-1.d0,min(1.d0,cosmu)))
   distTor1 = 1.e30
   if (mu  < theta ) then
      call solveQuadDble(1.d0, -2.d0*d*cosmu, d**2-r1**2, x1, x2, ok)
      if (.not.ok) then
         write(*,*) "Quad solver failed in intersectcubeamr2d"
         direction = randomUnitVector()
         x1 = thisoctal%subcellSize/2.d0
         x2 = 0.d0
      endif
      distTor1 = max(x1,x2)
   endif
         
   distToXboundary = min(distTor1, distTor2)


   zHat = VECTOR(0.d0, 0.d0, 1.d0)
   compZ = zHat.dot.direction
   currentZ = point%z

   if (compZ /= 0.d0 ) then
      if (compZ > 0.d0) then
         distToZboundary = (subcen%z + thisOctal%subcellsize/2.d0 - currentZ ) / compZ
      else
         distToZboundary = abs((subcen%z - thisOctal%subcellsize/2.d0 - currentZ ) / compZ)
      endif
   else
      disttoZboundary = 1.e30
   endif

   tVal = min(distToZboundary, distToXboundary) +0.0001d0*grid%halfsmallestsubcell
   if (tVal > 1.e29) then
      write(*,*) tVal,compX,compZ, distToZboundary,disttoxboundary
      write(*,*) "subcen",subcen
      write(*,*) "x,z",currentX,currentZ
   endif
   if (tval < 0.) then
      write(*,*) tVal,compX,compZ, distToZboundary,disttoxboundary
      write(*,*) "subcen",subcen
      write(*,*) "x,z",currentX,currentZ
   endif

  end subroutine intersectCubeAMR2D

  subroutine intersectCubeCylindrical(grid, posVec, direction, tval, sOctal)

! this is to find a cell intersection for a 3D AMR grid
! which is a cylindrical amr mesh


   implicit none
   type(GRIDTYPE), intent(in)    :: grid
   type(OCTAL), pointer :: sOctal
   type(OCTALVECTOR), intent(in) :: posVec
   type(OCTALVECTOR), intent(inout) :: direction
   real(oct), intent(out) :: tval
   !
   type(OCTALVECTOR) :: norm(6), p3(6)
   type(OCTAL),pointer :: thisOctal
   type(OCTALVECTOR) :: subcen, point
   real :: dx, dz ! directions in cylindrical coords
   integer :: subcell
   real(double) :: compX, compZ,currentX,currentZ
   real(double) :: distToZBoundary, distToXboundary
   real(oct) :: r1,r2,d,cosmu,x1,x2,distTor1,distTor2, theta, mu
   integer :: i,j
   logical :: ok, thisOk(6)
   type(OCTALVECTOR) :: xHat, zHAt

   point = posVec

   call amrGridValues(grid%octreeRoot, point, startOctal=sOctal,foundOctal=thisOctal, foundSubcell=subcell, grid=grid)
   subcen =  subcellCentre(thisOctal,subcell)
   ok = .true.


   r1 = subcen%x - thisOctal%subcellSize/2.d0
   r2 = subcen%x + thisOctal%subcellSize/2.d0
   d = sqrt(point%x**2+point%y**2)
   xHat = VECTOR(point%x, point%y,0.d0)
   call normalize(xHat)

   cosmu =((-1.d0)*xHat).dot.direction
   call solveQuadDble(1.d0, -2.d0*d*cosmu, d**2-r2**2, x1, x2, ok)
   if (.not.ok) then
      write(*,*) "Quad solver failed in intersectcubeamr2d"
      direction = randomUnitVector()
      x1 = thisoctal%subcellSize/2.d0
      x2 = 0.d0
   endif
   distTor2 = max(x1,x2)

   theta = asin(max(-1.d0,min(1.d0,r1 / d)))
   cosmu = xHat.dot.direction
   mu = acos(max(-1.d0,min(1.d0,cosmu)))
   distTor1 = 1.e30
   if (mu  < theta ) then
      call solveQuadDble(1.d0, -2.d0*d*cosmu, d**2-r1**2, x1, x2, ok)
      if (.not.ok) then
         write(*,*) "Quad solver failed in intersectcubeamr2d"
         direction = randomUnitVector()
         x1 = thisoctal%subcellSize/2.d0
         x2 = 0.d0
      endif
      distTor1 = max(x1,x2)
   endif
         
   distToXboundary = min(distTor1, distTor2)


   zHat = VECTOR(0.d0, 0.d0, 1.d0)
   compZ = zHat.dot.direction
   currentZ = point%z

   if (compZ /= 0.d0 ) then
      if (compZ > 0.d0) then
         distToZboundary = (subcen%z + thisOctal%subcellsize/2.d0 - currentZ ) / compZ
      else
         distToZboundary = abs((subcen%z - thisOctal%subcellsize/2.d0 - currentZ ) / compZ)
      endif
   else
      disttoZboundary = 1.e30
   endif

   tVal = min(distToZboundary, distToXboundary) +0.0001d0*grid%halfsmallestsubcell
   if (tVal > 1.e29) then
      write(*,*) tVal,compX,compZ, distToZboundary,disttoxboundary
      write(*,*) "subcen",subcen
      write(*,*) "x,z",currentX,currentZ
   endif
   if (tval < 0.) then
      write(*,*) tVal,compX,compZ, distToZboundary,disttoxboundary
      write(*,*) "subcen",subcen
      write(*,*) "x,z",currentX,currentZ
   endif

 end subroutine intersectCubeCylindrical



 subroutine toNextEventAMR(grid, rVec, uHat,  escaped,  thisFreq, nLambda, lamArray, twoD, imonte, &
      photonInDiffusionZone, diffusionZoneTemp, leftHandBoundary, directPhoton)


   type(GRIDTYPE) :: grid
   type(OCTALVECTOR) :: rVec,uHat, octVec,thisOctVec, tvec, tHat
   type(OCTAL), pointer :: thisOctal, tempOctal, sourceOctal
   type(OCTAL),pointer :: oldOctal, sOctal
   type(OCTAL),pointer :: foundOctal, endOctal
   integer :: endSubcell
   integer :: subcell, isubcell, tempSubcell, sourceSubcell
   logical :: directPhoton
   real(oct) :: tval, tau, r, tval2
   real :: lamArray(*)
   integer :: nLambda
   logical :: stillinGrid
   logical :: escaped
   logical :: twoD
   real(double) :: kappaScaDb, kappaAbsDb
   real(oct) :: thisTau
   real(oct) :: thisFreq
   real(oct) :: thisLam
   integer :: iLam
   logical ::inFlow
   integer :: imonte
   real :: diffusionZoneTemp
   logical :: photonInDiffusionZone
   logical :: leftHandBoundary
   real(double) :: prob
   integer :: i
   real(double), parameter :: fudgeFac = 1.d-2

    stillinGrid = .true.
    escaped = .false.
    photonInDiffusionZone = .false.
       


    thisLam = (cSpeed / thisFreq) * 1.e8
    call hunt(lamArray, nLambda, real(thisLam), iLam)
    if ((ilam < 1).or.(ilam > nlambda)) then
       write(*,*) "ilam error in tonexteventamr",ilam,thislam
    endif

! select an initial random tau and find distance to next cell

    call random_number(r)
    tau = -log(r)


    octVec = rVec
    thisOctVec = rVec

    call amrGridValues(grid%octreeRoot, octVec, iLambda=iLam,  foundOctal=thisOctal, &
         foundSubcell=subcell, kappaSca=kappaScadb, kappaAbs=kappaAbsdb, &
         grid=grid, inFlow=inFlow)
    oldOctal => thisOctal
    sOctal => thisOctal

! moved from before call to amrgridvalues - th 16/11/05

    call distanceToCellBoundary(grid, rVec, uHat, tVal, sOctal)
    tval = tval + fudgeFac * grid%halfSmallestSubcell
!    if (grid%octreeRoot%threed) then
!       call intersectCubeAMR(grid, rVec, uHat, tVal)
!    else
!       call intersectCubeAMR2D(grid, rVec, uHat, tVal, sOctal)
!    endif


    if (inFlow) then
       thisTau = dble(tVal) * (kappaAbsdb + kappaScadb)
    else
       thisTau = 1.0e-28
    end if

! if tau > thisTau then the photon has traversed a cell with no interactions

    do while(stillinGrid .and. (tau > thisTau)) 

! add on the distance to the next cell

       rVec = rVec + tVal * uHat

       octVec = rVec

! It is here that the photon path has potentially entered a cell
! in the diffusion approximation zone. In this case we have to return
! a position _before_ the photon enters the cell, and we need to
! tell the main photon loop that the photon has been absorbed
! and needs to re-emitted with a temperature corresponding to
! the top layer of the diffusion zone (this will conserve
! energy, and will create the appropriate boundary condition
! at the surface of the diffusion zone.
!       write(*,*) "octvec",octvec
!       write(*,*) sOctal%centre,sOctal%subcellSize
!       call amrGridValues(grid%octreeRoot, octVec,  startOctal=sOctal, foundOctal=tempOctal, &
!            foundSubcell=tempsubcell)

       call amrGridValues(grid%octreeRoot, octVec,  foundOctal=tempOctal, &
            foundSubcell=tempsubcell)
       sOctal => tempOctal
       if (tempOctal%diffusionApprox(tempsubcell)) then

          call randomWalk(grid, tempOctal, tempSubcell,  endOctal, endSubcell, diffusionZoneTemp)
          photonInDiffusionZone = .true.
          directPhoton = .false.
          rVec = subcellCentre(endOctal,endSubcell)
          octVec = rVec
          call amrGridValues(grid%octreeRoot, rVec,  startOctal=sOctal, foundOctal=tempOctal, &
            foundSubcell=tempsubcell)
          sOctal => tempOctal
          if (tempOctal%diffusionApprox(tempsubcell)) then
             write(*,*) "moved to cell with diffapprox",tempOctal%diffusionApprox(tempsubcell)
             write(*,*) "endOctal",endOctal%diffusionApprox(endSubcell)
             write(*,*) "temp octal",subcellCentre(tempOctal, tempSubcell),tempSubcell, tempOctal%rho(tempSubcell)
             write(*,*) "end octal",subcellCentre(endOctal, endSubcell), endSubcell,endOctal%rho(endSubcell)
             write(*,*) tempOctal%chiLine(tempSubcell),endOctal%chiLine(endSubcell)
             write(*,*) tempOctal%chiLine(1:tempOctal%maxChildren)
             write(*,*) tempOctal%splitAzimuthally, endOctal%splitAzimuthally
             write(*,*) tempOctal%haschild(tempSubcell), endOctal%hasChild(endSubcell)
             write(*,*) tempOctal%nDepth,endOctal%nDepth
             write(*,*) tempOctal%phi*radtodeg,tempOctal%dphi*radtodeg
             write(*,*) endOctal%phi*radtodeg,endOctal%dphi*radtodeg
             write(*,*) tempOctal%r, endOctal%r
             write(*,*) tempOctal%parent%chiline(1:tempOctal%parent%maxChildren)
             write(*,*) endOctal%parent%chiline(1:endOctal%parent%maxChildren)
             write(*,*) "temp"
             do i = 1, tempOctal%parent%maxChildren
                write(*,*) subcellCentre(tempOctal,i)
             enddo
             write(*,*) "end"
             do i = 1, tempOctal%parent%maxChildren
                write(*,*) subcellCentre(tempOctal,i)
             enddo

             do;enddo
          endif

       endif

!       write(*,*) tempOctal%centre,tempsubcell
!       sOctal => tempOctal
!       if (tempOctal%diffusionApprox(tempsubcell)) then
!          photonInDiffusionZone = .true.
!          if (tempOctal%leftHandDiffusionBoundary(subcell)) then
!             leftHandBoundary = .true.
!          else
!             leftHandBoundary = .false.
!          endif
!          tempOctal%nDiffusion(tempsubcell) = tempOctal%nDiffusion(tempsubcell) + abs(uHat%z)
!          diffusionZoneTemp = tempOctal%temperature(subcell)
!          sourceOctal => grid%octreeRoot
!!          call random_number(prob)
!!          call locateDiffusionProbAMR(prob, sourceOctal, sourceSubcell)
!!          rVec = subcellCentre(sourceOctal, sourcesubcell)
!          rVec = octVec
!          call diffPhotonPosition(grid, tempOctal, tempsubcell, rVec)
!          octVec = rVec
!          call amrGridValues(grid%octreeRoot, rVec,  startOctal=sOctal, foundOctal=tempOctal, &
!            foundSubcell=tempsubcell)
!          sOctal => tempOctal
!          if (tempOctal%diffusionApprox(tempsubcell)) then
!             write(*,*) "! error - photon produced in diffusion zone 1..."
!          endif
!       endif


! check whether the photon has escaped from the grid

       if (.not.inOctal(grid%octreeRoot, octVec)) then
          stillinGrid = .false.
          escaped = .true.
       endif


! two cases here now. in the 2D case we only update the distance grid in a single plane (y=0, x>=0)

! update the distance grid

!$OMP CRITICAL (changegrid)

       if (.not.twoD) then

          thisOctal%distanceGrid(subcell) = thisOctal%distanceGrid(subcell) &
               + tVal * dble(kappaAbsdb)
          thisOctal%nCrossings(subcell) = thisOctal%nCrossings(subcell) + 1
          if (directPhoton) thisOctal%nDirectPhotons(subcell) = thisOctal%nDirectPhotons(subcell)+1
       else
          
          thisOctVec = subcellCentre(thisOctal,subcell)
          call find2Doctal(thisOctVec, grid, foundOctal, isubcell)
          foundOctal%distanceGrid(isubcell) = foundOctal%distanceGrid(isubcell) &
               + tVal * dble(kappaAbsdb)
          foundOctal%nCrossings(isubcell) = foundOctal%nCrossings(isubcell) + 1
          if (directPhoton) foundOctal%nDirectPhotons(isubcell) = foundOctal%nDirectPhotons(isubcell)+1
       endif

!$OMP END CRITICAL (changegrid)


! now we need to return if the photon is in the diffusionzone

       if (photonInDiffusionZone) then
          goto 666
       endif
         

! now if the photon is in the grid choose a new random tau

       if (stillinGrid) then
          call random_number(r)
          tau = -log(1.0-r)
          call amrGridValues(grid%octreeRoot, octVec, iLambda=iLam,  foundOctal=thisOctal, &
               foundSubcell=subcell, kappaSca=kappaScadb, kappaAbs=kappaAbsdb, &
               grid=grid, inFlow=inFlow)
          sOctal => thisOctal
          oldOctal => thisOctal
          thisOctVec = octVec

! calculate the distance to the next cell

          call distanceToCellBoundary(grid, rVec, uHat, tVal, sOctal)
          tval = tval + fudgeFac*grid%halfSmallestSubcell

!          if (grid%octreeRoot%threed) then
!             call intersectCubeAMR(grid, rVec, uHat, tVal)
!          else
!             call intersectCubeAMR2D(grid, rVec, uHat, tVal, thisOctal)
!          endif
          octVec = rVec

! calculate the optical depth to the next cell boundary

          if (inFlow) then
             thisTau = dble(tVal) * (kappaAbsdb + kappaScadb)
          else
             thisTau = 1.0e-28
          end if

          if (tVal == 0.0d0) then
             escaped = .true.
             stillingrid = .false.
          endif
       endif ! still in grid

! if photon is still in grid and  tau > tau_to_the_next_cell then loop round again
! choosing a new tau

       
    enddo
    

! the photon may have escaped the grid...

    if (.not.inOctal(grid%octreeRoot, octVec))  escaped = .true.

 ! if not the photon must interact in this cell
       

    if (.not.escaped) then
       octVec = rVec
!       if (.not.inOctal(grid%octreeRoot, octVec)) then
!          write(*,*) "Error:: Photon location is out of boundaries, but its status is not ESCAPED."
!          write(*,*) "        .... [lucy_mod::toNextEventAMR]"
!          write(*,*) "octVec-centre = ",octVec-grid%octreeRoot%centre
!          write(*,*) "cell size = ",grid%octreeRoot%subcellsize
!          stop
!       endif
       if (dble(tau)/thisTau .gt. 1.d0) then
          write(*,*) "tau prob",tau,thisTau
       endif

!       if (grid%octreeRoot%threed) then
!          call intersectCubeAMR(grid, rVec, uHat, tVal)
!       else
!          call intersectCubeAMR2D(grid, rVec, uHat, tVal)
!       endif
       call amrGridValues(grid%octreeRoot, octVec, startOctal=oldOctal,iLambda=iLam, &
            foundOctal=thisOctal, foundSubcell=subcell, & 
            kappaAbs=kappaAbsdb,kappaSca=kappaScadb, grid=grid, inFlow=inFlow)
       thisOctVec = octVec


       if (thisOctal%diffusionApprox(subcell)) then
          write(*,*) "Photon in diff zone but not escaped"
       endif

       if (.not.inFlow) kappaAbsdb =0.0d0


! update the distance grid

       if (thisTau > 0.d0) then

!$OMP CRITICAL (changegrid2)

          
          if (.not.twoD) then

             thisOctal%distanceGrid(subcell) = thisOctal%distanceGrid(subcell) &
                  + (dble(tVal)*dble(tau)/thisTau) * dble(kappaAbsdb)
             thisOctal%nCrossings(subcell) = thisOctal%nCrossings(subcell) + 1
          if (directPhoton) thisOctal%nDirectPhotons(subcell) = thisOctal%nDirectPhotons(subcell)+1

          
          else
          
             thisOctVec = subcellCentre(thisOctal,subcell)
             call find2Doctal(thisOctVec, grid, foundOctal, isubcell)
             foundOctal%distanceGrid(isubcell) = foundOctal%distanceGrid(isubcell) &
                  + (dble(tVal)*dble(tau)/thisTau) * dble(kappaAbsdb)
             foundOctal%nCrossings(isubcell) = foundOctal%nCrossings(isubcell) + 1
             if (directPhoton) foundOctal%nDirectPhotons(isubcell) = foundOctal%nDirectPhotons(isubcell)+1

          endif

!$OMP END CRITICAL (changegrid2)


          oldOctal => thisOctal
          
       endif

       if (tau > thisTau) then
          write(*,*) "tau > thistau"
          stop
       endif

! move the requisite distance within the cell and return

       tVec = rVec
       rVec = rVec + (dble(tVal)*dble(tau)/thisTau) * uHat


! this is a workaround due to numerical problems with long pathlengths
! and small cells. needs fixing.

       call amrGridValues(grid%octreeRoot, rVec,  startOctal=sOctal, foundOctal=tempOctal, &
            foundSubcell=tempsubcell)
       if (tempOctal%diffusionApprox(tempsubcell)) then
          photonInDiffusionZone = .true.
          call randomWalk(grid, tempOctal, tempSubcell,  endOctal, endSubcell, diffusionZoneTemp)
          photonInDiffusionZone = .true.
          rVec = subcellCentre(endOctal,endSubcell)
          octVec = rVec
          call amrGridValues(grid%octreeRoot, rVec,  startOctal=sOctal,foundOctal=tempOctal, &
            foundSubcell=tempsubcell)
          if (tempOctal%diffusionApprox(tempsubcell)) then
             write(*,*) "! error - photon produced in diffusion zone 2..."
             write(*,*) Tau,thistau,tval
          endif
       endif


    endif

666 continue

 end subroutine toNextEventAMR

  recursive subroutine removeDust(thisOctal, Tthresh, nRemoved)
  type(octal), pointer   :: thisOctal
  type(octal), pointer  :: child 
  real :: Tthresh
  integer :: nRemoved
  integer :: subcell, i
  
  do subcell = 1, thisOctal%maxChildren
       if (thisOctal%hasChild(subcell)) then
          ! find the child
          do i = 1, thisOctal%nChildren, 1
             if (thisOctal%indexChild(i) == subcell) then
                child => thisOctal%child(i)
                call removeDust(child, Tthresh, nRemoved)
                exit
             end if
          end do
       else
          if (thisOctal%temperature(subcell) > Tthresh) then
             write(*,*) "cell removed with T at ",thisOctal%temperature(subcell)
             thisOctal%inFlow(subcell) = .false.
             thisOctal%etaCont(subcell) = 1.e-30
             thisOctal%rho(subcell) = 1.e-27
             thisOctal%temperature(subcell) = 1.e-3
             nRemoved = nRemoved + 1
          endif
       endif
    enddo
  end subroutine removeDust



!$MPI  !
!$MPI  ! For MPI implementation.
!$MPI  ! Updates distanceGrid and nCrossings from each octal
!$MPI  !
!$MPI  recursive subroutine update_octal_MPI(thisOctal, grid)
!$MPI    implicit none
!$MPI    include 'mpif.h'
!$MPI
!$MPI    type(gridtype) :: grid
!$MPI    type(octal), pointer   :: thisOctal
!$MPI    type(octal), pointer  :: child 
!$MPI    integer :: subcell, i
!$MPI    real :: r
!$MPI    ! data space to store values from all processors
!$MPI    real, save, allocatable  :: buffer_ncrossings(:)     
!$MPI    real(double), save, allocatable     :: buffer_distanceGrid(:) 
!$MPI    integer  :: ierr
!$MPI    integer, save  :: np  ! number of processors
!$MPI    logical, save  :: first_time = .true.
!$MPI
!$MPI    ! find the number of the processors for the first time.    
!$MPI    if (first_time) then
!$MPI       call MPI_COMM_SIZE(MPI_COMM_WORLD, np, ierr)
!$MPI       allocate(buffer_ncrossings(np))
!$MPI       allocate(buffer_distanceGrid(np))
!$MPI       first_time = .false.
!$MPI    end if
!$MPI
!$MPI
!$MPI    do subcell = 1, thisOctal%maxChildren
!$MPI       if (thisOctal%hasChild(subcell)) then
!$MPI          ! find the child
!$MPI          do i = 1, thisOctal%nChildren, 1
!$MPI             if (thisOctal%indexChild(i) == subcell) then
!$MPI                child => thisOctal%child(i)
!$MPI                call update_octal_MPI(child, grid)
!$MPI                exit
!$MPI             end if
!$MPI          end do
!$MPI       else
!$MPI          ! 
!$MPI          ! collecting the data from all the processors including itself.
!$MPI          call MPI_ALLGATHER(thisOctal%distanceGrid(subcell), 1, MPI_REAL, &
!$MPI               buffer_distanceGrid, 1, MPI_REAL, MPI_COMM_WORLD, ierr)  
!$MPI          call MPI_BARRIER(MPI_COMM_WORLD, ierr)
!$MPI          
!$MPI          
!$MPI          call MPI_ALLGATHER(REAL(thisOctal%ncrossings(subcell)), 1, MPI_REAL, &
!$MPI               buffer_ncrossings, 1, MPI_REAL, MPI_COMM_WORLD, ierr)  
!$MPI          call MPI_BARRIER(MPI_COMM_WORLD, ierr)
!$MPI          
!$MPI          thisOctal%distanceGrid(subcell) = SUM(buffer_distanceGrid)
!$MPI          thisOctal%nCrossings(subcell) = INT(SUM(buffer_ncrossings))
!$MPI          
!$MPI       endif
!$MPI    enddo
!$MPI  end subroutine update_octal_MPI


!$MPI  subroutine updateGridMPI(grid)
!$MPI    implicit none
!$MPI    include 'mpif.h'
!$MPI    type(gridtype) :: grid
!$MPI    integer :: nOctals, nVoxels
!$MPI    real, allocatable :: nCrossings(:)
!$MPI    real, allocatable :: tempRealArray(:)
!$MPI    real(double), allocatable :: distanceGrid(:),tempDoubleArray(:)
!$MPI    real, allocatable :: nDiffusion(:)
!$MPI    integer :: np, ierr,my_rank, nIndex
!$MPI
!$MPI    ! FOR MPI IMPLEMENTATION=======================================================
!$MPI    !  Get my process rank # 
!$MPI    call MPI_COMM_RANK(MPI_COMM_WORLD, my_rank, ierr)
!$MPI  
!$MPI    ! Find the total # of precessor being used in this run
!$MPI    call MPI_COMM_SIZE(MPI_COMM_WORLD, np, ierr)
!$MPI
!$MPI    call MPI_BARRIER(MPI_COMM_WORLD, ierr) 
!$MPI    nOctals = 0
!$MPI    nVoxels = 0
!$MPI    call countVoxels(grid%octreeRoot,nOctals,nVoxels)
!$MPI    allocate(nCrossings(1:nVoxels))
!$MPI    allocate(nDiffusion(1:nVoxels))
!$MPI    allocate(distanceGrid(1:nVoxels))
!$MPI
!$MPI    nIndex = 0
!$MPI    call packValues(grid%octreeRoot,nIndex,distanceGrid,nCrossings,ndiffusion)
!$MPI
!$MPI
!$MPI    allocate(tempDoubleArray(nVoxels))
!$MPI    allocate(tempRealArray(nVoxels))
!$MPI
!$MPI    tempDoubleArray = 0.d0
!$MPI    call MPI_ALLREDUCE(distanceGrid,tempDoubleArray,nVoxels,MPI_DOUBLE_PRECISION,&
!$MPI         MPI_SUM,MPI_COMM_WORLD,ierr)
!$MPI    distanceGrid = tempDoubleArray 
!$MPI
!$MPI    tempRealArray = 0.0
!$MPI    call MPI_ALLREDUCE(nCrossings,tempRealArray,nVoxels,MPI_REAL,&
!$MPI         MPI_SUM,MPI_COMM_WORLD,ierr)
!$MPI    nCrossings = tempRealArray 
!$MPI
!$MPI    tempRealArray = 0.0
!$MPI    call MPI_ALLREDUCE(nDiffusion,tempRealArray,nVoxels,MPI_REAL,&
!$MPI         MPI_SUM,MPI_COMM_WORLD,ierr)
!$MPI    nDiffusion = tempRealArray 
!$MPI    
!$MPI    deallocate(tempRealArray, tempDoubleArray)
!$MPI     
!$MPI    call MPI_BARRIER(MPI_COMM_WORLD, ierr) 
!$MPI    
!$MPI    nIndex = 0
!$MPI    call unpackValues(grid%octreeRoot,nIndex,distanceGrid,nCrossings,nDiffusion)
!$MPI
!$MPI    deallocate(nCrossings, nDiffusion, distanceGrid)
!$MPI
!$MPI  end subroutine updateGridMPI



  subroutine find2Doctal(rVec, grid, foundOctal, subcell)
    type(GRIDTYPE) :: grid
    type(OCTALVECTOR) :: rVec, rotVec
    type(OCTAL), pointer :: foundOctal, resultOctal
    integer :: subcell
    real(oct) :: r

! This subroutine finds the location of an octal in the y=0, x>=0 plane
! that corresponds to the position vector rVec when it is rotated
! into the y=0 plane 


    rotVec%z = rVec%z     ! the new vector has the same "z" value

    r = sqrt(rVec%x**2 + rVec%y**2) ! distance from z-axis

    rotVec%y = 0.

    rotVec%x = r

! now we find the octal and subcell that rotVec lies in

    call findSubcellTD(rotVec, grid%ocTreeRoot, resultOctal, subcell)
    foundOctal => resultOctal

  end subroutine find2Doctal

  recursive subroutine remapDistanceGrid(thisOctal, grid)
    type(GRIDTYPE) :: grid
    type(OCTAL), pointer :: thisOctal, child, foundOctal, resultOctal
    type(OCTALVECTOR) :: rVec, rotVec
    real(oct) :: r
    integer :: subcell, j, isub

! this routine remaps the distance grid attribute of a two-D plane
! (which is y=0, x>=0) onto a three-D grid

    do isub = 1, thisOctal%maxChildren, 1
      if ( thisOctal%hasChild(isub) ) then
        ! if the current subcell has a child, call this subroutine on
        !   each of its children
        do j = 1, thisOctal%nchildren
          if ( thisOctal%indexchild(j) == isub ) then
            child => thisoctal%child(j)
            call remapdistancegrid(child, grid)
            exit
          end if
        end do
      else
        ! if the current subcell does not have a child, then do the remap

        rVec = subcellCentre(thisOctal, isub)

        rotVec%z = rVec%z     ! the new vector has the same "z" value
    
        r = sqrt(rVec%x**2 + rVec%y**2) ! distance from z-axis
    
        rotVec%y = 0.

        rotVec%x = r

        ! now we find the octal and subcell that rotVec lies in

        call findSubcellTD(rotVec, grid%ocTreeRoot, resultOctal, subcell)
        foundOctal=>resultOctal

! we have added the path lengths over all cells in 3d to a 2d plane. we therefore need to correct
! the path length summation by the fractional volume that this cell in the 2d plane corresponds
! to. ncrossings we keep as is - it is used in a statistical sense here.

        thisOctal%chiLine(isub) = foundOctal%distanceGrid(subcell) * foundOctal%etaLine(subcell)
        thisOctal%nCrossings(isub) = foundOctal%nCrossings(subcell)

        thisOctal%rho(isub) = foundOctal%rho(subcell)
        thisOctal%temperature(isub) = foundOctal%temperature(subcell)

      end if
    end do
  end subroutine remapDistanceGrid

  recursive subroutine setupCellVolumes(thisOctal, grid)
    type(GRIDTYPE) :: grid
    type(OCTAL), pointer :: thisOctal, child, foundOctal, resultOctal
    type(OCTALVECTOR) :: rVec, rotVec
    real(oct) :: r
    integer :: subcell, j, isub

! this routine remaps the distance grid attribute of a two-D plane
! (which is y=0, x>=0) onto a three-D grid

    do isub = 1, thisOctal%maxChildren, 1
      if ( thisOctal%hasChild(isub) ) then
        ! if the current subcell has a child, call this subroutine on
        !   each of its children
        do j = 1, thisOctal%nchildren
          if ( thisOctal%indexchild(j) == isub ) then
            child => thisoctal%child(j)
            call setupCellVolumes(child, grid)
            exit
          end if
        end do
      else
        ! if the current subcell does not have a child, then do the remap

        rVec = subcellCentre(thisOctal, isub)

        rotVec%z = rVec%z     ! the new vector has the same "z" value
    
        r = sqrt(rVec%x**2 + rVec%y**2) ! distance from z-axis
    
        rotVec%y = 0.

        rotVec%x = r

        ! now we find the octal and subcell that rotVec lies in

        call findSubcellTD(rotVec, grid%ocTreeRoot, resultOctal, subcell)
        foundOctal=>resultOctal

        foundOctal%distanceGrid(subcell) = foundOctal%distanceGrid(subcell) + thisOctal%subcellsize**3
        foundOctal%nCrossings(subcell) = foundOctal%nCrossings(subcell) + 1

      end if
    end do
  end subroutine setupCellVolumes


  recursive subroutine normCellVolumes(thisOctal, grid)
    type(GRIDTYPE) :: grid
    type(OCTAL), pointer :: thisOctal, child, foundOctal, resultOctal
    type(OCTALVECTOR) :: rVec, rotVec
    real(oct) :: r
    integer :: subcell, j, isub

! this routine remaps the distance grid attribute of a two-D plane
! (which is y=0, x>=0) onto a three-D grid

    do isub = 1, thisOctal%maxChildren, 1
      if ( thisOctal%hasChild(isub) ) then
        ! if the current subcell has a child, call this subroutine on
        !   each of its children
        do j = 1, thisOctal%nchildren
          if ( thisOctal%indexchild(j) == isub ) then
            child => thisoctal%child(j)
            call normCellVolumes(child, grid)
            exit
          end if
        end do
      else
        ! if the current subcell does not have a child, then do the remap

        rVec = subcellCentre(thisOctal, isub)

        rotVec%z = rVec%z     ! the new vector has the same "z" value
    
        r = sqrt(rVec%x**2 + rVec%y**2) ! distance from z-axis
    
        rotVec%y = 0.

        rotVec%x = r

        ! now we find the octal and subcell that rotVec lies in

        call findSubcellTD(rotVec, grid%ocTreeRoot, resultOctal, subcell)
        foundOctal=>resultOctal

! etaline is used as a placeholder here. it corresponds to the fractional volume occupied by the cell in
! the 2d plane compared to the total volume of the 3d space

        thisOctal%etaLine(isub) = thisOctal%subcellsize**3 / foundOctal%distanceGrid(subcell)

      end if
    end do
  end subroutine normCellVolumes

  recursive subroutine resetDistanceGrid(thisOctal)
  type(octal), pointer   :: thisOctal
  type(octal), pointer  :: child 
  integer :: subcell, i
  
  do subcell = 1, thisOctal%maxChildren
       if (thisOctal%hasChild(subcell)) then
          ! find the child
          do i = 1, thisOctal%nChildren, 1
             if (thisOctal%indexChild(i) == subcell) then
                child => thisOctal%child(i)
                call resetDistanceGrid(child)
                exit
             end if
          end do
       else
          thisOctal%distanceGrid(subcell) = thisOctal%chiline(subcell) 
       endif
    enddo
  end subroutine resetDistanceGrid

  recursive subroutine resetDirectGrid(thisOctal)
  type(octal), pointer   :: thisOctal
  type(octal), pointer  :: child 
  integer :: subcell, i
  
  do subcell = 1, thisOctal%maxChildren
       if (thisOctal%hasChild(subcell)) then
          ! find the child
          do i = 1, thisOctal%nChildren, 1
             if (thisOctal%indexChild(i) == subcell) then
                child => thisOctal%child(i)
                call resetDirectGrid(child)
                exit
             end if
          end do
       else
          thisOctal%nDirectPhotons(subcell) = 0
       endif
    enddo
  end subroutine resetDirectGrid

  recursive subroutine recountDiffusionCells(thisOctal, ncells)
  type(octal), pointer   :: thisOctal
  type(octal), pointer  :: child 
  integer :: subcell, i
  integer :: ncells
  
  do subcell = 1, thisOctal%maxChildren
       if (thisOctal%hasChild(subcell)) then
          ! find the child
          do i = 1, thisOctal%nChildren, 1
             if (thisOctal%indexChild(i) == subcell) then
                child => thisOctal%child(i)
                call recountDiffusionCells(child, ncells)
                exit
             end if
          end do
       else
          if (thisOctal%diffusionApprox(subcell)) then
             ncells = ncells + 1
          endif
       endif
    enddo
  end subroutine recountDiffusionCells

  recursive subroutine packvalues(thisOctal,nIndex,distanceGrid,nCrossings, nDiffusion)
  type(octal), pointer   :: thisOctal
  type(octal), pointer  :: child 
  real(double) :: distanceGrid(:)
  real :: nCrossings(:)
  real :: nDiffusion(:)
  integer :: nIndex
  integer :: subcell, i
  
  do subcell = 1, thisOctal%maxChildren
       if (thisOctal%hasChild(subcell)) then
          ! find the child
          do i = 1, thisOctal%nChildren, 1
             if (thisOctal%indexChild(i) == subcell) then
                child => thisOctal%child(i)
                call packvalues(child,nIndex,distanceGrid,nCrossings,nDiffusion)
                exit
             end if
          end do
       else
          nIndex = nIndex + 1
          distanceGrid(nIndex) = thisOctal%distanceGrid(subcell)
          nCrossings(nIndex) = real(thisOctal%nCrossings(subcell))
          nDiffusion(nIndex) = thisOctal%nDiffusion(subcell)
       endif
    enddo
  end subroutine packvalues

  recursive subroutine unpackvalues(thisOctal,nIndex,distanceGrid,nCrossings, nDiffusion)
  type(octal), pointer   :: thisOctal
  type(octal), pointer  :: child 
  real(double) :: distanceGrid(:)
  real :: ncrossings(:)
  real :: ndiffusion(:)
  integer :: nIndex
  integer :: subcell, i
  
  do subcell = 1, thisOctal%maxChildren
       if (thisOctal%hasChild(subcell)) then
          ! find the child
          do i = 1, thisOctal%nChildren, 1
             if (thisOctal%indexChild(i) == subcell) then
                child => thisOctal%child(i)
                call unpackvalues(child,nIndex,distanceGrid,nCrossings,nDiffusion)
                exit
             end if
          end do
       else
          nIndex = nIndex + 1
          thisOctal%distanceGrid(subcell) = distanceGrid(nIndex)
          thisOctal%nCrossings(subcell) = int(nCrossings(nIndex))
          thisOctal%nDiffusion(subcell) = nDiffusion(nIndex)
       endif
    enddo
  end subroutine unpackvalues

  recursive subroutine directPhotonSmooth(thisOctal, grid, converged, inheritProps, interpProps)
    type(gridtype) :: grid
    type(octal), pointer   :: thisOctal
    type(octal), pointer  :: child, neighbourOctal, startOctal
    logical, optional :: inheritProps, interpProps
    integer :: subcell, i
    logical :: converged
    real(double) :: kabs, ksca, r
    type(OCTALVECTOR) :: dirVec(6), centre, octVec
    real :: thisFac, neighbourFac
    integer :: neighbourSubcell, j
    dirVec(1) = OCTALVECTOR( 0.d0, 0.d0, +1.d0)
    dirVec(2) = OCTALVECTOR( 0.d0,+1.d0,  0.d0)
    dirVec(3) = OCTALVECTOR(+1.d0, 0.d0,  0.d0)
    dirVec(4) = OCTALVECTOR(-1.d0, 0.d0,  0.d0)
    dirVec(5) = OCTALVECTOR( 0.d0,-1.d0,  0.d0)
    dirVec(6) = OCTALVECTOR( 0.d0, 0.d0, -1.d0)

!    do subcell = 1, thisOctal%maxChildren
    subcell = 1
    do while (subcell < thisOctal%maxChildren)
       if (thisOctal%hasChild(subcell)) then
          ! find the child
          do i = 1, thisOctal%nChildren, 1
             if (thisOctal%indexChild(i) == subcell) then
                child => thisOctal%child(i)
                call directPhotonSmooth(child, grid, converged, inheritProps, interpProps)
                exit
             end if
          end do
       else

          if (thisOctal%nCrossings(subcell) > 0)  then
             thisFac = real(thisOctal%nDirectPhotons(subcell)) / real(thisOctal%ncrossings(subcell))
          else
             thisFac = 0.
          endif

          r = thisOctal%subcellSize/2. + grid%halfSmallestSubcell 
          centre = subcellCentre(thisOctal, subcell)
          do j = 1, 6
             octVec = centre + r * dirvec(j)
             if (inOctal(grid%octreeRoot, octVec)) then
                startOctal => thisOctal
                call amrGridValues(grid%octreeRoot, octVec, grid=grid, startOctal=startOctal, &
                     foundOctal=neighbourOctal, foundsubcell=neighbourSubcell)
                if (neighbourOctal%nCrossings(neighboursubcell) > 0)  then
                   neighbourFac = real(neighbourOctal%nDirectPhotons(neighboursubcell)) &
                        / real(neighbourOctal%ncrossings(neighboursubcell))
                else
                   neighbourFac = 0.
                endif
                if ((min(thisFac, neighbourFac) == 0.0).and.(max(thisFac, neighbourFac) > 0.5)) then
                   if ((thisFac >= 0.).and.(thisFac < neighbourFac)) then
                      call addNewChild(thisOctal,subcell,grid,adjustGridInfo=.TRUE., &
                           inherit=inheritProps, interp=interpProps)
                      write(*,*) "split",thisFac,neighbourFac
                      converged = .false.
                      subcell = 0
                      exit
                   endif
                endif
             endif
          enddo
       endif
       subcell = subcell + 1
    end do

  end subroutine directPhotonSmooth


  recursive subroutine  calcContinuumEmissivityLucy(grid, thisOctal, nlambda, lamArray)
    type(GRIDTYPE) :: grid
    integer :: nLambda
    real :: lamArray(:)
    type(octal), pointer   :: thisOctal
    type(octal), pointer  :: child 
    integer :: subcell, i
  
  do subcell = 1, thisOctal%maxChildren
       if (thisOctal%hasChild(subcell)) then
          ! find the child
          do i = 1, thisOctal%nChildren, 1
             if (thisOctal%indexChild(i) == subcell) then
                child => thisOctal%child(i)
                call calcContinuumEmissivityLucy(grid, child, nlambda, lamArray)
                exit
             end if
          end do
       else
          thisOctal%etaCont(subcell) = 1.d-40
          if (thisOctal%temperature(subcell) > 1.d-3) then

             call addDustContinuumLucy(thisOctal, subcell, grid, nlambda, lamArray)
             
          endif

       endif
    enddo
  end subroutine calcContinuumEmissivityLucy


subroutine addDustContinuumLucy(thisOctal, subcell, grid, nlambda, lamArray)

  type(OCTAL), pointer :: thisOctal
  integer :: subcell
  type(GRIDTYPE) :: grid
  integer :: nLambda
  real :: lamArray(:)
  integer :: i, iLam
  real :: dlam
  type(OCTALVECTOR) :: octVec
  real(double), allocatable :: kabsArray(:)


  allocate(kAbsArray(1:nlambda))

  call returnKappa(grid, thisOctal, subcell, kappaAbsArray=kAbsArray)

  thisOctal%etaCont(subcell) = tiny(thisOctal%etaCont(subcell))

  do i = 2, nLambda
     dlam = lamArray(i)-lamArray(i-1)
     thisOctal%etaCont(subcell) = thisOctal%etaCont(subcell) + &
          bLambda(dble(lamArray(i)), dble(thisOctal%temperature(subcell))) * &
             kAbsArray(i) *1.d-10* dlam * fourPi * 1.d-8 ! conversion from per cm to per A
  enddo

  deallocate(kAbsArray)

end subroutine addDustContinuumLucy


end module lucy_mod

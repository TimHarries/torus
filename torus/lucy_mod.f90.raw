module lucy_mod

  use constants_mod
  use grid_mod
  use vector_mod
  use phasematrix_mod
  use amr_mod
  use source_mod
  use spectrum_mod
  use parallel_mod
  use timing
  implicit none


contains


  subroutine lucyRadiativeEquilibrium(grid, miePhase, nMuMie, nLambda, lamArray, temperature, nLucy)

    type(GRIDTYPE) :: grid
    type(OCTALVECTOR) :: uHat, uNew
    type(OCTALVECTOR) :: rVec
    integer :: nlucy
    integer,intent(in) :: nLambda, nMuMie
    type(PHASEMATRIX):: miePhase(1:nLambda, 1:nMuMie)
    real :: lamArray(:)
    real(oct), allocatable :: distanceGrid(:, :, :)
    real(oct) :: r
    integer, parameter :: nFreq = 100
    integer :: i, j, k
    real(oct) :: freq(nFreq), dnu(nFreq), probDistPlanck(nFreq), probDistJnu(nFreq)
    real(oct) :: temperature
    integer :: nMonte, iMonte, nScat, nAbs
    real(oct) :: thisFreq,  logFreqStart, logFreqEnd
    real(oct) :: albedo
    logical :: escaped
    integer :: i1, i2, i3
    real(oct) :: t1, t2, t3
    real(oct) :: thisLam
    integer :: iLam
    integer :: nInf
    real(oct) :: t
    integer :: nt
    real(oct) :: ang
    integer :: iIter, nIter = 5
    real(oct) :: kabs
    real(oct) ::  kappaP, norm
    real(oct) :: adot, V, epsOverDeltaT
    real(oct) :: newT, deltaT
    real(oct) :: meanDeltaT
    real(oct) :: dx, dy, tr(6), fg, bg
    real(oct), allocatable :: tempImage(:,:)
    integer :: nDT
    real(oct) :: totalEmission
    type(vector) :: vec_tmp

    allocate(tempImage(1:grid%nx,1:grid%ny))


    logFreqStart = log10((cSpeed / (lamArray(nLambda)*1.e-8)))
    logFreqEnd =  log10((cSpeed / (lamArray(1)*1.e-8)))
    write(*,*) logFreqStart, logFreqEnd
    do i = 1, nFreq
       freq(i) = logFreqStart + (dble(i-1)/dble(nFreq-1))*(logFreqEnd-logFreqStart)
       freq(i) = 10.**freq(i)
    enddo
    write(*,*) "Lam",(cSpeed/freq(1))*1.e8,(cSpeed/freq(nFreq))*1.e8

    do i = 2, nFreq-1
       dnu(i) = 0.5*((freq(i+1)+freq(i))-(freq(i)+freq(i-1)))
    enddo
    dnu(1) = freq(2)-freq(1)
    dnu(nFreq) = freq(nFreq)-freq(nFreq-1)



    call setupFreqProb(temperature, freq, dnu, nFreq, ProbDistPlanck)


    write(*,'(a)') "Computing lucy radiative equilibrium..."


    allocate(distanceGrid(1:grid%nx, 1:grid%ny, 1:grid%nz))


    do iIter = 1, nIter
       distanceGrid = 0.d0
       write(*,*) "Iteration",iIter
       nInf = 0
       nScat = 0
       nAbs = 0

       nMonte = nLucy

       do iMonte = 1, nMonte
          escaped = .false.
          call random_number(r)
          call locate(probDistPlanck, nFreq, r, j)
          thisFreq = freq(j) + (freq(j+1) - freq(j))* &
               (r - probDistPlanck(j))/(probDistPlanck(j+1)-probDistPlanck(j))


          rVec  = real(grid%rCore, kind=oct) * randomUnitOctalVector()
!          uHat = fromPhotosphereVector(rVec)
          ! -- using a new routine in source_mod.f90 (RK)
          uHat = random_direction_from_sphere(rVec)
          if ( (rVec .dot. uHat) < 0.) uHat = (-1.d0) * uHat

          do while(.not.escaped)
             call toNextEvent(grid, rVec, uHat, escaped, distanceGrid, thisFreq, nLambda, lamArray)

             if (escaped) nInf = nInf + 1

             if (.not. escaped) then

                thisLam = (cSpeed / thisFreq) * 1.e8
                call locate(lamArray, nLambda, real(thisLam), iLam)

                call getIndices(grid, rVec, i1, i2, i3, t1, t2, t3)
                if (.not.grid%oneKappa) then
                   albedo = grid%kappaSca(i1,i2,i3,iLam)/(grid%kappaSca(i1,i2,i3,iLam)+grid%kappaAbs(i1,i2,i3,iLam))
                else
                   albedo = grid%oneKappaSca(1,iLam) / (grid%oneKappaSca(1,iLam)+grid%oneKappaAbs(1,iLam))
                endif
                call random_number(r)
                if (r < albedo) then
                   vec_tmp=uhat 
                   uNew = newDirectionMie(vec_tmp, real(thisLam), lamArray, nLambda, miePhase, nMuMie)

                   nScat = nScat + 1
                   uHat = uNew

                else
                   nAbs = nAbs + 1
                   probDistJnu(1) = 0.
                   do i = 2, nFreq
                      thisLam = (cSpeed / freq(i)) * 1.e8
                      call hunt(lamArray, nLambda, real(thisLam), iLam)
                      if ((ilam >=1).and.(ilam <= nlambda)) then
                         if (.not.grid%oneKappa) then
                            kabs = grid%kappaAbs(i1,i2,i3,iLam)
                         else
                            kabs = grid%oneKappaAbs(1,iLam) * grid%rho(i1,i2,i3)
                         endif
                         probDistJnu(i) = probDistJnu(i-1) + &
                             (bnu(freq(i),dble(grid%temperature(i1,i2,i3)))) &
                                                     * kabs * dnu(i)
                      endif
                   enddo
                   probDistJnu(1:nFreq) = probDistJnu(1:nFreq) / probDistJnu(nFreq)
                   call random_number(r)
                   call locate(probDistJnu, nFreq, r, j)
                   if (j == nFreq) j = nFreq -1
                   thisFreq = freq(j) + (freq(j+1) - freq(j))* &
                        (r - probDistJnu(j))/(probDistJnu(j+1)-probDistJnu(j))
                   uHat = randomUnitVector()
                endif

             endif
          enddo
       enddo
       write(*,'(a,f7.2)') "Photons done.",real(ninf)/real(nmonte)
       write(*,'(a,f7.3)') "Mean number of scatters per photon: ",real(nScat)/real(nMonte)
       write(*,'(a,f7.3)') "Mean number of absorbs  per photon: ",real(nAbs)/real(nMonte)


       V = (dble(grid%xAxis(2)-grid%xAxis(1))*dble(grid%yAxis(2)-grid%yAxis(1))*dble(grid%zAxis(2)-grid%zAxis(1)))


       epsOverDeltaT = (dble(grid%lCore)) / dble(nInf)

       meanDeltaT = 0.
       nDT = 0


       totalEmission = 0.
       do i1 = 1, grid%nx
          do i2 = 1, grid%ny
             do i3 = 1, grid%nz
                if (grid%inUse(i1,i2,i3)) then
                   adot = epsoverDeltaT * (1.d0 / v) * distancegrid(i1,i2,i3) / 1.d30
                   kappaP = 0.d0
                   norm = 0.d0
                   do i = 1, nFreq
                      thisLam = (cSpeed / freq(i)) * 1.e8
                      call hunt(lamArray, nLambda, real(thisLam), iLam)
                      if ((iLam >=1) .and. (iLam <= nLambda)) then
                         if (.not.grid%oneKappa) then
                            kabs = grid%kappaAbs(i1,i2,i3,iLam)
                         else
                            kabs = grid%oneKappaAbs(1,iLam) * grid%rho(i1,i2,i3)
                         endif

                         kappaP = kappaP + kabs * &
                              bnu(freq(i),dble(grid%temperature(i1,i2,i3)))  * dnu(i)
                         norm = norm + bnu(freq(i),dble(grid%temperature(i1,i2,i3)))  * dnu(i)
                      endif
                   enddo
                   kappaP = kappaP / norm /1.d10


                   newT = (pi / stefanBoltz) * aDot / (fourPi * kappaP)
                   newT = newT**0.25

                   deltaT = newT - grid%temperature(i1,i2,i3)
                   grid%temperature(i1,i2,i3) = max(1.e-3,grid%temperature(i1,i2,i3) + 0.8 * real(deltaT))
                   nDT = nDT  + 1
                   meanDeltaT = meanDeltaT + deltaT
                   kappaP = 0.d0
                   norm = 0.d0
                   do i = 1, nFreq
                      thisLam = (cSpeed / freq(i)) * 1.e8
                      call hunt(lamArray, nLambda, real(thisLam), iLam)
                      if ((iLam >=1) .and. (iLam <= nLambda)) then
                         if (.not.grid%oneKappa) then
                            kabs = grid%kappaAbs(i1,i2,i3,iLam)
                         else
                            kabs = grid%oneKappaAbs(1,iLam) * grid%rho(i1,i2,i3)
                         endif
                         kappaP = kappaP + kabs * &
                              bnu(freq(i),dble(grid%temperature(i1,i2,i3))) * dnu(i)
                         norm = norm + bnu(freq(i),dble(grid%temperature(i1,i2,i3))) * dnu(i)
                      endif
                   enddo
                   kappaP = kappaP / norm /1.e10
                   grid%etaCont(i1,i2,i3) = fourPi * kappaP * (stefanBoltz/pi) * (grid%temperature(i1,i2,i3)**4)
                   totalEmission = totalEmission + grid%etaCont(i1,i2,i3) * V

                endif
             enddo
          enddo
       enddo

       write(*,*) meanDeltaT / real(nDT)

       write(*,*) "Emissivity of dust / core", totalEmission /grid%lCore * 1.e30

       do i = 1, grid%nx
          do j = 1, grid%ny
             tempImage(i,j) = grid%temperature(i,j,grid%nz/2)
          enddo
       enddo

       dx = grid%xAxis(2) - grid%xAxis(1)
       dy = grid%yAxis(2) - grid%yAxis(1) 
       tr(1) =  - dx + grid%xAxis(1)
       tr(2) = dx
       tr(3) = 0.
       tr(4) =  - dy + grid%yAxis(1)
       tr(5) = 0.
       tr(6) = dy

       bg = MAXVAL(tempImage, mask=grid%inUse(1:grid%nx,1:grid%ny,grid%nz/2))
       fg = MINVAL(tempImage, mask=grid%inUse(1:grid%nx,1:grid%ny,grid%nz/2))
       call pgbegin(0,"/xs",1,1)

       call pgvport(0.1,0.9,0.1,0.9)

       call pgwnad(grid%xAxis(1), grid%xAxis(grid%nx), grid%yAxis(1), grid%yAxis(grid%ny))
       call palette(3)
       call pgimag(tempImage, grid%nx, grid%ny, 1, grid%nx, 1, grid%ny, fg, bg, tr)
       call pgwedg("RI", 0.,10., fg,bg," ")
       call pgbox('bcnst',0,0,'bcnst',0,0)
       call pgend
    enddo
    open(21,file="r.dat",status="unknown",form="formatted")
    do i = 1, 100
       r = grid%xAxis(grid%nx) * real(i-1)/99.
       t = 0
       nT = 0
       do j = 1, 100
          ang = twoPi * real(j-1)/100.
          rVec = OCTALVECTOR(r*cos(ang), r*sin(ang),0.)
          call getIndices(grid, rVec, i1, i2, i3, t1, t2, t3)
          if (grid%inUse(i1,i2,i3)) then
             nT = nT + 1
             t = t + grid%temperature(i1,i2,i3)
          endif
       enddo
       if (nt > 0) then
          t = t / real(nt)
          write(21,*) r / grid%rCore, t
       endif
    enddo
    close(21)

    open(22,file="temps.dat",status="unknown",form="unformatted")
    do i = 1, grid%nx
       do j = 1, grid%ny
          do k = 1, grid%nz
             write(22) grid%temperature(i,j,k), grid%etaCont(i,j,k)
          enddo
       enddo
    enddo
    close(22)


  end subroutine lucyRadiativeEquilibrium

  subroutine lucyRadiativeEquilibriumAMR(grid, miePhase, nMuMie, nLambda, lamArray, &
       source, nSource, nLucy, massEnvelope, tthresh, percent_undersampled_min, twoD, maxIter)
    implicit none
!$MPI include 'mpif.h'
    type(GRIDTYPE) :: grid
    integer :: nSource
    type(SOURCETYPE) :: source(nsource), thisSource
    integer :: nLucy
    logical :: twoD
    ! threshold value for undersampled cell in percent (for stopping iteration).
    real, intent(in) :: percent_undersampled_min  
    type(OCTALVECTOR) ::  uHat, uNew, rVec, rHat
    type(OCTALVECTOR) :: octVec,avedirection
    type(OCTAL), pointer :: thisOctal
    integer, intent(in)  :: nLambda, nMuMie
    type(PHASEMATRIX):: miePhase(1:nLambda, 1:nMuMie)
!    real  :: lamArray(:)
    real  :: lamArray(nLambda)
    real(oct) :: r
    real :: massEnvelope, scaleFac
    real(oct) :: totalMass
    integer :: nFreq
    integer :: i, j
    real(oct) :: freq(2000), dnu(2000), probDistJnu(2000)
!    real(oct) :: probDistPlanck(nFreq)
    real :: kappaScaReal, kappaAbsReal
    integer :: nMonte, iMonte, nScat, nAbs
    real(oct) :: thisFreq
    real(oct) :: albedo
    logical :: escaped
    real(oct) :: t1
    real(oct) :: thisLam,wavelength
    integer :: iSource
    integer :: nRemoved
    real :: Tthresh
    integer :: iLam
    integer :: nInf
    integer :: iIter, nIter
    real(oct) ::   epsOverDeltaT
    real(oct) :: meanDeltaT
    integer :: nDT, nUndersampled
    real(oct) :: totalEmission
    integer :: subcell
    real :: treal
    real(oct) :: lCore
    real      :: kabs
    type(vector) :: vec_tmp
    real :: dummy(1)
    real(oct)::  dT_sum ! [Kelvins]  the sum of the temperature change
    real(oct)::  dT_min ! [kelvins]  the minimum change of temperature
    real(oct)::  dT_max ! [kelvins]  the maximum change of temperature
    real(oct)::  dT_over_T_max ! [kelvins]  the maximum fractional change of temperature
    character(len=30) :: tfilename1, tfilename2
    logical, save :: first_time_to_open_file = .true.
    integer, parameter :: LU_OUT = 42
    integer :: iIter_grand
    real(oct)::  dT_mean_new, dT_mean_old ! [Kelvins]
    logical :: converged
    real:: percent_undersampled
    integer :: nAbs_sub, nScat_sub, nInf_sub  ! For OpenMP
    integer :: maxIter
    integer       :: imonte_beg, imonte_end  ! the index boundary for the photon loops.

!$MPI    ! For MPI implementations
!$MPI  ! For MPI implementations =====================================================
!$MPI  integer ::   my_rank        ! my processor rank
!$MPI  integer ::   n_proc         ! The number of processes
!$MPI  integer ::   ierr           ! error flag
!$MPI  integer ::   n_rmdr, m      !
!$MPI  integer ::   mphotons       ! number of photons (actual) 
!$MPI  integer ::   tempInt        !
!$MPI  real, dimension(:), allocatable :: tempRealArray
!$MPI  real, dimension(:), allocatable :: tempRealArray2
!$MPI  integer, dimension(:), allocatable :: photonBelongsRank
!$MPI  integer, parameter :: tag = 0
!$MPI  logical :: rankComplete
!$MPI    ! data space to store values from all processors
!$MPI    real, save, allocatable  :: buffer_real(:)     
!$MPI    logical, save  :: first_time = .true.
!$MPI
!!$MPI    ! find the number of the processors for the first time.    
!!$MPI    if (first_time) then
!!$MPI       call MPI_COMM_SIZE(MPI_COMM_WORLD, n_proc, ierr)
!!$MPI       allocate(buffer_real(n_proc))
!!$MPI       first_time = .false.
!!$MPI    end if
!$MPI
!$MPI
!$MPI    ! FOR MPI IMPLEMENTATION=======================================================
!$MPI    !  Get my process rank # 
!$MPI    call MPI_COMM_RANK(MPI_COMM_WORLD, my_rank, ierr)
!$MPI  
!$MPI    ! Find the total # of precessor being used in this run
!$MPI    call MPI_COMM_SIZE(MPI_COMM_WORLD, n_proc, ierr)
!$MPI    
!$MPI       allocate(buffer_real(n_proc))
!$MPI    if (my_rank .eq. 0) then
!$MPI       print *, ' '
!$MPI       print *, 'Lucy radiative equilibrium routine computed by ', n_proc, ' processors.'
!$MPI       print *, ' '
!$MPI    endif
!$MPI    
!$MPI    ! ============================================================================





    nMonte = nLucy
    nFreq = nLambda
    do i = 1, nFreq
       freq(nFreq-i+1) = cSpeed / (lamArray(i)*1.e-8)
    enddo


    do i = 2, nFreq-1
       dnu(i) = 0.5*((freq(i+1)+freq(i))-(freq(i)+freq(i-1)))
    enddo
    dnu(1) = freq(2)-freq(1)
    dnu(nFreq) = freq(nFreq)-freq(nFreq-1)

! if we are in two-D then we make a quick remap of the density grid
! to ensure that we don't have numerical effects due to sampling
! differences as a function of azimuth

    if (twoD) then
       call remapDistanceGrid(grid%octreeRoot, grid)
       call zeroDistanceGrid(grid%octreeRoot)       ! distance grid in the first instance is used to store the total cell
                                                    ! volume corresponding to the mapping of the 3d -> 2d
       call setupCellVolumes(grid%octreeRoot,grid)  ! these volumes are set up here
       call normCellVolumes(grid%octreeRoot,grid)   ! etaLine is used as a placeholder for a fractional volume in the
                                                    ! 3d to 2d mapping
    endif


! writing the grid before the iteration...
!$MPI if (my_rank==0) &
      call writeAMRgrid("lucy_grid_tmp.dat", .false., grid)


!    call setupFreqProb(temperature, freq, dnu, nFreq, ProbDistPlanck)

!$MPI    if(my_rank == 0) &
    write(*,'(a)') "Computing lucy radiative equilibrium in AMR..."


    lCore = 0.d0
    do i = 1, nSource
       lCore = lCore + source(i)%luminosity
    enddo
!$MPI    if(my_rank == 0) &
    write(*,'(a,1pe12.5)') "Total souce luminosity (lsol): ",lCore/lSol

    iIter_grand = 0
    nRemoved = 1
    converged = .false.
    dT_mean_new = 10.0d0
    dT_mean_old = 10.0d0

    do while (.not.converged)
       ! ensure we do at least three iterations
       ! before removing the high temperature cells.
       if (iIter_grand>1) then
          nIter = 1
       else
          nIter = 1
       end if

    do iIter = 1, nIter

       iIter_grand =  iIter_grand + 1  ! total number of iterations so far

       write(tfilename1, '(a,i2.2,a)') "lucy_iter_",iIter_grand,".gif/gif"
       write(tfilename2, '(a,i2.2,a)') "lucy_iter_zoom",iIter_grand,".gif/gif"

       ! Plotting the intermidiate temperature steps
!$MPI    if(my_rank == 0)  then
       call plot_AMR_values(grid, "rho", "x-z", real(grid%octreeRoot%centre%y), &
            "rho_temp_xz.ps/vcps", .true., .false., &
            0, dummy, dummy, dummy, real(grid%octreeRoot%subcellsize), .false.) 
       call plot_AMR_values(grid, "rho", "x-y", real(grid%octreeRoot%centre%y), &
            "rho_temp_xy.ps/vcps", .true., .false., &
            0, dummy, dummy, dummy, real(grid%octreeRoot%subcellsize), .false.) 
       call plot_AMR_values(grid, "temperature", "x-z", real(grid%octreeRoot%centre%y), &
            "lucy_temp_xz.ps/vcps", .true., .false., &
            0, dummy, dummy, dummy, real(grid%octreeRoot%subcellsize), .false.) 
       call plot_AMR_values(grid, "temperature", "x-z", real(grid%octreeRoot%centre%y), &
            "lucy_zoom_xz.ps/vcps", .true., .false., &
            0, dummy, dummy, dummy, real(grid%octreeRoot%subcellsize), .false.,boxfac=0.0004) 
       call plot_AMR_values(grid, "etaCont", "x-z", real(grid%octreeRoot%centre%y), &
            "etacont_zoom_xz.ps/vcps", .true., .false., &
            0, dummy, dummy, dummy, real(grid%octreeRoot%subcellsize), .false.,boxfac=0.0004) 
       call plot_AMR_values(grid, "temperature", "x-z", real(grid%octreeRoot%centre%y), &
            tfilename1, .true., .false., &
            0, dummy, dummy, dummy, real(grid%octreeRoot%subcellsize), .false.,boxfac=0.0004) 
       call plot_AMR_values(grid, "temperature", "x-z", real(grid%octreeRoot%centre%y), &
            tfilename2, .true., .false., &
            0, dummy, dummy, dummy, real(grid%octreeRoot%subcellsize), .false.,boxfac=0.0004)
       call plot_AMR_values(grid, "temperature", "x-y", real(grid%octreeRoot%centre%z), &
            "lucy_temp_xy.ps/vcps", .true., .false., &
            0, dummy, dummy, dummy, real(grid%octreeRoot%subcellsize), .false.) 
       call plot_AMR_values(grid, "temperature", "y-z", real(grid%octreeRoot%centre%x), &
            "lucy_temp_yz.ps/vcps", .true., .false., &
            0, dummy, dummy, dummy, real(grid%octreeRoot%subcellsize), .false.) 
       call polardump(grid)
!$MPI    end if

!$MPI       if (my_rank == 0) &
       call tune(6, "One Lucy Rad Eq Itr")  ! start a stopwatch
       
       call zeroDistanceGrid(grid%octreeRoot)
!$MPI       if (my_rank == 0) then
       write(*,*) " "
       write(*,*) "Iteration",iIter_grand,",",nmonte," photons"
!$MPI       end if




!$OMP PARALLEL DEFAULT(NONE) &
!$OMP PRIVATE(iMonte, iSource, thisSource, rVec, uHat, rHat) &
!$OMP PRIVATE(escaped, wavelength, thisFreq, thisLam, iLam, octVec) &
!$OMP PRIVATE(thisOctal, kappaScaReal, kappaAbsReal, albedo, r) &
!$OMP PRIVATE(vec_tmp, uNew, Treal, subcell, probDistJnu) &
!$OMP PRIVATE(kabs,i, j, T1) &
!$OMP PRIVATE(nAbs_sub, nScat_sub, nInf_sub) &
!$OMP SHARED(grid, nLambda, lamArray,miePhase, nMuMie) &
!$OMP SHARED(imonte_beg, imonte_end, source, nsource) &
!$OMP SHARED(dnu, nFreq, freq, nMonte) &
!$OMP SHARED(nAbs, nScat, nInf) 
 
       nInf_sub = 0
       nScat_sub = 0
       nAbs_sub = 0
       nInf = 0
       nScat = 0
       nAbs = 0

       imonte_beg=1; imonte_end=nMonte  ! default value

!!$MPI       ! Set the range of index for a photon loop used later.     
!!$MPI       n_rmdr = MOD(nMonte,np)
!!$MPI       m = nMonte/np
!!$MPI
!!$MPI       if (my_rank .lt. n_rmdr ) then
!!$MPI          imonte_beg = (m+1)*my_rank + 1
!!$MPI          imonte_end = imonte_beg + m
!!$MPI       else
!!$MPI          imonte_beg = m*my_rank + 1 + n_rmdr
!!$MPI          imonte_end = imonte_beg + m -1
!!$MPI       end if
!!$MPI   !    print *, ' '
!!$MPI   !    print *, 'imonte_beg = ', imonte_beg
!!$MPI   !    print *, 'imonte_end = ', imonte_end
!!$MPI  
!!$MPI      
!!$MPI       !  Just for safety.
!!$MPI       if (imonte_end .gt. nMonte .or. imonte_beg < 1) then
!!$MPI          print *, 'Index out of range: i_beg and i_end must be ' 
!!$MPI          print *, ' 0< index < ', nMonte , '    ... [lucy_mod::lucyRadiativeEquilibriumAMR]'
!!$MPI          print *, 'imonte_beg = ', imonte_beg
!!$MPI          print *, 'imonte_end = ', imonte_end
!!$MPI          stop
!!$MPI       end if




!$MPI  !====================================================================================
!$MPI  ! Splitting the innerPhoton loop for multiple processors.
!$MPI  if (my_rank == 0) then
!$MPI     print *, ' '
!$MPI     print *, 'photonLoop computed by ', n_proc-1, ' processors.'
!$MPI     print *, ' '
!$MPI  endif
!$MPI  if (my_rank == 0) then
!$MPI     ! we will use an array to store the rank of the process
!$MPI     !   which will calculate each photon
!$MPI     allocate(photonBelongsRank(nMonte))
!$MPI    
!$MPI     call mpiBlockHandout(n_proc,photonBelongsRank,blockDivFactor=40,tag=tag,&
!$MPI                          setDebug=.false.)
!$MPI     deallocate(photonBelongsRank) ! we don't really need this here. 
!$MPI  end if
!$MPI  !====================================================================================

!$MPI    
!$MPI    
!$MPI  if (my_rank /= 0) then
!$MPI    mpiBlockLoop: do  
!$MPI      call mpiGetBlock(my_rank,imonte_beg, imonte_end,rankComplete,tag,setDebug=.false.)  
!$MPI      if (rankComplete) exit mpiBlockLoop  
!$MPI    


!!$OMP DO SCHEDULE(DYNAMIC,10)
!$OMP DO SCHEDULE(STATIC,10)
       avedirection = OCTALVECTOR(0.d0, 0.d0, 0.d0)
       photonloop: do iMonte = imonte_beg, imonte_end

!$MPI !  if (MOD(i,n_proc) /= my_rank) cycle photonLoop

!$MPI !  if (MOD(i,n_proc) /= my_rank) goto 999

          call randomSource(source, nSource, iSource)
          thisSource = source(iSource)
          call getPhotonPositionDirection(thisSource, rVec, uHat,rHat)
          avedirection = avedirection + uHat
          escaped = .false.
          call getWavelength(thisSource%spectrum, wavelength)
          thisFreq = cSpeed/(wavelength / 1.e8)


          do while(.not.escaped)

!$OMP CRITICAL (tonext)
             call toNextEventAMR(grid, rVec, uHat, escaped, thisFreq, nLambda, lamArray, twoD,imonte)
!$OMP END CRITICAL (tonext)

!             write(*,*) imonte,rvec,thisFreq
!             if (iMonte == 14) stop

             If (escaped) nInf_sub = nInf_sub + 1

             if (.not. escaped) then

                thisLam = (cSpeed / thisFreq) * 1.e8
                call locate(lamArray, nLambda, real(thisLam), iLam)
                octVec = rVec 
                call amrGridValues(grid%octreeRoot, octVec, foundOctal=thisOctal, iLambda=iLam, &
                     kappaSca=kappaScaReal, kappaAbs=kappaAbsReal, grid=grid)
                if (kappaScaReal+kappaAbsReal /= 0.0) then
                   albedo = kappaScaReal / (kappaScaReal + kappaAbsReal)
                else
                   albedo = 0.5
                end if
	        albedo = min(albedo,0.9999d0)

                call random_number(r)
                if (r < albedo) then
                   vec_tmp = uhat
                   uNew = newDirectionMie(vec_tmp, real(thisLam), lamArray, nLambda, miePhase, nMuMie)
                   nScat_sub = nScat_sub + 1
                   uHat = uNew

                else
                   call amrGridValues(grid%octreeRoot, octVec, foundOctal=thisOctal, &
                        foundSubcell=subcell, temperature=treal,grid=grid)
                   t1 = dble(treal)
                   nAbs_sub = nAbs_sub + 1
                   probDistJnu(1) = 0.
                   do i = 2, nFreq
                      thisLam = (cSpeed / freq(i)) * 1.e8
                      call hunt(lamArray, nLambda, real(thisLam), iLam)
                      if ((ilam >=1).and.(ilam <= nlambda)) then

                         ! tjh added on 7/4/05 - stop direct addressing of octal kappa arrays
                         ! to allow implemntation of gas opacities...

                         call amrGridValues(grid%octreeRoot, octVec, startOctal=thisOctal, &
                              actualSubcell=subcell, kappaAbs=kabs, ilambda=ilam, grid=grid)

!                         if (.not.grid%oneKappa) then
!                            kabs = thisOctal%kappaAbs(subcell,ilam)
!                         else
!                            kabs = grid%oneKappaAbs(thisOctal%dustType(subcell),iLam) * thisOctal%rho(subcell)
!                         endif
                         probDistJnu(i) = probDistJnu(i-1) + &
                              bnu(freq(i),t1) * dble(kabs) * dnu(i)
                      endif
                   enddo
                   if (probDistJnu(nFreq) /= 0.) then
                      probDistJnu(1:nFreq) = probDistJnu(1:nFreq) / probDistJnu(nFreq)
                      call random_number(r)
                      call locate(probDistJnu, nFreq, r, j)
                      if (j == nFreq) j = nFreq -1
                      thisFreq = freq(j) + (freq(j+1) - freq(j))* &
                           (r - probDistJnu(j))/(probDistJnu(j+1)-probDistJnu(j))
                   endif
                   uHat = randomUnitVector()
                endif

             endif
          enddo

       enddo photonLoop

!$MPI    end do mpiBlockLoop  
!$MPI  end if ! (my_rank /= 0)


!$OMP END DO
!$OMP CRITICAL (update)
      nScat = nScat_sub  + nScat   ! sum from each thread for OpenMP
      nInf = nInf_sub    + nInf    ! sum from each thread for OpenMP
      nAbs = nAbs_sub    + nAbs    ! sum from each thread for OpenMP
!$OMP END CRITICAL (update)

!$OMP BARRIER
!$OMP END PARALLEL





!$MPI       ! Summing the value in octal computed by each processors.
!$MPI       ! This is a recursive function which involves the many 
!$MPI       ! comunications between processors. It may take a while....
!$MPI       ! (Maybe faster to pack the values in 1D arrays and distribute.)
!$MPI
!$MPI       if(my_rank == 0) call tune(6, "  Lucy Loop Update ")  ! start a stopwatch
!$MPI       if(my_rank == 0) write(*,*) "Calling update_octal_MPI"
!$MPI    !   call update_octal_MPI(grid%octreeRoot, grid)

!$MPI       call MPI_BARRIER(MPI_COMM_WORLD, ierr)


!$MPI       call updateGridMPI(grid)

!$MPI       if(my_rank == 0) call tune(6, "  Lucy Loop Update ")  ! stop a stopwatch
!$MPI
!$MPI       ! collect some statical info from each node.
!$MPI       call MPI_ALLGATHER(REAL(nInf), 1, MPI_REAL, buffer_real, 1, MPI_REAL, MPI_COMM_WORLD, ierr)
!$MPI       call MPI_BARRIER(MPI_COMM_WORLD, ierr)
!$MPI       nInf = INT(SUM(buffer_real))
!$MPI
!$MPI       call MPI_ALLGATHER(REAL(nScat), 1, MPI_REAL, buffer_real, 1, MPI_REAL, MPI_COMM_WORLD, ierr)
!$MPI       call MPI_BARRIER(MPI_COMM_WORLD, ierr)
!$MPI       nScat = INT(SUM(buffer_real))
!$MPI
!$MPI       call MPI_ALLGATHER(REAL(nAbs), 1, MPI_REAL, buffer_real, 1, MPI_REAL, MPI_COMM_WORLD, ierr)
!$MPI       call MPI_BARRIER(MPI_COMM_WORLD, ierr)
!$MPI       nAbs = INT(SUM(buffer_real))
!$MPI
!$MPI       
!$MPI       if(my_rank == 0) then
          write(*,'(a,f7.2)') "Photons done.",real(ninf)/real(nmonte)
          write(*,'(a,f13.3)') "Mean number of scatters per photon: ",real(nScat)/real(nMonte)
          write(*,'(a,f13.3)') "Mean number of absorbs  per photon: ",real(nAbs)/real(nMonte)
!$MPI       end if




       epsOverDeltaT = (lCore) / dble(nInf)

       meanDeltaT = 0.
       nDT = 0
       nUndersampled = 0


       totalEmission = 0.

! If we are doing the computation in 2D then we need to remap the distancegrid before
! calculating the temperature corrections

       if (twoD) then
          write(*,*) "! Remapping the distance grid attributes..."
          call remapDistanceGrid(grid%octreeRoot, grid)
          call resetDistanceGrid(grid%octreeRoot)
          write(*,*) "done."
       endif

       call calculateTemperatureCorrections(.true., grid%octreeRoot, totalEmission, epsOverDeltaT, &
       nFreq, freq, dnu, lamarray, nLambda, grid, nDt, nUndersampled,  &
       dT_sum, dT_min, dT_max, dT_over_T_max)

       if (twoD) then
          write(*,*) "! Remapping the distance grid attributes..."
          call remapDistanceGrid(grid%octreeRoot, grid)
          call resetDistanceGrid(grid%octreeRoot)
          write(*,*) "done."
       endif


       percent_undersampled  = 100.*real(nUndersampled)/real(nDt)
       dT_mean_old = dT_mean_new  ! save this for the next iteration
       dT_mean_new = dT_sum/real(nDt)





!$MPI       if (my_rank==0) then
       write(*,*) "Mean change in temperature    : ", dT_mean_new , " Kelvins"
       write(*,*) "Minimum change in temperature : ", dT_min, " Kelvins"
       write(*,*) "Maximum change in temperature : ", dT_max, " Kelvins"
      write(*,*) "Maximum fractional change in temperature : ", dT_over_T_max
       write(*,'(a,i8)') "Number of undersampled cells: ",nUndersampled
       write(*,'(a,f8.2)') "Percentage of undersampled cells: ",percent_undersampled
       write(*,*) "Emissivity of dust / core", totalEmission /lCore * 1.e30
       write(*,*) "Total emission",totalEmission

       
       !
       ! writing the info above to a file.
10     format(a3, a12, 3(2x, a12),     4(2x, a12),     (2x, a12))
11     format(3x, i12, 3(2x, 1PE12.4), 4(2x, 1PE12.4), (2x, i12))
       if (first_time_to_open_file) then
          open(unit=LU_OUT, file='convergence_lucy.dat', status='replace')
          first_time_to_open_file=.false.
          write(LU_OUT, 10) "#", "iteration", "Mean dT [K]", "Min dT [K]", "Max dT [K]", &
               "% bad cells", "Eta dust/*", "Eta Total", "Max dT/T", "nMonte"
       else
          open(unit=LU_OUT, file='convergence_lucy.dat', status='old', position='append')
       end if

       write(LU_OUT, 11) iIter_grand, dT_sum/real(nDt), dT_min, dT_max, & 
            100.*real(nUndersampled)/real(nDt), totalEmission /lCore *1.e30, &
            totalEmission, dT_over_T_max, nMonte
       
       close(LU_OUT)
!$MPI    end if   

!$MPI if (my_rank==0) &       
       call tune(6, "One Lucy Rad Eq Itr")  ! stop a stopwatch
       
    enddo



    nRemoved = 0
    if (iIter_Grand > 1) then
!$MPI if (my_rank==0) & 
       write(*,*) "Removing dust with T > Tthresh: ",Tthresh
       call removeDust(grid%octreeRoot, Tthresh, nRemoved)
    endif

!$MPI if (my_rank==0) & 
    write(*,*) "Number of cells removed: ",nRemoved

    if (grid%geometry == "wr104") then

       totalMass = 0.
       call findTotalMass(grid%octreeRoot, totalMass)
       scaleFac = massEnvelope / totalMass
!$MPI if (my_rank==0) & 
       write(*,'(a,1pe12.5)') "Density scale factor: ",scaleFac
       call scaleDensityAMR(grid%octreeRoot, scaleFac)
    endif


    !
    ! check the convergence
    !
    if (percent_undersampled>percent_undersampled_min) then
       converged = .false.
       nMonte = nMonte*2  ! increases the number of iterations!
    elseif (nRemoved > 3   &
         .or. iIter_grand < maxIter &
         .or. (dT_mean_new-dT_mean_old)/((dT_mean_new+dT_mean_old)/2.0) > 0.05) then
       converged = .false.
    else 
       converged = .true.
    end if

!    converged = .true.
!    write(*,*) "FORCING CONVERGENCE FOR TESTS!!!!"


!    !
!    ! Write grid structure to a tmp file.
!    !
!$MPI if (my_rank==0) then
      call writeAMRgrid("lucy_grid_tmp.dat", .false., grid)
!$MPI end if
       
  enddo


  end subroutine lucyRadiativeEquilibriumAMR


  subroutine setupFreqProb(temperature, freq, dnu, nFreq, probDist)

    ! Lucy 1999, A&A, 344, 282 Equation 3

    real(oct) :: temperature
    integer :: nFreq
    real(oct) :: freq(*)
    real(oct) :: probDist(*)
    real(oct) :: dnu(*)

    integer :: i


    
    probDist(1:nFreq) = 0.
    do i = 2, nFreq
       probDist(i) = probDist(i-1) + bnu(dble(freq(i)),dble(temperature)) * dnu(i)

    enddo

    probDist(1:nFreq) = probDist(1:nFreq) / probDist(nFreq)

  end subroutine setupFreqProb


 subroutine toNextEvent(grid, rVec, uHat,  escaped, distanceGrid, thisFreq, nLambda, lamArray)


   type(GRIDTYPE) :: grid
   type(OCTALVECTOR) :: rVec, uHat
   integer :: i1, i2, i3
   real(oct) :: t1, t2, t3
   real(oct) :: tval, tau, r
   real :: lamArray(*)
   integer :: nLambda
   logical :: stillinGrid
   logical :: escaped
   real(oct) :: thisTau
   real(oct) :: kabs, ksca
   real(oct) :: thisFreq
   real(oct) :: distanceGrid(1:grid%nx, 1:grid%ny, 1:grid%nz)
   real(oct) :: thisLam
   integer :: iLam

    stillinGrid = .true.
    escaped = .false.


    thisLam = (cSpeed / thisFreq) * 1.e8
    call hunt(lamArray, nLambda, real(thisLam), iLam)
    if ((ilam < 1).or.(ilam > nlambda)) then
       write(*,*) "ilam errro",ilam
    endif

    call random_number(r)
    tau = -log(r)
    call getIndices(grid, rVec, i1, i2, i3, t1, t2, t3)
    call intersectCube(grid, rVec, i1, i2, i3, uHat, tVal)

    if (.not.grid%oneKappa) then
       kabs = grid%kappaAbs(i1,i2,i3,iLam)
       ksca = grid%kappaSca(i1,i2,i3,iLam)
    else
       kabs = grid%oneKappaAbs(1,iLam) * grid%rho(i1,i2,i3)
       ksca = grid%oneKappaSca(1,iLam) * grid%rho(i1,i2,i3)
    endif

    thisTau = tVal * (kabs + ksca)

    do while(stillinGrid .and. (tau > thisTau)) 
       rVec = rVec + tVal * uHat


       if ((rVec%x > grid%xAxis(grid%nx)).or. &
           (rVec%y > grid%yAxis(grid%ny)).or. &
           (rVec%z > grid%zAxis(grid%nz)).or. &
           (rVec%x < grid%xAxis(1)).or. &
           (rVec%y < grid%yAxis(1)).or. &
           (rVec%z < grid%zAxis(1))) then
          stillinGrid = .false.
          escaped = .true.
          if (.not.grid%oneKappa) then
             kabs = grid%kappaAbs(i1,i2,i3,iLam)
          else
             kabs = grid%oneKappaAbs(1,iLam) * grid%rho(i1,i2,i3)
          endif
          distanceGrid(i1,i2,i3) = distanceGrid(i1,i2,i3) + tVal * kabs
       endif


       if (stillinGrid) then
          call random_number(r)
          tau = -log(r)
          call getIndices(grid, rVec, i1, i2, i3, t1, t2, t3)
          call intersectCube(grid, rVec, i1, i2, i3, uHat, tVal)
          if (.not.grid%oneKappa) then
             kabs = grid%kappaAbs(i1,i2,i3,iLam)
             ksca = grid%kappaSca(i1,i2,i3,iLam)
          else
             kabs = grid%oneKappaAbs(1,iLam) * grid%rho(i1,i2,i3)
             ksca = grid%oneKappaSca(1,iLam) * grid%rho(i1,i2,i3)
          endif
          thisTau = tVal * (kabs+ksca)
          if (tVal == 0.) then
             escaped = .true.
             stillingrid = .false.
          endif
       endif
    enddo

    if (.not.escaped) then
       call getIndices(grid, rVec, i1, i2, i3, t1, t2, t3)
       call intersectCube(grid, rVec, i1, i2, i3, uHat, tVal)

       if ((tVal*tau/thisTau) > 2.*(grid%xAxis(2)-grid%xAxis(1))) then
          write(*,*) "tval*tau/thistau too big", tval*tau/thisTau
       else
          if (.not.grid%oneKappa) then
             kabs = grid%kappaAbs(i1,i2,i3,iLam)
          else
             kabs = grid%oneKappaAbs(1,iLam) * grid%rho(i1,i2,i3)
          endif
          distanceGrid(i1,i2,i3) = distanceGrid(i1,i2,i3) + (tVal*tau/thisTau) * kabs
       endif
       

       if (tau > thisTau) then
          write(*,*) "tau > thistau"
          stop
       endif
       
       rVec = rVec + (tVal*tau/thisTau) * uHat
    endif




 end subroutine toNextEvent


  subroutine intersectCube(grid, posVec, i1,i2,i3,direction, tval)
   use vector_mod
   use grid_mod
   implicit none
   type(GRIDTYPE) :: grid
   type(OCTALVECTOR) :: direction
   type(OCTALVECTOR) :: posVec, norm(6), p3(6)
   real(oct) :: t(6),tval,denom(6)
   integer :: i,j
   logical :: ok, thisOk(6)
   integer :: i1, i2, i3

   ok = .true.

   norm(1) = VECTOR(1., 0., 0.)
   norm(2) = VECTOR(0., 1., 0.)
   norm(3) = VECTOR(0., 0., 1.)
   norm(4) = VECTOR(-1., 0., 0.)
   norm(5) = VECTOR(0., -1., 0.)
   norm(6) = VECTOR(0., 0., -1.)

   p3(1) = VECTOR(grid%xAxis(i1+1), 0., 0.)
   p3(2) = VECTOR(0.,grid%yAxis(i2+1),0.)
   p3(3) = VECTOR(0.,0.,grid%zAxis(i3+1))
   p3(4) = VECTOR(grid%xAxis(i1), 0., 0.)
   p3(5) = VECTOR(0.,grid%yAxis(i2),0.)
   p3(6) = VECTOR(0.,0.,grid%zAxis(i3))

   thisOk = .true.
   
   do i = 1, 6

      denom(i) = norm(i) .dot. direction
      if (denom(i) /= 0.) then
         t(i) = (norm(i) .dot. (p3(i)-posVec))/denom(i)
      else
         thisOk(i) = .false.
         t(i) = 0.
      endif
      if (t(i) < 0.) thisOk(i) = .false.
!      if (denom > 0.) thisOK(i) = .false.
 enddo




  
  j = 0
  do i = 1, 6
    if (thisOk(i)) j=j+1
  enddo

  if (j == 0) ok = .false.
   
  if (.not.ok) then
     write(*,*) i1, i2, i3
     write(*,*) direction%x,direction%y,direction%z
     write(*,*) t(1:6)
     stop
  endif

  tval = minval(t, mask=thisOk)
  tval = max(tval * 1.001d0,dble((grid%xAxis(2)-grid%xAxis(1))/1000.))


  if (tval == 0.) then
     write(*,*) i1, i2, i3,tval
     write(*,*) posVec
     write(*,*) grid%xAxis(i1),grid%yAxis(i2),grid%zAxis(i3)
     write(*,*) grid%xAxis(i1+1),grid%yAxis(i2+1),grid%zAxis(i3+1)
     write(*,*) direction%x,direction%y,direction%z
     write(*,*) t(1:6)
     stop
  endif

  if (tval > 2.*(grid%xAxis(2)-grid%xAxis(1))) then
!     write(*,*) "tval too big",tval,i1,i2,i3,posvec
!     write(*,*) "direction",direction
!     write(*,*) t(1:6)
!     write(*,*) denom(1:6)
  endif


  end subroutine intersectCube 


  recursive subroutine zeroDistanceGrid(thisOctal)
  type(octal), pointer   :: thisOctal
  type(octal), pointer  :: child 
  integer :: subcell, i
  
  do subcell = 1, thisOctal%maxChildren
       if (thisOctal%hasChild(subcell)) then
          ! find the child
          do i = 1, thisOctal%nChildren, 1
             if (thisOctal%indexChild(i) == subcell) then
                child => thisOctal%child(i)
                call zeroDistanceGrid(child)
                exit
             end if
          end do
       else
          thisOctal%distanceGrid(subcell) = 0.d0
          thisOctal%nCrossings(subcell) = 0
       endif
    enddo
  end subroutine zeroDistanceGrid


  recursive subroutine calculateTemperatureCorrections(this_is_root, thisOctal, totalEmission, &
       epsOverDeltaT, nFreq, freq, dnu, lamarray, nLambda, grid, nDt, nUndersampled,  &
       dT_sum, dT_min, dT_max, dT_over_T_max)

    logical, intent(in) :: this_is_root    ! T if thisOctal is a root node.
    real(oct) :: totalEmission
    type(octal), pointer   :: thisOctal
    type(octal), pointer  :: child 
    type(gridtype) :: grid
    integer :: subcell, i
    integer, parameter :: minCrossings = 50
    real(oct) :: V, epsOverDeltaT
    real(oct) :: adot
    real(oct) :: kappaP, norm
    real(oct) :: thisLam
    integer :: ilam, nLambda
    real(oct) :: newT, deltaT
    integer, intent(inout) :: nDt
    real(oct), intent(inout) :: dT_sum ! [Kelvins]  the sum of the temperature change
    real(oct), intent(inout) :: dT_min ! [kelvins]  the minimum change of temperature
    real(oct), intent(inout) :: dT_max ! [kelvins]  the maximum change of temperature
    ! [kelvins]  the maximum fractional change of temperature
    real(oct), intent(inout) :: dT_over_T_max 

    real :: kabs
    real :: lamArray(*)
    integer :: nFreq
    real(oct) :: freq(*)
    real(oct) :: dnu(*)
    integer :: nUndersampled
    integer, save  :: nwarning = 0
    integer, parameter :: nmaxwarning = 200000
    real(double) :: r1, r2
    type(OCTALVECTOR) :: rVec

    if(this_is_root) then !initialize some values
       dT_sum = 0.0
       dT_min = 1.0e10
       dT_max = 0.0
       nDT = 0
       dT_over_T_max = 0.0
    end if
    

    do subcell = 1, thisOctal%maxChildren
       if (thisOctal%hasChild(subcell)) then
          ! find the child
          do i = 1, thisOctal%nChildren, 1
             if (thisOctal%indexChild(i) == subcell) then
                child => thisOctal%child(i)
                call calculateTemperatureCorrections(.false., child, totalEmission, epsOverDeltaT, &
                     nFreq, freq, dnu, lamarray, nLambda, grid, nDt, nUndersampled, &
                     dT_sum, dT_min, dT_max, dT_over_T_max)
                exit
             end if
          end do
       else
          if (thisOctal%inFlow(subcell)) then
             if (thisOctal%threed) then
                v = thisOctal%subcellSize**3
             else
                rVec = subcellCentre(thisOctal,subcell)
                r1 = rVec%x-thisOctal%subcellSize/2.d0
                r2 = rVec%x+thisOctal%subcellSize/2.d0
                v = dble(pi) * (r2**2 - r1**2) * thisOctal%subcellSize
             endif
             adot = epsoverDeltaT * (thisOctal%distancegrid(subcell)/v) / 1.d30
             kappaP = 0.d0
             norm = 0.d0
             do i = 1, nFreq
                thisLam = (cSpeed / freq(i)) * 1.d8
                call hunt(lamArray, nLambda, real(thisLam), iLam)
                if ((iLam >=1) .and. (iLam <= nLambda)) then

                   ! tjh added on 7/4/05 - stop direct addressing of octal kappa arrays
                   ! to allow implemntation of gas opacities...
                   
                   call amrGridValues(grid%octreeRoot, subcellCentre(thisOctal,subcell), startOctal=thisOctal, &
                        actualSubcell=subcell, kappaAbs=kabs, ilambda=ilam, grid=grid)

!                   if (.not.grid%oneKappa) then
!                      kabs = thisOctal%kappaAbs(subcell,iLam)
!                   else
!                      kabs = grid%oneKappaAbs(thisOctal%dustType(subcell),iLam) * thisOctal%rho(subcell)
!                   endif
                   kappaP = kappaP + dble(kabs) * &
                        dble(bnu(dble(freq(i)),dble(thisOctal%temperature(subcell))))  * dble(dnu(i))
                   norm = norm + dble(bnu(dble(freq(i)),dble(thisOctal%temperature(subcell))))  * dble(dnu(i))
                endif
             enddo
             kappaP = kappaP / norm /1.d10
             
             
             if (kappaP > 1.e-25) then
                newT = dble(pi / stefanBoltz) * aDot / (dble(fourPi) * kappaP)
                newT = newT**0.25d0
             else
                newT = thisOctal%temperature(subcell)
             endif
             deltaT = newT - thisOctal%temperature(subcell)
             if ((deltaT > 10000.).and.(thisOctal%nCrossings(subcell) .ge. minCrossings)) then
                if (nwarning < nmaxwarning) then
                   write(*,*) "Warning:: deltaT > 10000 kelvins calculateTemperatureCorrections.", &
                        deltaT, thisOctal%nCrossings(subcell), &
                        modulus(subcellcentre(thisOctal,subcell))/grid%rinner,thisOctal%rho(subcell), &
                        dble(1./grid%rinner)*subcellcentre(thisOctal,subcell) 
                   write(*,*) "kappap",kappap,"adot",adot
                   nwarning = nwarning + 1
                elseif (nwarning == nmaxwarning) then
                   write(*,*) " "
                   write(*,*) " ==> Suppressing the further delatT > 1000 Kelvins  wanrning .... "
                   write(*,*) " "
                   nwarning = nwarning + 1
                else
                   continue
                end if                   
                !                write(*,*) deltaT, thisOctal%temperature(subcell), newT
                !                write(*,*) adot,kappap,thisOctal%rho(subcell)
             endif
             if (thisOctal%nCrossings(subcell) .ge. minCrossings) then
                thisOctal%temperature(subcell) = max(1.e-3,thisOctal%temperature(subcell) + real(0.8 * deltaT))
             else
                deltaT = 0.
                nUnderSampled = nUndersampled + 1
             endif
             kappaP = 0.d0
             norm = 0.d0
             do i = 1, nFreq
                thisLam = (cSpeed / freq(i)) * 1.e8
                call hunt(lamArray, nLambda, real(thisLam), iLam)
                if ((iLam >=1) .and. (iLam <= nLambda)) then
                   if (.not.grid%oneKappa) then
                      kabs = thisOctal%kappaAbs(subcell,iLam)
                   else
                   call amrGridValues(grid%octreeRoot, subcellCentre(thisOctal,subcell), startOctal=thisOctal, &
                        actualSubcell=subcell, kappaAbs=kabs, ilambda=ilam, grid=grid)
!                      kabs = grid%oneKappaAbs(thisOctal%dusttype(subcell),iLam) * thisOctal%rho(subcell)
                   endif


                   
                   kappaP = kappaP + dble(kabs) * &
                        dble(bnu(dble(freq(i)),dble(thisOctal%temperature(subcell)))) * dble(dnu(i)) 
                   norm = norm + dble(bnu(dble(freq(i)),dble(thisOctal%temperature(subcell)))) * dble(dnu(i)) 
                endif
             enddo
             kappaP = kappaP / norm / 1.e10
             thisOctal%etaCont(subcell) = fourPi * kappaP * (stefanBoltz/pi) * &
                  (thisOctal%temperature(subcell)**4)
             totalEmission = totalEmission + thisOctal%etaCont(subcell) * V
             nDT = nDT  + 1
             dT_sum = dT_sum + ABS(deltaT)
             dT_min = MIN(deltaT, dT_min)
             dT_max = MAX(deltaT, dT_max)
             if (newT>0.0) dT_over_T_max = MAX(ABS(deltaT)/newT, dT_over_T_max)
          else 
             thisOctal%etaCont(subcell) = 0.
          endif
       endif
    enddo
  end subroutine calculateTemperatureCorrections

  subroutine intersectCubeAMR(grid, posVec, direction, tval)
   implicit none
   type(GRIDTYPE), intent(in)    :: grid
   type(OCTALVECTOR), intent(in) :: posVec
   type(OCTALVECTOR), intent(in) :: direction
   real(oct), intent(out) :: tval
   !
   type(OCTALVECTOR) :: norm(6), p3(6)
   type(OCTAL),pointer :: thisOctal
   type(OCTALVECTOR) :: subcen, point
   integer :: subcell
   
   real(oct) :: t(6),denom(6)
   integer :: i,j
   logical :: ok, thisOk(6)


   point = posVec

   call amrGridValues(grid%octreeRoot, point, foundOctal=thisOctal, foundSubcell=subcell, grid=grid)
   subcen =  subcellCentre(thisOctal,subcell)
   ok = .true.

   norm(1) = OCTALVECTOR(1.0d0, 0.d0, 0.0d0)
   norm(2) = OCTALVECTOR(0.0d0, 1.0d0, 0.0d0)
   norm(3) = OCTALVECTOR(0.0d0, 0.0d0, 1.0d0)
   norm(4) = OCTALVECTOR(-1.0d0, 0.0d0, 0.0d0)
   norm(5) = OCTALVECTOR(0.0d0, -1.0d0, 0.0d0)
   norm(6) = OCTALVECTOR(0.0d0, 0.0d0, -1.0d0)

   p3(1) = OCTALVECTOR(subcen%x+thisOctal%subcellsize/2.0d0, subcen%y, subcen%z)
   p3(2) = OCTALVECTOR(subcen%x, subcen%y+thisOctal%subcellsize/2.0d0 ,subcen%z)
   p3(3) = OCTALVECTOR(subcen%x,subcen%y,subcen%z+thisOctal%subcellsize/2.0d0)
   p3(4) = OCTALVECTOR(subcen%x-thisOctal%subcellsize/2.0d0, subcen%y,  subcen%z)
   p3(5) = OCTALVECTOR(subcen%x,subcen%y-thisOctal%subcellsize/2.0d0, subcen%z)
   p3(6) = OCTALVECTOR(subcen%x,subcen%y,subcen%z-thisOctal%subcellsize/2.0d0)

   thisOk = .true.

   do i = 1, 6

      denom(i) = norm(i) .dot. direction
      if (denom(i) /= 0.0d0) then
         t(i) = (norm(i) .dot. (p3(i)-posVec))/denom(i)
      else
         thisOk(i) = .false.
         t(i) = 0.0d0
      endif
      if (t(i) < 0.) thisOk(i) = .false.
!      if (denom > 0.) thisOK(i) = .false.
 enddo

  
  j = 0
  do i = 1, 6
    if (thisOk(i)) j=j+1
  enddo

  if (j == 0) ok = .false.
   
  if (.not.ok) then
     write(*,*) "Error: j=0 (no intersection???) in lucy_mod::intersectCubeAMR. "
     write(*,*) direction%x,direction%y,direction%z
     write(*,*) t(1:6)
     stop
  endif

  tval = minval(t, mask=thisOk)
  tval = max(tval * 1.001d0,dble(thisOctal%subCellSize/1000.))


  if (tval == 0.) then
     write(*,*) posVec
     write(*,*) direction%x,direction%y,direction%z
     write(*,*) t(1:6)
     stop
  endif

  if (tval > sqrt(3.)*thisOctal%subcellsize) then
!     write(*,*) "tval too big",tval/(sqrt(3.)*thisOctal%subcellSize)
!     write(*,*) "direction",direction
!     write(*,*) t(1:6)
!     write(*,*) denom(1:6)
  endif


  end subroutine intersectCubeAMR

  subroutine intersectCubeAMR2D(grid, posVec, direction, tval)

! this is to find a cell intersection for a 2D AMR grid
! which is essentially a 2D-grid that projects into
! a 3D cylindrical coordinate system


   implicit none
   type(GRIDTYPE), intent(in)    :: grid
   type(OCTALVECTOR), intent(in) :: posVec
   type(OCTALVECTOR), intent(in) :: direction
   real(oct), intent(out) :: tval
   !
   type(OCTALVECTOR) :: norm(6), p3(6)
   type(OCTAL),pointer :: thisOctal
   type(OCTALVECTOR) :: subcen, point
   real :: dx, dz ! directions in cylindrical coords
   integer :: subcell
   real(double) :: compX, compZ,currentX,currentZ
   real(double) :: distToZBoundary, distToXboundary
   real(oct) :: r1,r2,d,cosmu,x1,x2,distTor1,distTor2, theta, mu
   integer :: i,j
   logical :: ok, thisOk(6)
   type(OCTALVECTOR) :: xHat, zHAt

   point = posVec

   call amrGridValues(grid%octreeRoot, point, foundOctal=thisOctal, foundSubcell=subcell, grid=grid)
   subcen =  subcellCentre(thisOctal,subcell)
   ok = .true.


   r1 = subcen%x - thisOctal%subcellSize/2.d0
   r2 = subcen%x + thisOctal%subcellSize/2.d0
   d = sqrt(point%x**2+point%y**2)
   xHat = VECTOR(point%x, point%y,0.d0)
   call normalize(xHat)

   cosmu =((-1.d0)*xHat).dot.direction
   call solveQuadDble(1.d0, -2.d0*d*cosmu, d**2-r2**2, x1, x2, ok)
   if (.not.ok) then
      write(*,*) "Quad solver failed in intersectcubeamr2d"
      do;enddo
   endif
   distTor2 = max(x1,x2)

   theta = asin(max(-1.d0,min(1.d0,r1 / d)))
   cosmu = xHat.dot.direction
   mu = acos(max(-1.d0,min(1.d0,cosmu)))
   distTor1 = 1.e30
   if (mu  < theta ) then
      call solveQuadDble(1.d0, -2.d0*d*cosmu, d**2-r1**2, x1, x2, ok)
      if (.not.ok) then
         write(*,*) "Quad solver failed in intersectcubeamr2d"
         do;enddo
      endif
      distTor1 = max(x1,x2)
   endif
         
   distToXboundary = min(distTor1, distTor2)


   zHat = VECTOR(0.d0, 0.d0, 1.d0)
   compZ = zHat.dot.direction
   currentZ = point%z

   if (compZ /= 0.d0 ) then
      if (compZ > 0.d0) then
         distToZboundary = (subcen%z + thisOctal%subcellsize/2.d0 - currentZ ) / compZ
      else
         distToZboundary = abs((subcen%z - thisOctal%subcellsize/2.d0 - currentZ ) / compZ)
      endif
   else
      disttoZboundary = 1.e30
   endif

   tVal = min(distToZboundary, distToXboundary)
   tval = max(tval * 1.00001d0,dble(thisOctal%subCellSize/100000.d0))
   if (tVal > 1.e29) then
      write(*,*) tVal,compX,compZ, distToZboundary,disttoxboundary
      write(*,*) "subcen",subcen
      write(*,*) "x,z",currentX,currentZ
   endif
   if (tval < 0.) then
      write(*,*) tVal,compX,compZ, distToZboundary,disttoxboundary
      write(*,*) "subcen",subcen
      write(*,*) "x,z",currentX,currentZ
   endif

  end subroutine intersectCubeAMR2D



 subroutine toNextEventAMR(grid, rVec, uHat,  escaped,  thisFreq, nLambda, lamArray, twoD, imonte)


   type(GRIDTYPE) :: grid
   type(OCTALVECTOR) :: rVec, uHat, octVec,thisOctVec,octVec2D
   type(OCTAL), pointer :: thisOctal
   type(OCTAL),pointer :: oldOctal
   type(OCTAL),pointer :: foundOctal
   integer :: subcell, isubcell
   real(oct) :: tval, tau, r
   real :: lamArray(*)
   integer :: nLambda
   logical :: stillinGrid
   logical :: escaped
   logical :: twoD
   real :: kappaScaReal, kappaAbsReal
   real(oct) :: thisTau
   real(oct) :: thisFreq
   real(oct) :: thisLam
   integer :: iLam
   logical ::inFlow
   integer :: imonte

    stillinGrid = .true.
    escaped = .false.



    thisLam = (cSpeed / thisFreq) * 1.e8
    call hunt(lamArray, nLambda, real(thisLam), iLam)
    if ((ilam < 1).or.(ilam > nlambda)) then
       write(*,*) "ilam errro",ilam
    endif

    call random_number(r)
    tau = -log(r)
    if (grid%octreeRoot%threed) then
       call intersectCubeAMR(grid, rVec, uHat, tVal)
    else
       call intersectCubeAMR2D(grid, rVec, uHat, tVal)
    endif

!    if (iMonte == 13) write(*,*) "tval",tval,uHat,rVec


    octVec = rVec
    thisOctVec = rVec
    octVec2D = projecttoXZ(octVec)

    call amrGridValues(grid%octreeRoot, octVec, iLambda=iLam,  foundOctal=thisOctal, &
         foundSubcell=subcell, kappaSca=kappaScaReal, kappaAbs=kappaAbsReal, &
         grid=grid, inFlow=inFlow)
    oldOctal => thisOctal

    if (inFlow) then
       thisTau = dble(tVal) * dble(kappaAbsReal + kappaScaReal)
    else
       thisTau = 1.0e-28
    end if

!    if (iMonte == 13) write(*,*) "thisTau",thisTau


    do while(stillinGrid .and. (tau > thisTau)) 
       rVec = rVec + tVal * uHat

       octVec = rVec

!    if (iMonte == 13) write(*,*) "octvec",octvec


       if (.not.inOctal(grid%octreeRoot, octVec)) then
          stillinGrid = .false.
          escaped = .true.
       endif





! two cases here now. in the 2D case we only update the distance grid in a single plane (y=0, x>=0)

       if (.not.twoD) then

          thisOctal%distanceGrid(subcell) = thisOctal%distanceGrid(subcell) &
               + tVal * dble(kappaAbsReal)
          thisOctal%nCrossings(subcell) = thisOctal%nCrossings(subcell) + 1
          
       else
          
          thisOctVec = subcellCentre(thisOctal,subcell)
          call find2Doctal(thisOctVec, grid, foundOctal, isubcell)
          foundOctal%distanceGrid(isubcell) = foundOctal%distanceGrid(isubcell) &
               + tVal * dble(kappaAbsReal)
          foundOctal%nCrossings(isubcell) = foundOctal%nCrossings(isubcell) + 1
       endif

       if (stillinGrid) then
          call random_number(r)
          tau = -log(r)
          call amrGridValues(grid%octreeRoot, octVec, iLambda=iLam,  foundOctal=thisOctal, &
               foundSubcell=subcell, kappaSca=kappaScaReal, kappaAbs=kappaAbsReal, &
               grid=grid, inFlow=inFlow)
          oldOctal => thisOctal
          thisOctVec = octVec
          if (grid%octreeRoot%threed) then
             call intersectCubeAMR(grid, rVec, uHat, tVal)
          else
             call intersectCubeAMR2D(grid, rVec, uHat, tVal)
          endif
          octVec = rVec

          if (inFlow) then
             thisTau = dble(tVal) * dble(kappaAbsReal + kappaScaReal)
!             if (imonte == 13) write(*,*) "inflow",tval,thisTau,thisOctal%rho(subcell)
!             if (imonte == 13) write(*,*) "inflow",kappaAbsReal,kappaScaReal
          else
             thisTau = 1.0e-28
          end if

          if (tVal == 0.0d0) then
             escaped = .true.
             stillingrid = .false.
          endif
       endif
    enddo


    if (.not.inOctal(grid%octreeRoot, octVec))  escaped = .true.

    
       

    if (.not.escaped) then
       octVec = rVec
       octVec2D = projectToXZ(octVec)
!       if (.not.inOctal(grid%octreeRoot, octVec)) then
!          write(*,*) "Error:: Photon location is out of boundaries, but its status is not ESCAPED."
!          write(*,*) "        .... [lucy_mod::toNextEventAMR]"
!          write(*,*) "octVec-centre = ",octVec-grid%octreeRoot%centre
!          write(*,*) "cell size = ",grid%octreeRoot%subcellsize
!          stop
!       endif
       if (dble(tau)/thisTau .gt. 1.d0) then
          write(*,*) "tau prob",tau,thisTau
       endif
       if (grid%octreeRoot%threed) then
          call intersectCubeAMR(grid, rVec, uHat, tVal)
       else
          call intersectCubeAMR2D(grid, rVec, uHat, tVal)
       endif
       call amrGridValues(grid%octreeRoot, octVec, startOctal=oldOctal,iLambda=iLam, &
            foundOctal=thisOctal, foundSubcell=subcell, &
            kappaAbs=kappaAbsReal,kappaSca=kappaScaReal, grid=grid, inFlow=inFlow)
       thisOctVec = octVec
       if (.not.inFlow) kappaAbsReal =0.0d0

!       if (iMonte == 13) write(*,*) "octVec in not escaped",octVec,thisTau

       if (thisTau > 1.e-30) then

          
          if (.not.twoD) then

             thisOctal%distanceGrid(subcell) = thisOctal%distanceGrid(subcell) &
                  + (dble(tVal)*dble(tau)/thisTau) * dble(kappaAbsReal)
             thisOctal%nCrossings(subcell) = thisOctal%nCrossings(subcell) + 1
          
          else
          
             thisOctVec = subcellCentre(thisOctal,subcell)
             call find2Doctal(thisOctVec, grid, foundOctal, isubcell)
             foundOctal%distanceGrid(isubcell) = foundOctal%distanceGrid(isubcell) &
                  + (dble(tVal)*dble(tau)/thisTau) * dble(kappaAbsReal)
             foundOctal%nCrossings(isubcell) = foundOctal%nCrossings(isubcell) + 1

          endif

          oldOctal => thisOctal
          
       endif

       if (tau > thisTau) then
          write(*,*) "tau > thistau"
          stop
       endif


!       ! We limit the maxiumum number of the interaction in a single
!       ! cell.  (RK modefied this part, june-11-2003)
!       !      
!       if (thisOctal%nCrossings(subcell) > 1000) then
!           thisOctal%distanceGrid(subcell) = thisOctal%distanceGrid(subcell) &
!            + tVal * dble(kappaAbsReal)
!          rVec = rVec + tVal * uHat
!          stillinGrid = .false.
!       elseif (thisTau > 1.e-30) then
          rVec = rVec + (dble(tVal)*dble(tau)/thisTau) * uHat
!       endif
    endif

 end subroutine toNextEventAMR

  recursive subroutine removeDust(thisOctal, Tthresh, nRemoved)
  type(octal), pointer   :: thisOctal
  type(octal), pointer  :: child 
  real :: Tthresh
  integer :: nRemoved
  integer :: subcell, i
  
  do subcell = 1, thisOctal%maxChildren
       if (thisOctal%hasChild(subcell)) then
          ! find the child
          do i = 1, thisOctal%nChildren, 1
             if (thisOctal%indexChild(i) == subcell) then
                child => thisOctal%child(i)
                call removeDust(child, Tthresh, nRemoved)
                exit
             end if
          end do
       else
          if (thisOctal%temperature(subcell) > Tthresh) then
             write(*,*) "cell removed with T at ",thisOctal%temperature(subcell)
             thisOctal%inFlow(subcell) = .false.
             thisOctal%etaCont(subcell) = 1.e-30
             thisOctal%rho(subcell) = 1.e-27
             thisOctal%temperature(subcell) = 1.e-3
             nRemoved = nRemoved + 1
          endif
       endif
    enddo
  end subroutine removeDust



!$MPI  !
!$MPI  ! For MPI implementation.
!$MPI  ! Updates distanceGrid and nCrossings from each octal
!$MPI  !
!$MPI  recursive subroutine update_octal_MPI(thisOctal, grid)
!$MPI    implicit none
!$MPI    include 'mpif.h'
!$MPI
!$MPI    type(gridtype) :: grid
!$MPI    type(octal), pointer   :: thisOctal
!$MPI    type(octal), pointer  :: child 
!$MPI    integer :: subcell, i
!$MPI    real :: r
!$MPI    ! data space to store values from all processors
!$MPI    real, save, allocatable  :: buffer_ncrossings(:)     
!$MPI    real(double), save, allocatable     :: buffer_distanceGrid(:) 
!$MPI    integer  :: ierr
!$MPI    integer, save  :: np  ! number of processors
!$MPI    logical, save  :: first_time = .true.
!$MPI
!$MPI    ! find the number of the processors for the first time.    
!$MPI    if (first_time) then
!$MPI       call MPI_COMM_SIZE(MPI_COMM_WORLD, np, ierr)
!$MPI       allocate(buffer_ncrossings(np))
!$MPI       allocate(buffer_distanceGrid(np))
!$MPI       first_time = .false.
!$MPI    end if
!$MPI
!$MPI
!$MPI    do subcell = 1, thisOctal%maxChildren
!$MPI       if (thisOctal%hasChild(subcell)) then
!$MPI          ! find the child
!$MPI          do i = 1, thisOctal%nChildren, 1
!$MPI             if (thisOctal%indexChild(i) == subcell) then
!$MPI                child => thisOctal%child(i)
!$MPI                call update_octal_MPI(child, grid)
!$MPI                exit
!$MPI             end if
!$MPI          end do
!$MPI       else
!$MPI          ! 
!$MPI          ! collecting the data from all the processors including itself.
!$MPI          call MPI_ALLGATHER(thisOctal%distanceGrid(subcell), 1, MPI_REAL, &
!$MPI               buffer_distanceGrid, 1, MPI_REAL, MPI_COMM_WORLD, ierr)  
!$MPI          call MPI_BARRIER(MPI_COMM_WORLD, ierr)
!$MPI          
!$MPI          
!$MPI          call MPI_ALLGATHER(REAL(thisOctal%ncrossings(subcell)), 1, MPI_REAL, &
!$MPI               buffer_ncrossings, 1, MPI_REAL, MPI_COMM_WORLD, ierr)  
!$MPI          call MPI_BARRIER(MPI_COMM_WORLD, ierr)
!$MPI          
!$MPI          thisOctal%distanceGrid(subcell) = SUM(buffer_distanceGrid)
!$MPI          thisOctal%nCrossings(subcell) = INT(SUM(buffer_ncrossings))
!$MPI          
!$MPI       endif
!$MPI    enddo
!$MPI  end subroutine update_octal_MPI


!$MPI  subroutine updateGridMPI(grid)
!$MPI    implicit none
!$MPI    include 'mpif.h'
!$MPI    type(gridtype) :: grid
!$MPI    integer :: nOctals, nVoxels
!$MPI    real, allocatable :: nCrossings(:)
!$MPI    real, allocatable :: tempRealArray(:)
!$MPI    real(double), allocatable :: distanceGrid(:),tempDoubleArray(:)
!$MPI    integer :: np, ierr,my_rank, nIndex
!$MPI
!$MPI    ! FOR MPI IMPLEMENTATION=======================================================
!$MPI    !  Get my process rank # 
!$MPI    call MPI_COMM_RANK(MPI_COMM_WORLD, my_rank, ierr)
!$MPI  
!$MPI    ! Find the total # of precessor being used in this run
!$MPI    call MPI_COMM_SIZE(MPI_COMM_WORLD, np, ierr)
!$MPI
!$MPI    call MPI_BARRIER(MPI_COMM_WORLD, ierr) 
!$MPI    nOctals = 0
!$MPI    nVoxels = 0
!$MPI    call countVoxels(grid%octreeRoot,nOctals,nVoxels)
!$MPI    allocate(nCrossings(1:nVoxels))
!$MPI    allocate(distanceGrid(1:nVoxels))
!$MPI
!$MPI    nIndex = 0
!$MPI    call packValues(grid%octreeRoot,nIndex,distanceGrid,nCrossings)
!$MPI
!$MPI
!$MPI    allocate(tempDoubleArray(nVoxels))
!$MPI    allocate(tempRealArray(nVoxels))
!$MPI
!$MPI    tempDoubleArray = 0.d0
!$MPI    call MPI_ALLREDUCE(distanceGrid,tempDoubleArray,nVoxels,MPI_DOUBLE_PRECISION,&
!$MPI         MPI_SUM,MPI_COMM_WORLD,ierr)
!$MPI    distanceGrid = tempDoubleArray 
!$MPI
!$MPI    tempRealArray = 0.0
!$MPI    call MPI_ALLREDUCE(nCrossings,tempRealArray,nVoxels,MPI_REAL,&
!$MPI         MPI_SUM,MPI_COMM_WORLD,ierr)
!$MPI    nCrossings = tempRealArray 
!$MPI    
!$MPI    deallocate(tempRealArray)
!$MPI    deallocate(tempDoubleArray)
!$MPI     
!$MPI    call MPI_BARRIER(MPI_COMM_WORLD, ierr) 
!$MPI    
!$MPI    nIndex = 0
!$MPI    call unpackValues(grid%octreeRoot,nIndex,distanceGrid,nCrossings)
!$MPI
!$MPI
!$MPI  end subroutine updateGridMPI



  subroutine find2Doctal(rVec, grid, foundOctal, subcell)
    type(GRIDTYPE) :: grid
    type(OCTALVECTOR) :: rVec, rotVec
    type(OCTAL), pointer :: foundOctal, resultOctal
    integer :: subcell
    real(oct) :: r

! This subroutine finds the location of an octal in the y=0, x>=0 plane
! that corresponds to the position vector rVec when it is rotated
! into the y=0 plane 


    rotVec%z = rVec%z     ! the new vector has the same "z" value

    r = sqrt(rVec%x**2 + rVec%y**2) ! distance from z-axis

    rotVec%y = 0.

    rotVec%x = r

! now we find the octal and subcell that rotVec lies in

    call findSubcellTD(rotVec, grid%ocTreeRoot, resultOctal, subcell)
    foundOctal => resultOctal

  end subroutine find2Doctal

  recursive subroutine remapDistanceGrid(thisOctal, grid)
    type(GRIDTYPE) :: grid
    type(OCTAL), pointer :: thisOctal, child, foundOctal, resultOctal
    type(OCTALVECTOR) :: rVec, rotVec
    real(oct) :: r
    integer :: subcell, j, isub

! this routine remaps the distance grid attribute of a two-D plane
! (which is y=0, x>=0) onto a three-D grid

    do isub = 1, thisOctal%maxChildren, 1
      if ( thisOctal%hasChild(isub) ) then
        ! if the current subcell has a child, call this subroutine on
        !   each of its children
        do j = 1, thisOctal%nchildren
          if ( thisOctal%indexchild(j) == isub ) then
            child => thisoctal%child(j)
            call remapdistancegrid(child, grid)
            exit
          end if
        end do
      else
        ! if the current subcell does not have a child, then do the remap

        rVec = subcellCentre(thisOctal, isub)

        rotVec%z = rVec%z     ! the new vector has the same "z" value
    
        r = sqrt(rVec%x**2 + rVec%y**2) ! distance from z-axis
    
        rotVec%y = 0.

        rotVec%x = r

        ! now we find the octal and subcell that rotVec lies in

        call findSubcellTD(rotVec, grid%ocTreeRoot, resultOctal, subcell)
        foundOctal=>resultOctal

! we have added the path lengths over all cells in 3d to a 2d plane. we therefore need to correct
! the path length summation by the fractional volume that this cell in the 2d plane corresponds
! to. ncrossings we keep as is - it is used in a statistical sense here.

        thisOctal%chiLine(isub) = foundOctal%distanceGrid(subcell) * foundOctal%etaLine(subcell)
        thisOctal%nCrossings(isub) = foundOctal%nCrossings(subcell)

        thisOctal%rho(isub) = foundOctal%rho(subcell)
        thisOctal%temperature(isub) = foundOctal%temperature(subcell)

      end if
    end do
  end subroutine remapDistanceGrid

  recursive subroutine setupCellVolumes(thisOctal, grid)
    type(GRIDTYPE) :: grid
    type(OCTAL), pointer :: thisOctal, child, foundOctal, resultOctal
    type(OCTALVECTOR) :: rVec, rotVec
    real(oct) :: r
    integer :: subcell, j, isub

! this routine remaps the distance grid attribute of a two-D plane
! (which is y=0, x>=0) onto a three-D grid

    do isub = 1, thisOctal%maxChildren, 1
      if ( thisOctal%hasChild(isub) ) then
        ! if the current subcell has a child, call this subroutine on
        !   each of its children
        do j = 1, thisOctal%nchildren
          if ( thisOctal%indexchild(j) == isub ) then
            child => thisoctal%child(j)
            call setupCellVolumes(child, grid)
            exit
          end if
        end do
      else
        ! if the current subcell does not have a child, then do the remap

        rVec = subcellCentre(thisOctal, isub)

        rotVec%z = rVec%z     ! the new vector has the same "z" value
    
        r = sqrt(rVec%x**2 + rVec%y**2) ! distance from z-axis
    
        rotVec%y = 0.

        rotVec%x = r

        ! now we find the octal and subcell that rotVec lies in

        call findSubcellTD(rotVec, grid%ocTreeRoot, resultOctal, subcell)
        foundOctal=>resultOctal

        foundOctal%distanceGrid(subcell) = foundOctal%distanceGrid(subcell) + thisOctal%subcellsize**3
        foundOctal%nCrossings(subcell) = foundOctal%nCrossings(subcell) + 1

      end if
    end do
  end subroutine setupCellVolumes


  recursive subroutine normCellVolumes(thisOctal, grid)
    type(GRIDTYPE) :: grid
    type(OCTAL), pointer :: thisOctal, child, foundOctal, resultOctal
    type(OCTALVECTOR) :: rVec, rotVec
    real(oct) :: r
    integer :: subcell, j, isub

! this routine remaps the distance grid attribute of a two-D plane
! (which is y=0, x>=0) onto a three-D grid

    do isub = 1, thisOctal%maxChildren, 1
      if ( thisOctal%hasChild(isub) ) then
        ! if the current subcell has a child, call this subroutine on
        !   each of its children
        do j = 1, thisOctal%nchildren
          if ( thisOctal%indexchild(j) == isub ) then
            child => thisoctal%child(j)
            call normCellVolumes(child, grid)
            exit
          end if
        end do
      else
        ! if the current subcell does not have a child, then do the remap

        rVec = subcellCentre(thisOctal, isub)

        rotVec%z = rVec%z     ! the new vector has the same "z" value
    
        r = sqrt(rVec%x**2 + rVec%y**2) ! distance from z-axis
    
        rotVec%y = 0.

        rotVec%x = r

        ! now we find the octal and subcell that rotVec lies in

        call findSubcellTD(rotVec, grid%ocTreeRoot, resultOctal, subcell)
        foundOctal=>resultOctal

! etaline is used as a placeholder here. it corresponds to the fractional volume occupied by the cell in
! the 2d plane compared to the total volume of the 3d space

        thisOctal%etaLine(isub) = thisOctal%subcellsize**3 / foundOctal%distanceGrid(subcell)

      end if
    end do
  end subroutine normCellVolumes

  recursive subroutine resetDistanceGrid(thisOctal)
  type(octal), pointer   :: thisOctal
  type(octal), pointer  :: child 
  integer :: subcell, i
  
  do subcell = 1, thisOctal%maxChildren
       if (thisOctal%hasChild(subcell)) then
          ! find the child
          do i = 1, thisOctal%nChildren, 1
             if (thisOctal%indexChild(i) == subcell) then
                child => thisOctal%child(i)
                call resetDistanceGrid(child)
                exit
             end if
          end do
       else
          thisOctal%distanceGrid(subcell) = thisOctal%chiline(subcell) 
       endif
    enddo
  end subroutine resetDistanceGrid

  recursive subroutine packvalues(thisOctal,nIndex,distanceGrid,nCrossings)
  type(octal), pointer   :: thisOctal
  type(octal), pointer  :: child 
  real(double) :: distanceGrid(:)
  real :: nCrossings(:)
  integer :: nIndex
  integer :: subcell, i
  
  do subcell = 1, thisOctal%maxChildren
       if (thisOctal%hasChild(subcell)) then
          ! find the child
          do i = 1, thisOctal%nChildren, 1
             if (thisOctal%indexChild(i) == subcell) then
                child => thisOctal%child(i)
                call packvalues(child,nIndex,distanceGrid,nCrossings)
                exit
             end if
          end do
       else
          nIndex = nIndex + 1
          distanceGrid(nIndex) = thisOctal%distanceGrid(subcell)
          nCrossings(nIndex) = real(thisOctal%nCrossings(subcell))
       endif
    enddo
  end subroutine packvalues

  recursive subroutine unpackvalues(thisOctal,nIndex,distanceGrid,nCrossings)
  type(octal), pointer   :: thisOctal
  type(octal), pointer  :: child 
  real(double) :: distanceGrid(:)
  real :: ncrossings(:)
  integer :: nIndex
  integer :: subcell, i
  
  do subcell = 1, thisOctal%maxChildren
       if (thisOctal%hasChild(subcell)) then
          ! find the child
          do i = 1, thisOctal%nChildren, 1
             if (thisOctal%indexChild(i) == subcell) then
                child => thisOctal%child(i)
                call unpackvalues(child,nIndex,distanceGrid,nCrossings)
                exit
             end if
          end do
       else
          nIndex = nIndex + 1
          thisOctal%distanceGrid(subcell) = distanceGrid(nIndex)
          thisOctal%nCrossings(subcell) = int(nCrossings(nIndex))
       endif
    enddo
  end subroutine unpackvalues



end module lucy_mod

#ifdef CMFATOM
module cmf_mod

  ! written by tjh


  use kind_mod
  use constants_mod
  use messages_mod
  use vector_mod
  use octal_mod, only: octal, octalWrapper, subcellCentre
  use amr_mod, only: inOctal, distanceToCellBoundary, findsubcellLocal, amrGridVelocity
  use gridtype_mod, only: GRIDTYPE
  use utils_mod, only: gaussj, locate, toPerAngstrom
  use random_mod
  use modelatom_mod, only: MODELATOM, BoltzSahaGeneral, bfOpacity, bfEmissivity, photoCrossSection, collisionRate, &
        addcrosssectionstoatom, createcontfreqarray, createrbbarrays, returneinsteincoeffs, boltzSahaEquationAbsolute, &
        sahaEquationNextIon, returnNe
  use source_mod, only: SOURCETYPE, I_nu, insideSource, distanceToSource
  use surface_mod, only: getElement
  use timing, only: tune
  use parallel_mod, only: torus_mpi_barrier
  use vtk_mod, only: writeVtkfile
  use octal_mod, only : allocateAttribute
  implicit none

  private
  public:: atomLoop, calculateAtomSpectrum, checkVelocityInterp

contains

  subroutine solveLevels(grid, source, thisOctal, subcell, nPops, jnuLine,  &
       temperature, nAtom, thisAtom, ne, rho, jnuCont, freq, dfreq, nfreq, sobolevApprox)
!    use inputs_mod, only : debug
    use inputs_mod, only : opticallyThickContinuum
    type(GRIDTYPE) :: grid
    type(SOURCETYPE) :: source(:)
    type(OCTAL), pointer :: thisOctal
    integer :: subcell
    logical :: sobolevApprox
    integer :: nFreq, ifreq
    integer :: num(100)
    real(double) :: freq(:), dfreq(:), jnuCont(:)
    real(double), allocatable :: hCgsFreq(:)
    real(double) :: nPops(:,:)
    real(double) :: temperature, ne
    real(double) :: jnuLine(:)
    type(MODELATOM) :: thisAtom(:)
    real(double), allocatable :: matrixA(:,:), matrixB(:)
!    integer, allocatable :: indx(:)
!    real(double), allocatable :: vMatrix(:,:), wMatrix(:,:), xMatrix(:)
!    real(double) :: wMax, wMin
!    real(double) :: d 
    real(double) :: boltzFac
    integer :: nLevels
    integer :: i
    integer :: itrans, l, k
    real(double) :: collEx, colldeEx
    real(double) :: a, Bul, Blu
    real(double) :: photoRatelk, recombRatekl, xSection, xSection2
    real(double) :: rho
    real(double) :: NstarRatio, totRecomb, totPHotoIon, totcion
    real(double) :: tot1, tot2
    real(double) :: nuStart !,thisFreq,test
    integer :: iStart
    integer :: iJnu
    real(double) :: jnu, jnusob
    real(double) :: radtot, colltot
    integer :: nAtom, iAtom, nMatrix
    integer, allocatable :: nOffset(:)
    logical, allocatable :: continuumGround(:)
    integer, allocatable :: nCons(:)
    logical :: ok
    integer :: nDifferentElements

    real(double) :: rate01, rate02, rate03, rate04
    real(double) :: inu_times_betacmn, betamn

    rate01 = 0.d0
    rate02 = 0.d0
    rate03 = 0.d0
    rate04 = 0.d0

!    r = modulus(subcellCentre(thisOctal,subcell))

!    eps =  (r - rcore)/(49.*rcore)

!    if (r < 5.*rCore) eps = 0.

    blu = 0.d0; bul = 0.d0; a = 0.d0; ok = .true.
    nDifferentElements = 0
    do iAtom = 1, nAtom
       if (iAtom /= nAtom) then
          if (thisAtom(iAtom)%nz /= thisAtom(iAtom+1)%nz) then ! if next atom is different element
             nDifferentElements = nDifferentElements + 1
          else
             nDifferentElements = nDifferentElements + 1
          endif
       endif
    enddo

    allocate(nOffset(1:nAtom))
    allocate(nCons(1:nAtom))
    allocate(continuumGround(1:nAtom))
    allocate(hCgsFreq(1:nFreq))
    hCgsFreq(1:nFreq) = hCgs * freq(1:nFreq)
    continuumGround = .false.

    nMatrix = 0
    nOffset(1) = 0
    nCons = 0
    do iAtom = 1, nAtom
       if (iAtom /= nAtom) then
          if (thisAtom(iAtom)%nz /= thisAtom(iAtom+1)%nz) then ! if next atom is different element
             nMatrix = nMatrix + thisAtom(iAtom)%nLevels 
             nCons(iAtom) = nMatrix
!             nMatrix = nMatrix + 1  
             nOffset(iAtom+1) = nMatrix
          else
             nMatrix = nMatrix + thisAtom(iAtom)%nLevels-1  ! continuum state of this atom is ground state of next
             continuumGround(iAtom) = .true.
             nOffset(iAtom+1) = nMatrix
             nCons(iAtom) = -1
          endif
       else
          nMatrix = nMatrix + thisAtom(iAtom)%nLevels  ! last atom
!          nMatrix = nMatrix + 1      ! TJH 1/6/11 
          nCons(iAtom) = nMatrix     ! TJH 1/6/11  
       endif
    enddo


    allocate(matrixA(1:nMatrix,1:nMatrix))
    allocate(matrixB(1:nMatrix))


    matrixA = 0.d0
    matrixB = 0.d0



    do i = 1, nMatrix
       num(i) = i
    enddo




    do iAtom = 1, nAtom

       colltot = 0.d0
       radtot = 0.d0

       nLevels = thisAtom(iAtom)%nLevels

       ! recombination rates

       do iTrans = 1, thisAtom(iAtom)%nTrans
          totRecomb = 0.d0
          tot1 = 0.d0
          tot2 = 0.d0

          k = thisAtom(iAtom)%iUpper(iTrans)
          l = thisAtom(iAtom)%iLower(iTrans)

          NstarRatio = boltzSahaGeneral(thisAtom(iAtom),  l, ne, temperature)
          

          if ((thisAtom(iAtom)%transType(iTrans) == "RBF").and.&
               (.not.thisAtom(iAtom)%inDetailedBalance(iTrans)))  then ! radiative recomb

             recombratekl = 0.d0
             nuStart = (thisAtom(iAtom)%iPot - thisAtom(iAtom)%energy(l))*evtoerg/hcgs

             call locate(freq, nfreq, nuStart, istart)


             do i = istart+2, nFreq
                xSection = photoCrossSection(thisAtom(iAtom), l, freq(i-1))
                xSection2 = photoCrossSection(thisAtom(iAtom), l, freq(i))

                recombRatekl = recombRatekl + &
                     0.5 * ( (fourPi/(hCgs*freq(i-1)))*xSection*((2.d0*hCgs*freq(i-1)**3)/cSpeed**2  + jnuCont(i-1)) * &
                     exp(-(hCgs*freq(i-1))/(kErg*temperature)) + &
                             (fourPi/(hCgs*freq(i)))*xSection2*((2.d0*hCgs*freq(i)**3)/cSpeed**2  + jnuCont(i)) * &
                     exp(-(hCgs*freq(i))/(kErg*temperature)) )*dfreq(i)
!                write(*,*) i, real(1.e8*cspeed/freq(i-1))," recomb ",recombratekl,&
!                     real((2.d0*hCgs*freq(i-1)**3)/cSpeed**2),real(jnuCont(i-1))
             enddo


!             if ((thisAtom(iatom)%name=="HeII").and.(l==1)) recombratekl = recombratekl * eps


!             if ((thisAtom(iatom)%name=="HeII").and.(l==2)) write(*,*) "Radiative recomb into level 2: ", &
!                  Nstarratio*recombratekl*npops(iatom,k)

!             if (thisAtom(iatom)%name == "HeII") write(*,*) "Radiative recomb out of continuum ", &
!                  Nstarratio*recombratekl*npops(iatom,k)

             if ((thisAtom(iatom)%name == "HeII")) then 
                if (l==2) rate03 = rate03 + Nstarratio*recombratekl*npops(iatom,k)
!                if (l==2) write(*,'(a,1p,e10.2)') "Rad ",Nstarratio*recombratekl*npops(iatom,k)
             endif


             matrixA(l + noffset(iatom), k+nOffset(iAtom)) = matrixA(l + noffset(iatom), k+nOffset(iAtom)) + &
                  NstarRatio * recombratekl
             matrixA(k+nOffset(iAtom),k+nOffset(iAtom)) = matrixA(k+nOffset(iAtom),k+nOffset(iAtom)) &
                  - NstarRatio * recombratekl 


             tot1 = tot1  + NstarRatio * recombratekl

!             if ((l == 1).and.iatom==2) then
!                write(*,*) "rad recomb to ground state ",nStarRatio * recombratekl * npops(iatom, k+nOffset(iatom))
!             endif


             radtot = radtot + tot1 * ne 

          endif


          if (thisAtom(iAtom)%transType(iTrans) == "CBF") then ! collisional recomb
             collEx = collisionRate(thisAtom(iAtom), iTrans, temperature)


!             if ((thisAtom(iatom)%name=="HeII").and.(l==2)) write(*,*) "Collisional recomb into level 2: ", &
!                  Nstarratio*collex*ne*npops(iatom,k)


             if ((thisAtom(iatom)%name == "HeII")) then 
                if (l==2) then
                   rate03 = rate03 + Nstarratio*collex*npops(iatom,k)
!                   write(*,'(a,1p,e10.2)') "N(HeIII) ",npops(iatom,k)
!                   write(*,'(a,1p,e10.2)') "Nstar ",nStarRatio*npops(iatom,k)
!                   write(*,'(a,1p,e10.2)') "Coll ",Nstarratio*collex*npops(iatom,k)
                endif
             endif



             matrixA(l + noffset(iatom), k+nOffset(iAtom)) = matrixA(l + noffset(iatom), k+nOffset(iAtom)) + &
                  NstarRatio * collex * ne

             matrixA(k+nOffset(iAtom),k+nOffset(iAtom)) = matrixA(k+nOffset(iAtom),k+nOffset(iAtom)) - NstarRatio*collEx*ne



             tot2 = tot2 + NstarRatio*collEx*ne


             colltot = colltot + tot2 * ne

          
          endif


!          totRecomb =  tot1 + tot2
!          if (thisAtom(iAtom)%transType(iTrans)(2:3) == "BF") then
!             matrixA(k+nOffset(iAtom), k+nOffset(iAtom)) = matrixA(k+nOffset(iAtom), k+nOffset(iAtom))-totRecomb
!          endif


       enddo



       do iTrans = 1, thisAtom(iAtom)%nTrans
          totPhotoIon = 0.d0
          totcion = 0.d0

          k = thisAtom(iAtom)%iUpper(iTrans)
          l = thisAtom(iAtom)%iLower(iTrans)



          if (thisAtom(iAtom)%transType(iTrans) == "RBB") then ! radiative BB rates
             iJnu = thisAtom(iAtom)%indexRBBTrans(iTrans)
             call returnEinsteinCoeffs(thisAtom(iAtom), iTrans, a, Bul, Blu)



             call locate(freq, nfreq, thisAtom(iatom)%transFreq(itrans), istart)

             jnu = jNuLine(iJnu)


             if (.not.thisAtom(iAtom)%inDetailedBalance(iTrans)) then
                

!                if ((thisAtom(iatom)%name=="HeII").and.(l==2)) write(*,*) "Rad bound-bound out of  level 2: ", &
!                    (Blu * jnu) * npops(iatom,l)
!                if ((thisAtom(iatom)%name=="HeII").and.(k==2)) write(*,*) "Rad bound-bound into level 2 (lyman alpha): ", &
!                    (Blu * jnu) * npops(iatom,l)
!                if ((thisAtom(iatom)%name=="HeII").and.(k==2)) then 
!                   write(*,*) "Rad bound-bound out of   level 2 (ly alpha): ", &
!                        (Bul * jnu + a )*npops(iatom,k), blu*jnu,a
!                endif
!                if ((thisAtom(iatom)%name=="HeII").and.(l==2)) write(*,*) "Rad bound-bound into  level 2 (recomb cascade): ", &
!                    (Bul * jnu + a )*npops(iatom,k) 
!
!                if ((thisAtom(iatom)%name=="HeII").and.(l==2)) write(*,*) "Bul ",Bul * jnu, " a ",a

                if ((thisAtom(iatom)%name == "HeII")) then
                   if ((l==1).and.(k==2)) then
!                      write(*,*) "Bul ", Bul
!                      write(*,*) "Blu" , blu
!                      write(*,*) "a ",a
!                      write(*,*) "jnu ",jnu
                   endif
                endif
 
                if ((thisAtom(iatom)%name == "HeII")) then
                   if (k==2) rate01 = rate01 + (npops(iatom,l) * blu * jnu - npops(iatom,k) * bul * jnu)
                   if (k==2) rate01 = rate01 - npops(iatom,k) * a
                endif

                if ((thisAtom(iatom)%name == "HeII")) then
                   if (l==2) rate02 = rate02 + npops(iatom,k) * a
                   if (l==2) rate02 = rate02 - (npops(iatom,l) * blu * jnu - npops(iatom,k) * bul * jnu)
                endif

                betamn = 1.d0

                
                if (sobolevApprox) then
                   call getSobolevJnuLine(grid, thisOctal, subcell, iatom, itrans, thisAtom, &
                        source(1), inu_times_betacmn, betamn, jnusob)
!                   write(*,*) "jnu cmf ",jnu
!                   write(*,*) "jnu sob ",jnusob
!                   write(*,*) " "
                   Jnu = inu_times_betacmn
                   if (opticallyThickContinuum) then
                      call locate(freq, nfreq, thisAtom(iatom)%transFreq(itrans), ifreq)
                      jnu = betamn * jnucont(ifreq)
                   endif
                endif


                matrixA(k+nOffset(iAtom),k+nOffset(iAtom)) = matrixA(k+nOffset(iAtom),k+nOffset(iAtom)) - Bul * jnu - a * betamn
                matrixA(l+nOffset(iAtom),l+nOffset(iAtom)) = matrixA(l+nOffset(iAtom),l+nOffset(iAtom)) - Blu * jnu
                matrixA(k+nOffset(iAtom),l+nOffset(iAtom)) = matrixA(k+nOffset(iAtom),l+nOffset(iAtom)) + Blu * jnu
                matrixA(l+nOffset(iAtom),k+nOffset(iAtom)) = matrixA(l+nOffset(iAtom),k+nOffset(iAtom)) + Bul * jnu + a * betamn

!                matrixA(k+nOffset(iAtom),k+nOffset(iAtom)) = matrixA(k+nOffset(iAtom),k+nOffset(iAtom)) - Bul * jnu - a
!                matrixA(l+nOffset(iAtom),l+nOffset(iAtom)) = matrixA(l+nOffset(iAtom),l+nOffset(iAtom)) - Blu * jnu
!                matrixA(k+nOffset(iAtom),l+nOffset(iAtom)) = matrixA(k+nOffset(iAtom),l+nOffset(iAtom)) + Blu * jnu
!                matrixA(l+nOffset(iAtom),k+nOffset(iAtom)) = matrixA(l+nOffset(iAtom),k+nOffset(iAtom)) + Bul * jnu + a


             endif

          endif

          if (thisAtom(iAtom)%transType(iTrans) == "CBB") then ! collision BB  rates


             collEx = collisionRate(thisAtom(iAtom), iTrans, temperature)


             boltzFac =  exp(-abs(thisAtom(iAtom)%energy(k)-thisAtom(iAtom)%energy(l)) / (kev*temperature))
             colldeEx = collEx / (boltzFac * thisAtom(iAtom)%g(k)/thisAtom(iAtom)%g(l))


!             if ((thisAtom(iatom)%name=="HeII").and.(l==2)) write(*,*) "Col bound-bound out of  level 2: ", &
!                  (collex+colldeex) * ne *npops(iatom,l)
!             if ((thisAtom(iatom)%name=="HeII").and.(k==2)) write(*,*) "Col bound-bound into level 2: ", &
!                  (collex+colldeex) * ne * npops(iatom,k)
	

             if ((thisAtom(iatom)%name == "HeII")) then 
                if (k==2) rate01 = rate01 + ne * (npops(iatom,l) * collex - npops(iatom,k) * colldeex)
             endif

             if ((thisAtom(iatom)%name == "HeII")) then 
                if (l==2) rate02 = rate02 + ne * (npops(iatom,k) * colldeex - npops(iatom,l) * collex)
             endif

             matrixA(k+nOffset(iAtom),k+nOffset(iAtom)) = matrixA(k+nOffset(iAtom),k+nOffset(iAtom)) - colldeex * ne
             matrixA(l+nOffset(iAtom),l+nOffset(iAtom)) = matrixA(l+nOffset(iAtom),l+nOffset(iAtom)) - collex * ne
             matrixA(k+nOffset(iAtom),l+nOffset(iAtom)) = matrixA(k+nOffset(iAtom),l+nOffset(iAtom)) + collex * ne
             matrixA(l+nOffset(iAtom),k+nOffset(iAtom)) = matrixA(l+nOffset(iAtom),k+nOffset(iAtom)) + colldeex * ne



          endif

          ! now do bound-free rates



          if (thisAtom(iAtom)%transType(iTrans) == "RBF") then ! photoionization

             if (.not.thisAtom(iAtom)%inDetailedBalance(iTrans)) then


                nuStart = (thisAtom(iAtom)%iPot - thisAtom(iAtom)%energy(l))*evtoerg/hcgs

                call locate(freq, nfreq, nuStart, istart)
                
                photoRatelk = 0.d0
                do i = istart+2, nFreq
                   xSection = photoCrossSection(thisAtom(iAtom), l, freq(i-1))
                   xSection2 = photoCrossSection(thisAtom(iAtom), l, freq(i))
                   photoRatelk = photoRatelk + 0.5d0 * ((jnuCont(i-1)/(hCgsfreq(i-1)))*xSection &
                        + (jnuCont(i)/(hCgsfreq(i)))*xSection2) * dfreq(i)
!                   write(*,*) i, real(1.e8*cspeed/freq(i)),real(jnucont(i)),real(photoratelk)
                enddo

                photoRatelk = photoRatelk * fourPi

!                if ((thisAtom(iatom)%name=="HeII").and.(l==1)) photoRatelk = photoRatelk * eps

!
!             if (thisAtom(iatom)%name == "HeII") write(*,*) "Photoion into continuum ", &
!                  photoRatelk * npops(iatom,l)

                
                if ((thisAtom(iatom)%name == "HeII")) then 
                   if (l==2) rate04 = rate04 - photoRatelk * npops(iatom,l)

                endif

!                photoRatelk = tiny(photoratelk)

                matrixA(l+nOffset(iAtom),l+nOffset(iAtom)) = matrixA(l+nOffset(iAtom),l+nOffset(iAtom)) - photoRatelk
                matrixA(k+nOffset(iAtom),l+nOffset(iAtom)) = matrixA(k+nOffset(iAtom),l+nOffset(iAtom)) + photoRatelk
                totphotoion=totphotoion + photoRatelk

             endif




          endif

          if (thisAtom(iAtom)%transType(iTrans) == "CBF") then ! collisional ionization

             k = thisAtom(iAtom)%iUpper(iTrans)
             l = thisAtom(iAtom)%iLower(iTrans)


             collEx = collisionRate(thisAtom(iAtom), iTrans, temperature)

             
             if ((thisAtom(iatom)%name == "HeII")) then 
                if (l==2) rate04 = rate04 - npops(iatom,l) * collex * ne
             endif

!             if ((thisAtom(iatom)%name=="HeII").and.(l==2)) write(*,*) "Coll ion out of  level 2: ", collex*ne*npops(iatom,l)



             matrixA(l+nOffset(iAtom),l+nOffset(iAtom)) = matrixA(l+nOffset(iAtom),l+nOffset(iAtom)) - collex * ne
             matrixA(k+nOffset(iAtom),l+nOffset(iAtom)) = matrixA(k+nOffset(iAtom),l+nOffset(iAtom)) + collex * ne
             totcion = totcion + collex*ne

             
          endif


       enddo


!       if (iatom == 2) write(*,*) "total photoionization: " , totphotoion, totcion

    enddo



    do iAtom = 1, nAtom
       if (nCons(iAtom) /= 0) then
          if (.not.continuumGround(iAtom)) then
             matrixA(nCons(iAtom),1+nOffset(iAtom):nOffset(iAtom)+thisAtom(iAtom)%nLevels) = 1.d0
             matrixB(nCons(iAtom)) = thisOctal%atomAbundance(subcell,iAtom) * rho
          else
             do i = iAtom, nAtom
                if (nCons(i) /= -1) exit
             enddo
             matrixA(nCons(i),1+nOffset(iAtom): nOffset(iAtom)+thisAtom(iAtom)%nLevels-1) = 1.d0
          endif
       endif
    enddo

!    write(*,'(a,1p,3e10.2)') "N(HeII) ",npops(3,1:3)
!    write(*,'(a,1p,5e10.2)') "Rates ",rate01, rate02, rate03, rate04, rate01+rate02+rate03+rate04
!
!       write(*,'(4x,100i9)') num(1:nMatrix)
!       do i = 1, nMatrix
!          write(*,'(i4,1p,100e9.1)') i,matrixA(i,1:nMatrix),matrixB(i)
!       enddo

    !    call luSlv(matrixA, matrixB, nMatrix)
    call GAUSSJ(matrixA, nMatrix, nMatrix, matrixB, 1, nMatrix, ok)

    !    allocate(indx(1:nMatrix))
    !    call ludcmp(matrixA, nMatrix, nMatrix, indx, d)
    !    call lubksb(matrixA, nMatrix, nMatrix, indx, matrixB)
    !    deallocate(indx)

    !    allocate(wMatrix(1:nMatrix,1:nMatrix))
    !    allocate(vMatrix(1:nMatrix,1:nMatrix))
    !    allocate(xMatrix(1:nMatrix))
    !    call svdcmp(matrixA, nMatrix, nMatrix, nMatrix, nMatrix, wMatrix, vMatrix)
    !    wMax = maxval(wMatrix)
    !    wMin = 1.d-13 * wMax
    !    where (wMatrix < wMin)
    !       wMatrix = 0.d0
    !    end where
    !    call svbksb(matrixA, Wmatrix, vMatrix, nMatrix, nMatrix, nMatrix, nMatrix, matrixB, xmatrix)
    !    matrixB = xmatrix
    !    deallocate(wmatrix,vmatrix, xmatrix)


    do iAtom = 1, nAtom
       nPops(iAtom,1:thisAtom(iAtom)%nLevels) = matrixB(1+nOffset(iAtom):thisAtom(iatom)%nLevels+nOffset(iAtom))
       if (continuumGround(iatom)) npops(iAtom,thisAtom(iatom)%nlevels) = matrixB(1+nOffset(iatom+1))
!       write(*,*) "iatom ",iatom, continuumGround(iatom)
    enddo
    deallocate(matrixA, matrixB)


!    if (debug) then
!       do iAtom = 1, nAtom
!          write(*,*) trim(thisAtom(iAtom)%name),SUM(nPops(iAtom,1:thisAtom(iAtom)%nLevels-1))
!          write(*,*) trim(thisAtom(iAtom)%name)//"I",nPops(iAtom,thisAtom(iAtom)%nLevels)
!       enddo
!       write(*,*) "Ne",ne,rho/mhydrogen
!    endif
    deallocate(hCgsFreq)
  end subroutine solveLevels


  subroutine getRay(grid, fromOctal, fromSubcell, position, direction, rayDeltaV, ds, phi, i0, &
       hCol, HeIcol, HeIIcol, nAtom, thisAtom, source, nSource, &
       hitPhotosphere, sourceNumber, cosTheta, weightFreq, weightOmega, &
       nRBBTrans, indexRBBTrans, indexAtom, &
       nFreq, freq, iCont, sobolevApprox, fracRay)
    use inputs_mod, only : opticallyThickContinuum, nLambda, mie, holeRadius
    use amr_mod, only: randomPositionInCell, returnKappa
    use utils_mod, only : findIlambda
    use atom_mod, only : bnu
    type(SOURCETYPE) :: source(:)
    logical :: sobolevApprox
    real(double) :: rayDeltaV
    integer :: nfreq
    real(double) :: freq(:)
    real(double) :: iCont(:)
    real(double) :: fracRay
    integer :: nAtom
    integer :: nSource
    integer :: nRBBTrans, indexRBBTrans(:), indexAtom(:)
    type(MODELATOM) :: thisAtom(:)
    type(GRIDTYPE) :: grid
    type(OCTAL), pointer :: thisOctal, startOctal, fromOctal
    integer :: fromSubcell
    integer :: subcell
    real(double) :: ds, phi, i0(:), r, cosTheta
    real(double) :: Hcol, HeICol, HeIICol
    integer :: iTrans
    type(VECTOR) :: position, direction, currentPosition, thisPosition, thisVel
    type(VECTOR) :: rayVel, startVel, endVel, endPosition, pvec, photoDirection
    real(double) :: alphanu, snu, jnu
    integer :: iLower , iUpper
    real(double) :: dv, deltaV
    integer :: i
    real(double), allocatable :: distArray(:)
    real(double) :: tval
    integer :: nTau
    real(double) :: nLower, nUpper
    real(double) :: dTauCont, etaline
    real(double), allocatable :: dTau(:)
    real(double), allocatable :: tau(:)
    real(double) :: intensityIntegral
    real(double) :: dvAcrossCell, projVel
    integer :: iCount
    real(double) :: a, blu, bul
    real(double) :: distTosource, totDist
    integer :: sourceNumber
    logical :: hitPhotosphere, hitSource
    real(double) :: dv1, dv2
    real(double) :: weightFreq
    real(double) :: weightOmega
    integer :: iAtom, iRBB
    real(double) :: phiAv, phiNorm
    logical :: firstSubcell
    integer :: nBug
    integer :: iFreq
    integer :: iElement
    integer :: j
    real(double), allocatable :: tauCont(:), jnuCont(:), alphanuCont(:), snuCont(:)
    real(double), allocatable :: tauStep(:), iStep(:), tauTmp(:)
    logical, save :: firstWarning = .true.
    logical, save :: firstTime = .true.
    real(double) :: nStar(5,40)
    logical :: passThroughResonance, ok, hitDisc
    real(double) :: deltaDist, lambda, kappaSca, kappaExt, kappaAbs
    real(double) :: dustOpac, dustEmiss
    Integer :: ilambda
    integer, allocatable,save :: iFreqRBB(:)
    integer, save :: iflagRBB
    integer :: iTestFreq

    !$OMP THREADPRIVATE (firstWarning, firstTime, ifreqRBB, iflagRBB)

    if (firstTime) then
       allocate(iFreqRBB(1:nRBBTrans))
       do iRBB = 1, nRBBTRans
          iAtom = indexAtom(iRBB)
          iTrans = indexRBBTrans(iRBB)
          
          if ((thisAtom(iatom)%name == "HeII").and.(thisAtom(iatom)%ilower(itrans) == 1).and. &
               (thisAtom(iatom)%iupper(itrans) == 2)) iflagRBB = iRbb

          call locate(freq, nfreq, thisAtom(iAtom)%transFreq(iTrans), iFreqRBB(iRBB))
       enddo
       firstTime = .false.
    endif


    call locate(freq,nfreq, cspeed/ 200.d-8, iTestFreq)

    distToSource = 0.d0; hitSource = .false.
    a = 0.d0; blu = 0.d0; bul =0.d0
    allocate(tauCont(1:nFreq))
    allocate(jnuCont(1:nFreq))
    allocate(alphanuCont(1:nFreq))
    allocate(snuCont(1:nFreq))

    allocate(tau(1:nRBBTrans))
    allocate(dtau(1:nRBBTrans))
    allocate(tautmp(1:nRBBTrans))

    allocate(tauStep(1:nRBBTrans))
    allocate(iStep(1:nRBBTrans))

    position = randomPositionInCell(fromOctal, fromsubcell)

    icount = 1
    thisOctal => grid%octreeRoot
    call findSubcellLocal(position, thisOctal, subcell)

    if (sobolevApprox) then
       call randomRayDirection(0.8d0, position, source, nSource, direction, weightOmega, fracRay)
    else
       call randomRayDirection(0.5d0, position, source, nSource, direction, weightOmega, fracRay)
    endif

    call randomNumberGenerator(getDouble=r)

    totDist = 0.d0
    call distanceToSource(source, nSource, position, direction, hitSource, disttoSource, sourcenumber)

    if (hitSource) then
       pVec = (position + (direction * distToSource) - source(sourceNumber)%position)
       call normalize(pVec)
       cosTheta = -1.d0*(pVec.dot.direction)
       photoDirection = pVec
       call normalize(PhotoDirection)
    endif


    rayVel = amrGridVelocity(grid%octreeRoot, position, startOctal = thisOctal, actualSubcell = subcell)


    call randomNumberGenerator(getDouble=r)


    deltaV = 4.3 * thisOctal%microturb(subcell) * (r-0.5d0) ! random frequency near line spectrum peak. 

!    deltaV = 10.d0 * thisOctal%microturb(subcell) * (r-0.5d0) ! random frequency near line spectrum peak. 

    rayDeltaV = deltaV
    ! 4.3 corresponds to the width where the peak of the line profile has dropped to 1% of its peak
    ! microturulence is assumed gaussian - b is FULL WIDTH

    weightFreq = phiProfTurb(dv, thisOctal%microturb(subcell))

    deltaV = deltaV +  (rayVel .dot. direction)

    projVel = deltaV - (rayVel .dot. direction)

    Hcol = 0.d0
    HeICol = 0.d0
    HeIICol = 0.d0
    i0 = 0.d0
    intensityIntegral = 0.0
    tau = 0.d0
    tauCont = 0.d0
    iCont = 0.d0

    hitPhotosphere = .false.
    hitDisc = .false.
    firstSubcell = .true.

    currentPosition = position

    nBug = 0
    do while(inOctal(grid%octreeRoot, currentPosition).and.(.not.hitPhotosphere))

       nBug = 0
       phiAv = 0.d0
       phiNorm = 0.d0

       call findSubcellLocal(currentPosition, thisOctal, subcell)
       call distanceToCellBoundary(grid, currentPosition, direction, tVal, sOctal=thisOctal)

       if ((totDist + tval) > distTosource) then
          tVal = distToSource - totDist
          hitPhotosphere = .true.
       endif

       if (firstSubcell) then
          ds = tval * 1.d10
       endif


       startVel = amrGridVelocity(grid%octreeRoot, currentPosition, startOctal = thisOctal, actualSubcell = subcell) 
       !       startVel = getVel(grid, thisOctal, subcell, currentposition, direction)

       endPosition = currentPosition + tval * direction

       if (currentPosition%z*endPosition%z < 0.d0) then ! ray passes through z=0
          if (sqrt(currentPosition%x**2 + currentPosition%y**2) > holeRadius/1.d10) then
             hitDisc = .true.
             hitPhotosphere = .false.
             write(*,*) "hit disc in getray"
             goto 666
          endif
       endif

       endVel = amrGridVelocity(grid%octreeRoot, endPosition)
       !       endVel = getVel(grid, thisOctal, subcell, endposition, direction)


       dvAcrossCell = ((startVel - rayVel).dot.direction) - ((endVel - rayVel).dot.direction)
       dvAcrossCell = abs(dvAcrossCell / thisOctal%microturb(subcell))
       dv1 = abs(deltaV - (startVel .dot. direction))
       dv2 = abs(deltaV - (endVel .dot. direction))


       passThroughResonance =.false.


       if (dv1*dv2 < 0.d0) passThroughResonance = .true.


       if (passthroughresonance.or.(min(abs(dv1),abs(dv2)) < 4.d0*thisOctal%microturb(subcell))) then
          ntau = 20
       endif

       if (sobolevApprox) ntau = 2



       if (.not.thisOctal%inflow(subcell)) ntau = 2
       
       ok = .false.
       do while (.not.ok)
          ok = .true.
          tauStep = 0.d0
          tautmp = tau
          iStep = 0.d0
          allocate(distArray(1:nTau))
          do i = 1, ntau
             distArray(i) = tval * dble(i-1)/dble(nTau-1)
          enddo
       do i = 2, nTau


          startOctal => thisOctal
          thisPosition = currentPosition + distArray(i)*direction

          thisVel = amrGridVelocity(grid%octreeRoot, thisPosition, startOctal = startOctal, actualSubcell = subcell) 
          !          thisVel = getVel(grid, thisOctal, subcell, thisposition, direction)


          ! only need to calc continuum opacities once per cell

          if (opticallyThickContinuum.and.(i==2)) then

             do iAtom = 1, nAtom
                do j = 1, thisAtom(iAtom)%nLevels - 1
                   nStar(iAtom,j) = BoltzSahaGeneral(thisAtom(iAtom),  j, thisOctal%ne(subcell), &
                        dble(thisOctal%temperature(subcell))) * &
                        Thisoctal%atomlevel(subcell, iAtom,thisAtom(iatom)%nLevels)
                enddo
             enddo


             do iFreq = 1, nFreq

                alphanuCont(ifreq) = bfOpacity(freq(ifreq), nAtom, thisAtom, thisOctal%atomLevel(subcell,:,:), &
                     nstar, thisOctal%ne(subcell),  dble(thisOctal%temperature(subcell)), ifreq=ifreq)

                jnuCont(iFreq) = bfEmissivity(freq(ifreq), nAtom, thisAtom, &
                     thisOctal%atomLevel(subcell, :, :), nStar, dble(thisOctal%temperature(subcell)), thisOctal%ne(subcell), &
                     ifreq=ifreq)

                dustOpac = 0.d0
                dustEmiss = 0.d0
                if (mie) then
                   lambda = (cSpeed/freq(ifreq)) /angstromTocm
                   iLambda = findIlambda(real(lambda), grid%lamArray, nLambda, ok)
                   call returnKappa(grid, thisOctal, subcell, ilambda=ilambda, kappaSca=kappaSca, kappaAbs=kappaAbs)
                   kappaExt = kappaAbs + kappaSca
                   dustOpac = kappaExt/1.d10
                   dustEmiss = kappaAbs * bnu(freq(ifreq), dble(thisOctal%temperature(subcell)))/1.d10
                endif
                
                jnuCont(ifreq) = jnuCont(ifreq) + dustEmiss
                alphaNuCont(iFreq) = alphaNuCont(ifreq) + dustOpac

                if (alphanuCont(ifreq) /= 0.d0) then
                   snuCont(iFreq) = jnuCont(iFreq)/alphanuCont(iFreq)
                else
                   snuCont(iFreq) = tiny(snuCont(iFreq))
                endif
             enddo
          endif

          if (opticallyThickContinuum) then
             deltaDist = (distArray(i)-distArray(i-1)) * 1.d10
             do iFreq = 1, nFreq
                dTauCont = alphaNuCont(iFreq) *  deltaDist

                iCont(iFreq) = iCont(ifreq) + exp(-tauCont(iFreq)) * (1.d0-exp(-dtauCont))*snuCont(iFreq)
                if (icont(ifreq) < 0.d0) then
                   write(*,*) "icont negative ",icont(ifreq)
                   write(*,*) "tau ",tauCont(ifreq), " dtau ",dtau, " snu ",snuCont(ifreq)
                   write(*,*) "expression ",exp(-tauCont(iFreq)) * (1.d0-exp(-dtauCont))*snuCont(iFreq)
                   stop
                endif
                tauCont(iFreq) = tauCont(iFreq) + dtauCont
             enddo
          endif
          !          write(*,*) tauCont(48),iCont(48),snuCont(48)
          dv = deltaV - (thisVel .dot. direction)

          icount = icount + 1

          if (.not.SobolevApprox) then
          do iRBB = 1, nRBBTRans
             iAtom = indexAtom(iRBB)
             iTrans = indexRBBTrans(iRBB)

            

!             call locate(freq, nfreq, thisAtom(iAtom)%transFreq(iTrans), iFreq)
             call returnEinsteinCoeffs(thisAtom(iAtom), iTrans, a, Bul, Blu)


             alphanu = hCgsOverFourPi * phiProf(dv, thisOctal, subcell, &
                        thisAtom(iatom)%transfreq(itrans), thisAtom(iatom))/thisAtom(iAtom)%transFreq(iTrans)


             if (firstSubcell) then
                phiAv = phiAv + phiProf(dv, thisOctal, subcell, &
                        thisAtom(iatom)%transfreq(itrans), thisAtom(iatom)) * &
                     (distArray(i)-distArray(i-1)) * 1.d10
                phiNorm = phiNorm + (distArray(i)-distArray(i-1)) * 1.d10
             endif


             iUpper = thisAtom(iAtom)%iUpper(iTrans)
             iLower = thisAtom(iAtom)%iLower(iTrans)

             nLower = thisOctal%atomLevel(subcell,iAtom, iLower)
             nUpper = thisOctal%atomLevel(subcell,iAtom, iUpper)

             alphanu = alphanu * (nLower * Blu - nUpper * Bul)

             if (opticallyThickContinuum) alphanu = alphanu + alphaNuCont(iFreqRBB(iRBB))


             if (alphanu < 0.d0) then
                alphanu = 0.d0
                if (firstWarning) then
                   write(*,*) "negative opacity warning in getray",iUpper,iLower,nLower,nUpper,thisAtom%name
                   firstWarning = .false.
                endif
             endif



             dTau(iRBB) = max(0.d0, alphaNu *  (distArray(i)-distArray(i-1)) * 1.d10)



             etaLine = hCgs * a * thisAtom(iAtom)%transFreq(iTrans)
             etaLine = etaLine * thisOctal%atomLevel(subcell, iAtom, iUpper)
             jnu = (etaLine/fourPi) * phiProf(dv, thisOctal, subcell, &
                        thisAtom(iatom)%transfreq(itrans), thisAtom(iatom))/thisAtom(iAtom)%transFreq(iTrans)


             if (opticallyThickContinuum) jnu = jnu + jnuCont(iFreqRBB(iRBB)) 


             if (alphanu > 1.d-30) then
                snu = jnu/alphanu
             else
                snu = tiny(snu)
             endif


             if (tau(irbb) < 0.d0) then
                write(*,*) "Negative tau(irbb) problem ",tau(irbb), irbb
             endif
             if (dtau(iRBB) < 0.d0) then
                write(*,*) "negative dtau ",dtau
             endif
             if (i0(irbb) > 1.e20) then
                write(*,*) "intensity bug ",i0(irbb), irbb
             endif
             if (snu > 1.d20) then
                write(*,*) "snu bug ",snu, jnu, alphanu
             endif



             istep(iRBB) = istep(iRBB) +  exp(-tautmp(irBB)) * (1.d0-exp(-dtau(iRBB)))*snu
             tauStep(iRBB) = tauStep(iRBB) + dtau(iRBB)
             tautmp(iRBB) = tautmp(iRBB) + dtau(iRBB)

          enddo

          if (ANY(dtau > 1.d0)) then
             ntau = ntau * 2
             ok = .false.
             exit
          endif

       endif
    enddo

    if (ok) then
       do iRBB = 1, nRBBtrans
          i0(iRBB) = i0(iRBB) + iStep(iRBB)
          tau(iRBB) = tau(iRBB) + tauStep(iRBB)
       enddo
    endif


    deallocate(distArray)

 enddo

       currentPosition = currentPosition + (tval+1.d-3*grid%halfSmallestSubcell) * direction
       totdist = totdist + (tval+1.d-3*grid%halfSmallestSubcell)

       if (nBug > 10000) then
          write(*,*) "bug",currentPosition,nTau,tval,modulus(currentPosition)
       endif

       if (firstSubcell) then
          if (phiNorm /= 0.d0) then
             phi = phiAv / phiNorm
          else
             phi = 0.d0
          endif
          firstSubcell = .false.
       endif

    enddo


    if (sobolevApprox.and.(.not.hitPhotosphere)) iCont = 0.d0


    if (hitPhotosphere) then ! don't include weight below - that's done when jbar is calculated
       iElement = getElement(source(sourcenumber)%surface, photoDirection)
       do iFreq = 1, nFreq
          !          write(*,*) freq(ifreq),iCont(ifreq),i_nu(source(sourceNumber), &
          !               freq(iFreq), iElement)*cosTheta*exp(-tauCont(iFreq)),taucont(ifreq)
          !          write(*,*) freq(ifreq),i_nu(source(sourcenumber),freq(ifreq),ielement)
          !          iCont(iFreq) = iCont(iFreq) + i_nu(source(sourceNumber), freq(iFreq), iElement)*cosTheta*exp(-tauCont(iFreq))
          if (opticallyThickContinuum) then
               iCont(iFreq) = iCont(iFreq) + i_nu(source(sourceNumber), freq(iFreq), iElement, cosTheta)*exp(-tauCont(iFreq))
            else
               iCont(iFreq) = i_nu(source(sourceNumber), freq(iFreq), iElement, cosTheta)*exp(-tauCont(iFreq))
            endif

       enddo
    endif



    if (hitPhotosphere.and.(.not.SobolevApprox)) then ! don't include weight below - that's done when jbar is calculated
       iElement = getElement(source(sourcenumber)%surface, photoDirection)
       do iRBB = 1, nRBBTrans
          iAtom = indexAtom(iRBB)
          iTrans = indexRBBTrans(iRBB)
          i0(iRBB) = i0(iRBB) + i_nu(source(sourceNumber), thisAtom(iATom)%transFreq(iTrans), iElement, cosTheta)*exp(-tau(iRBB))
       enddo
    endif

!    write(*,*) "test tau ",tauCont(iTestFreq),icont(itestFreq)
666 continue
    deallocate(tau, dtau, istep, tautmp)
  end subroutine getRay


  real(double) function phiProf(dv, thisOctal, subcell, nu, thisAtom)
    type(OCTAL), pointer :: thisOctal
    integer :: subcell
    real(double) :: dv, nu
    type(MODELATOM) :: thisAtom
    
    if ((thisAtom%name=="HI").and.(thisOctal%microturb(subcell)==0.d0)) then
       phiProf = phiProfStark(dv, thisOctal, subcell, nu, thisAtom)
    else
       phiProf = phiProfTurb(dv, thisOctal%microturb(subcell))
    endif
  end function phiProf


  function phiProfTurb(dv, b) result (phi)
    real(double) :: dv, b
    real(double) :: fac, phi

    phi = 1.d0 / (b * sqrtPi)
    fac = (dv/b)**2
    phi = phi * exp(-fac)

  end function phiProfTurb

  real(double) function  phiProfStark(dv, thisOctal, subcell, nu, thisAtom)
    use utils_mod, only : voigtn
    use atom_mod, only: bigGamma
    type(MODELATOM) :: thisAtom
    real(double) :: dv
    type(OCTAL), pointer :: thisOctal
    integer :: subcell
    real(double) :: n_hi, a, dopplerWidth, hay, nu, v_th

    V_th = sqrt(2.*kErg*thisOctal%temperature(subcell)/(thisAtom%mass*mHydrogen))  ! [cm/s] theram speed
             
    DopplerWidth = nu/cSpeed * V_th !eq 7  [Hz]

    N_HI = thisoctal%atomlevel(subcell, 1, 1)
    a = bigGamma(N_HI, dble(thisOctal%temperature(subcell)), thisOctal%ne(subcell), nu) / (fourPi * DopplerWidth) ! [-]
    Hay = voigtn(a,dv*cspeed/v_th)
    phiProfStark = nu * Hay / (sqrtPi*DopplerWidth)
!    write(*,*) "stark ",dv*cspeed/1.d5, phiProfStark,a/1.d5, n_hi
  end function phiProfStark



  subroutine calculateJbar(grid, thisOctal, subcell, thisAtom, nRay, position, direction, rayDeltaV, &
       ds,  i0, iTrans, jbar, nPops, &
       weight,  tauAv)
    type(GRIDTYPE) :: grid
    type(VECTOR) :: position(:), direction(:), thisPosition, startVel, thisVel, endVel, endPosition
    real(double) :: dds, dv, rayDeltaV(:)
    integer :: ns 
    real(double) :: inu
    integer :: i
    real(double) :: weight(:)
    type(OCTAL), pointer :: thisOctal
    integer :: subcell
    type(MODELATOM) :: thisAtom
    integer :: nRay
    Real(double) :: ds(:), i0(:), nPops(:)
    integer :: iTrans
    real(double) :: jbar
    integer :: iRay
    real(double) :: nLower, nUpper
    real(double) :: jBarInternal, jBarExternal
    real(double) :: alphanu, jnu, etaline
    integer :: iUpper, iLower
    real(double) :: tau, snu, sumWeight,inuAv
    real(double) :: a, bul, blu
    logical,save :: first = .true.
    real(double) :: dtau, tauav, test
    real(double) :: distanceForTauOfOne
    real(double) :: currentS
    logical :: debugOutput, split
    !$OMP THREADPRIVATE (first)

    jBarExternal = 0.d0
    jBarInternal = 0.d0
    a = 0.d0; bul = 0.d0; blu = 0.d0


    if (thisAtom%transType(iTrans) == "RBB") then

       iUpper = thisAtom%iUpper(iTrans)
       iLower = thisAtom%iLower(iTrans)

       debugOutput = .false.
!           if ((thisAtom%name == "HeII").and.(ilower==1).and.(iupper==2)) &
!                debugOutput = .true.

       sumWeight = 0.d0
       tauAv = 0.d0
       inuAv = 0.d0
       do iRay = 1, nRay
          nLower = nPops(iLower)
          nUpper = nPops(iUpper)

          call returnEinsteinCoeffs(thisAtom, iTrans, a, Bul, Blu)

          etaLine = hCgs * a * thisAtom%transFreq(iTrans)
          etaLine = etaLine *  nPops(iUpper)

          thisPosition = position(iray)
          endPosition = thisPosition + (ds(iray)/1.d10)*direction(iray)
          startVel = amrGridVelocity(grid%octreeRoot, thisPosition, startOctal = thisOctal, actualSubcell = subcell) 

          endVel = amrGridVelocity(grid%octreeRoot, endPosition, startOctal = thisOctal, &
               actualSubcell = subcell) 
          dv = rayDeltaV(iray)

          alphanu = (hCgs*thisAtom%transFreq(iTrans)/fourPi)
          alphanu = alphanu * (nLower * Blu - nUpper * Bul) * &
               phiProf(dv, thisOctal, subcell, &
                        thisAtom%transfreq(itrans), thisAtom)/thisAtom%transFreq(iTrans)
          distanceForTauOfOne = 0.1d0/(alphanu)


          ns = max(5, nint(ds(iray)/max(ds(iray)/100.d0,distanceForTauOfOne)))


          split = .true.
          do while(split)
             dds = ds(iray)/dble(ns)
             split = .false.
             inu = 0.d0
             tau = 0.d0
             currentS = dds
             thisPosition = position(iray)

             do i = 1, ns
                thisPosition = thisPosition + dds * direction(iray)
                !             thisVel = amrGridVelocity(grid%octreeRoot, thisPosition, startOctal = thisOctal, actualSubcell = subcell) 

                thisVel = startVel + (currentS/ds(iray)) * (endVel - startVel)
                thisVel= thisVel - startVel

                dv = rayDeltaV(iray) - (thisVel .dot. direction(iray))

                alphanu = (hCgs*thisAtom%transFreq(iTrans)/fourPi)
                alphanu = alphanu * (nLower * Blu - nUpper * Bul) * &
                     phiProf(dv, thisOctal, subcell, &
                        thisAtom%transfreq(itrans), thisAtom)/thisAtom%transFreq(iTrans)
!                if (debugOutput) &
!                     write(*,*) i, dv*cspeed/1.e5,tau,inu
                if (alphanu < 0.d0) then
                   alphanu = 0.d0
                   if (first) then
                      write(*,*) "negative opacity warning in calcjbar",iUpper,iLower,nLower,nUpper,thisAtom%name
                      first = .false.
                   endif
                endif

                dtau = alphaNu * dds

                if (dtau > 0.2d0) then
                   split = .true.
                   exit
                endif

                jnu = (etaLine/fourPi) * phiProf(dv, thisOctal, subcell, &
                        thisAtom%transfreq(itrans), thisAtom)/thisAtom%transFreq(iTrans)


                if (alphanu /= 0.d0) then
                   snu = jnu/alphanu
                else
                   snu = tiny(snu)
                endif


                inu = inu + exp(-tau) * snu * (1.d0 - exp(-dtau))


                tau = tau + dtau
                currentS = currentS + dds
                if (tau > 100.d0) exit
             enddo
             if (split) then
                dds = dds / 2.d0
                ns = ns * 2
             endif
          enddo


          !          if ((thisAtom%name == "HeII").and.(ilower==1).and.(iupper==2)) &
          !               write(*,*) "delta v ",raydeltaV(iray)*cspeed/1e5,tau,inu

          tauAv = tauAv + tau * weight(iray)
          jBarInternal = jbarInternal + inu  * weight(iray)
          jBarExternal = jbarExternal + i0(iray) * exp(-tau) * weight(iray)
          test = i0(iray) * exp(-tau) * weight(iray)
          !          if ((thisAtom%name == "HeII").and.(ilower==1).and.(iupper==2).and.(test>0.d0)) &
          !               write(*,*) "ext ",i0(iray),tau,weight(iray), exp(-tau)

          inuAv = inuAv + inu * weight(iray)

          sumWeight = sumWeight + weight(iRay) 


       enddo
       tauAv = tauAv / sumWeight
       inuAv = inuAv / sumWeight

       if ((thisAtom%name == "HeII").and.(ilower==1).and.(iupper==2)) &
            write(*,*) "tau cmf ",tauAv



       jBarExternal = jBarExternal / sumWeight
       jBarInternal = jBarInternal / sumWeight



       jbar = (jBarExternal + jBarInternal)

       if (debugoutput) then
          write(*,*) "jbar ",jbar
          write(*,*) "snu ",snu
       endif


       if ((thisAtom%name == "HeII").and.(ilower==1).and.(iupper==2)) then
            write(*,*) "jbar cmf (int, ext) ",jbar, jbarinternal, jbarexternal
         endif


    endif

  end subroutine calculateJbar

  subroutine calculateJbarCont(thisOctal, subcell, nAtom, thisAtom, ne, nray, ds, freq, nfreq, &
       iCont, jBarCont, weight)
    use inputs_mod, only : opticallyThickContinuum
    real(double) :: iCont(:,:), jBarCont(:), ds(:), ne
    integer :: nAtom
    type(OCTAL), pointer :: thisOctal
    integer :: subcell
    type(MODELATOM) :: thisAtom(:)
    integer :: nfreq
    real(double) :: freq(:), weight(:)
    integer :: iray, nRay
    real :: tau
    real(double), allocatable :: jBarContExternal(:), jBarContInternal(:)
    real(double) :: alphanu
    integer :: iFreq
    real(double) :: jnu, snu
    real(double) :: nstar(10,50), expMinusTau
    integer :: iAtom, j, itestfreq
    allocate(jBarContExternal(1:nFreq))
    allocate(jBarContInternal(1:nFreq))


    call locate(freq,nfreq, cspeed/ 200.d-8, iTestFreq)

    jBarCont = 0.d0
    jBarContInternal = 0.d0
    jBarContExternal = 0.d0

    do iAtom = 1, nAtom
       do j = 1, thisAtom(iAtom)%nLevels - 1
          nStar(iAtom,j) = BoltzSahaGeneral(thisAtom(iAtom), j, ne, &
               dble(thisOctal%temperature(subcell))) * &
               Thisoctal%atomlevel(subcell, iAtom,thisAtom(iatom)%nLevels)
!          write(*,*) "iatom ", iatom, " j ",nstar(iatom,j), thisOctal%atomlevel(subcell, iatom,thisAtom(iatom)%nLevels)

       enddo
       if (any(nstar(iatom,1:thisAtom(iatom)%nlevels-1) < 0.d0)) then
          write(*,*) "atom: ",thisAtom(iatom)%name
          write(*,*) "nstar bug ",nstar(iAtom,1:thisAtom(iatom)%nlevels-1)
          stop
       endif
    enddo


    do iRay = 1, nRay
       do iFreq = 1, nFreq

          tau = 0.d0
          snu = 0.d0
          if (opticallyThickContinuum) then
             alphanu = bfOpacity(freq(ifreq), nAtom, thisAtom, thisOctal%atomLevel(subcell,:,:), nstar, ne, &
                  dble(thisOctal%temperature(subcell)),ifreq=ifreq)
             jnu =  bfEmissivity(freq(ifreq), nAtom, thisAtom, &
                  thisOctal%atomLevel(subcell,:,:), nstar, &
                  dble(thisOctal%temperature(subcell)), thisOctal%ne(subcell), &
                  ifreq=ifreq)
             tau = real(alphaNu * ds(iray))
             if (alphanu /= 0.d0) then
                snu = jnu/alphanu
             else
                snu = tiny(snu)
             endif
         endif
         if (tau < 0.d0) then
            write(*,*) "tau bug ", tau
            stop
         endif
         if (tau < 60.d0) then
            expMinusTau = exp(-tau)
         else
            expMinusTau = 0.d0
         endif

         jBarContExternal(iFreq) = jBarContExternal(iFreq) + iCont(iray, iFreq) * expMinusTau * weight(iRay)
         jBarContInternal(iFreq) = jBarContInternal(iFreq) + snu * (1.d0 - expMinusTau) * weight(iRay)

       enddo
       if (any(jbarcontexternal(1:nfreq) < 0.d0)) then
          write(*,*) "negative jbarcontexternal"
          write(*,*) icont(iray,1:nfreq)
          stop
       endif
    enddo
    jBarContExternal = jBarContExternal / SUM(weight(1:nRay))
    jBarContInternal = jBarContInternal / SUM(weight(1:nRay))
    jbarCont = jBarContExternal + jBarContInternal

!    write(*,*) "test ",jbarcont(itestfreq),jbarcontExternal(itestfreq),jbarcontInternal(itestfreq)

    if (any(jbarCont < 0.d0)) then
       write(*,*) "fatal jbar cont bug"
       write(*,*) "ext ",jbarContExternal(1:nfreq)
       write(*,*) "int ",jbarContInternal(1:nfreq)
       write(*,*) "weight ",weight(1:nray)
       write(*,*) "icont ",icont(1:nray,1:nfreq)
       stop
    endif

  end subroutine calculateJbarCont


  subroutine atomLoop(grid, nAtom, thisAtom, nSource, source)

    use inputs_mod, only : debug, rcore, lte, vturb
    use messages_mod, only : myRankIsZero
    use gridio_mod, only : writeAmrGrid
    use utils_mod, only : ngstep
    use random_mod
    use amr_mod, only: sortOctalArray
#ifdef MEMCHECK
    use memory_mod, only : resetGlobalMemory
#endif
#ifdef MPI
    use amr_mod, only : countVoxels
    use mpi
#endif

    type(SOURCETYPE) :: source(:)
    integer :: nSource
    integer :: nAtom
    type(GRIDTYPE) :: grid
    type(MODELATOM) :: thisAtom(:)
    type(VECTOR), allocatable :: position(:), direction(:)
    real(double), allocatable :: rayDeltaV(:)
    integer :: iOctal, subcell
    real(double), allocatable :: ds(:), phi(:), i0(:,:)
    real(double), allocatable :: Hcol(:), HeICol(:), HeIICol(:)
    integer :: nRay
    type(OCTAL), pointer :: thisOctal
    integer, parameter :: maxIter = 100, maxRay = 200000
    logical :: popsConverged, gridConverged 
    integer :: iRay, iTrans, iter,i 
    integer :: iStage
    real(double), allocatable :: oldpops(:,:), newPops(:,:), dPops(:,:), mainoldpops(:,:)
    real(double) :: newNe
    real(double), parameter :: underCorrect = 0.8d0
    real(double), parameter :: underCorrectne = 0.8d0
    real(double) :: dne
    logical :: sobolevApprox
    real(double) :: fac
    type(octalWrapper), allocatable :: octalArray(:) ! array containing pointers to octals
    integer :: ioctal_beg, ioctal_end
    real(double) :: maxFracChange
    logical :: fixedRays
    integer(bigint) :: iseed
    integer, allocatable :: sourceNumber(:)
    !    type(VECTOR) :: posVec
    !    real(double) :: r
    real(double), allocatable :: cosTheta(:)
    real(double), allocatable :: weightFreq(:), weightOmega(:)
    real(double), allocatable :: iCont(:,:)
    logical, allocatable :: hitPhotosphere(:)
    integer, parameter :: maxFreq = 2000
    real(double) :: freq(maxFreq), dFreq(maxFreq)
    real(double), allocatable :: jnuCont(:)
    integer :: nFreq, nhit, iRBB
    integer :: nRBBTrans
    integer :: indexRBBTrans(1000), indexAtom(1000)
    real(double) :: ne, tauav
    integer :: iAtom
    integer :: nHAtom, nHeIAtom, nHeIIatom !, ir, ifreq
    real(double) :: nstar, ratio, ntot
    real(double), parameter :: convergeTol = 1.d-4, gridtolerance = 1.d-2
    integer :: neIter, itmp
    logical :: recalcJbar,  firstCheckonTau
    character(len=80) :: message, ifilename
!    real :: r
    logical :: ionized
    integer :: nOctals
    integer :: nIter, idump, nt, nInuse, nConverged
    real(double) :: percentageConverged
    real(double), save, allocatable :: oldpops1(:,:), oldpops2(:,:), oldpops3(:,:), oldpops4(:,:)
    integer, parameter :: iNgStep = 5
    integer :: nStage
    real(double) :: inu_times_betacmn, betamn, sobJnuLine

#ifdef MPI
    ! For MPI implementations
    integer       ::   my_rank        ! my processor rank
    integer       ::   np             ! The number of processes
    integer       ::   ierr           ! error flag
    integer       ::   nVoxels
    integer       :: nOCtal
    integer       ::   isubcell
    integer :: status(MPI_STATUS_SIZE)
    integer :: ithread
    integer, parameter :: tag = 54
    real(double), allocatable :: tArrayd(:),tempArrayd(:)
    logical,allocatable :: doneByThisThread(:)
#endif

#ifdef _OPENMP
    integer :: omp_get_thread_num
    integer(bigInt) ::  iCellSeed
#endif
    !$OMP THREADPRIVATE (oldpops1, oldpops2, oldpops3, oldpops4)



    !    blockHandout = .false. 

#ifdef MPI
    ! FOR MPI IMPLEMENTATION=======================================================
    !  Get my process rank # 
    call MPI_COMM_RANK(MPI_COMM_WORLD, my_rank, ierr)

    ! Find the total # of precessor being used in this run
    call MPI_COMM_SIZE(MPI_COMM_WORLD, np, ierr)
#endif


    call checkInflow(grid%octreeRoot, nsource, source)
    freq = 0.d0
    indexRBBTrans = 0
    nfreq = 0; nRBBTrans = 0; tauAv = 0.d0
    call createRBBarrays(nAtom, thisAtom, nRBBtrans, indexAtom, indexRBBTrans)

    call createContFreqArray(nFreq, freq, nAtom, thisAtom, nsource, source)

    dfreq(1) = freq(2)-freq(1)
    do i = 2, nFreq
       dfreq(i) = freq(i) - freq(i-1)
    enddo


    !     open(69,file="photoionization.dat",status="unknown",form="formatted")
    !     do i = 1, nfreq
    !        do itrans = 1, thisAtom(1)%nTrans
    !          if (thisAtom(1)%name == "HI".and.thisAtom(1)%transType(iTrans) == "RBF") then ! photoionization
    !             if (thisAtom(1)%iLower(iTrans) == 1) then
    !                xH = photoCrossSection(thisAtom(1), iTrans, 1, freq(i))
    !             endif
    !          endif
    !       enddo
    !        do itrans = 1, thisAtom(2)%nTrans
    !          if (thisAtom(2)%name == "HeI".and.thisAtom(2)%transType(iTrans) == "RBF") then ! photoionization
    !             if (thisAtom(2)%iLower(iTrans) == 2) then
    !                xHeI = photoCrossSection(thisAtom(2), iTrans, 2, freq(i))
    !             endif
    !          endif
    !       enddo
    !        do itrans = 1, thisAtom(3)%nTrans
    !          if (thisAtom(3)%name == "HeII".and.thisAtom(3)%transType(iTrans) == "RBF") then ! photoionization
    !             if (thisAtom(3)%iLower(iTrans) == 2) then
    !                xHeII = photoCrossSection(thisAtom(3), iTrans, 2, freq(i))
    !             endif
    !          endif
    !       enddo
    !
    !       write(69,*) freq(i),  xHeI, xHeII
    !    end do
    !    close(69)


    ionized = .false.
    if (grid%geometry == "gammavel") ionized = .true.
    if (grid%geometry == "wrshell") ionized = .true.
    if (grid%geometry == "wind") ionized = .true.

    call writeInfo("Allocating levels and applying LTE...")
    call allocateLevels(grid, grid%octreeRoot, nAtom, thisAtom, nRBBTrans, nFreq, ionized)
#ifdef MEMCHECK
    call resetGlobalMemory(grid)
#endif
    call setMicroturb(grid%octreeRoot, dble(vTurb))

    call writeVTKfile(grid,"lte.vtk", valueTypeString = (/"ne","n4"/))
    call writeInfo("Done.")

    do i = 1, nAtom
       call addCrossSectionstoAtom(thisAtom(i), nFreq, freq)
    enddo



    if (LTE) goto 666

    nHAtom = 0
    nHeIAtom = 0
    nHeIIAtom = 0
    do iAtom = 1, nAtom
       if (thisAtom(iAtom)%name == "HI") nHatom = iAtom
       if (thisAtom(iAtom)%name == "HeI") nHeIatom = iAtom
       if (thisAtom(iAtom)%name == "HeII") nHeIIatom = iAtom
    enddo

    ! ly-alpha in detailed balance

    !    do iAtom = 1, nAtom
    !       do iTrans = 1, thisAtom(iAtom)%nTrans
    !          if (thisAtom(iAtom)%transType(iTrans) == "RBB") then 
    !             if (thisAtom(iatom)%name == "HI") then
    !                if ((thisAtom(iAtom)%iLower(iTrans) == 1).and.(thisAtom(iatom)%iUpper(itrans)==2)) then
    !                   thisAtom(iAtom)%inDetailedBalance(iTrans) = .true.
    !                endif
    !             endif
    !          endif
    !       enddo
    !    enddo


    ! Lyman continuum in detailed balance

    !    do iAtom = 1, nAtom
    !       do iTrans = 1, thisAtom(iAtom)%nTrans
    !          if (thisAtom(iAtom)%name == "HI".and.thisAtom(iAtom)%transType(iTrans) == "RBF") then ! photoionization
    !             if (thisAtom(iAtom)%iLower(iTrans) == 1) thisAtom(iAtom)%inDetailedBalance(iTrans) = .true.
    !          endif
    !       enddo
    !    enddo
!!!

    ! Lyman continuum in detailed balance

    !    do iAtom = 1, nAtom
    !       do iTrans = 1, thisAtom(iAtom)%nTrans
    !          if (thisAtom(iAtom)%name == "HeI".and.thisAtom(iAtom)%transType(iTrans) == "RBF") then ! photoionization
    !             if (thisAtom(iAtom)%iLower(iTrans) == 1) thisAtom(iAtom)%inDetailedBalance(iTrans) = .true.
    !          endif
    !       enddo
    !    enddo

    !
    !! Lyman continuum in detailed balance

    do iAtom = 1, nAtom
       do iTrans = 1, thisAtom(iAtom)%nTrans
          if (thisAtom(iAtom)%name == "HeII".and.thisAtom(iAtom)%transType(iTrans) == "RBF") then ! photoionization
             if (thisAtom(iAtom)%iLower(iTrans) == 1) thisAtom(iAtom)%inDetailedBalance(iTrans) = .true.
             !             write(*,*) "lyman cont detailed balance ",itrans
          endif
       enddo
    enddo

    ! Lyman lines in detailed balance

    !    do iAtom = 1, nAtom
    !       do iTrans = 1, thisAtom(iAtom)%nTrans
    !          if (thisAtom(iAtom)%name == "HeII".and.thisAtom(iAtom)%transType(iTrans) == "RBB") then ! photoionization
    !             if (thisAtom(iAtom)%iLower(iTrans) == 1) thisAtom(iAtom)%inDetailedBalance(iTrans) = .true.
    !             write(*,*) "lyman cont detailed balance ",itrans
    !          endif
    !       enddo
    !    enddo


    call testSobolevJnuLine(grid, grid%octreeRoot, 1, 4, thisAtom, source(1), &
       inu_times_betacmn, betamn, sobJnuLine)
    call writeVTKfile(grid,"sobtest.vtk", valueTypeString = (/"rhou","rhov"/))

    nInUse = 0
    call getOctalArrayLocal(grid%octreeRoot,octalArray, nInUse, .true.)
    allocate(octalArray(nInUse))
    nInUse = 0
    call getOctalArrayLocal(grid%octreeRoot,octalArray, nInUse, .false.)
    !    grid%starpos1 = vector(1.d5,0.d0,0.d0)
    call  sortOctalArray(octalArray,grid)


    call randomNumberGenerator(randomSeed=.true.)
    !    if (myrankiszero) then
    !       call testRays(grid, nSource, source)
    !    endif
    call torus_mpi_barrier

    call randomNumberGenerator(getiseed = iseed)
    call randomNumberGenerator(syncIseed = .true.)

    if (myRankisZero) then
       open(69, file="cmf_convergence.dat", status="unknown", form="formatted")
       write(69,'(a)') &
            !             01234567890123456789012345678901234567890123456789
       "       Iter    Tol  %Converged   nRays     Fix ray"
       close(69)
    endif

    nRay = 1024

    nStage = 2

    sobolevApprox = .true.

    if (sobolevApprox) nStage = 1
    do iStage = 1, nStage


       if (iStage == 1) then
          fixedRays = .true.
       else
          fixedRays = .false.
       endif

       gridConverged = .false.
       nIter = 0
       idump = 0
       itmp = 0
       do while (.not.gridConverged)

          nIter = nIter + 1
          idump = idump + 1
          write(ifilename,'(a,i2.2,a)') "ionization",01,".dat"
          if (myRankisZero) then
             open(69, file=ifilename, status="unknown", form="formatted")
             write(69,'(a)') &
                  "# log(r/R) , log N(HI), log N(HeI), log N(HeII), log N(HeIII)"
             close(69)
          endif

          if (doTuning) call tune(6, "One cmf iteration")  ! start a stopwatch


          ! default loop indecies
          ioctal_beg = 1
          ioctal_end = SIZE(octalArray)       

          write(*,*) myrankGlobal, " size of octal Array ",ioctal_end

          if (fixedRays) then
             call randomNumberGenerator(putIseed = iseed)
             call randomNumberGenerator(reset = .true.)
          else
             call randomNumberGenerator(randomSeed=.true.)
          endif





         nOctals = size(octalArray)

#ifdef MPI
         if (.not.allocated(doneByThisThread)) allocate(doneBythisThread(1:nOctals))
         donebythisthread = .false.

         if (myrankGlobal == 0) then
            do i = 1, nOctals
               call MPI_RECV(iThread, 1, MPI_INTEGER, MPI_ANY_SOURCE, tag, MPI_COMM_WORLD, status, ierr)
               call MPI_SEND(i, 1, MPI_INTEGER, iThread, tag, MPI_COMM_WORLD,  ierr)
            enddo
            do i = 1, nThreadsGlobal-1
               call MPI_RECV(iThread, 1, MPI_INTEGER, i, tag, MPI_COMM_WORLD, status, ierr)
               call MPI_SEND(-1, 1, MPI_INTEGER, i, tag, MPI_COMM_WORLD,  ierr)
            enddo
         else
            
            do
               call MPI_SEND(myrankGlobal, 1, MPI_INTEGER, 0, tag, MPI_COMM_WORLD, ierr)
               call MPI_RECV(iOctal, 1, MPI_INTEGER, 0, tag, MPI_COMM_WORLD, status, ierr)
               if (iOctal < 0) then
                  exit
               endif

               ioctal_beg = ioctal
               ioctal_end = ioctal
               doneByThisThread(iOctal_beg:iOctal_end) = .true.
#endif
          !$OMP PARALLEL DEFAULT (NONE) &
          !$OMP PRIVATE (iOctal, thisOctal, subcell, i0, position, direction, nt, iCellSeed) &
               !$OMP PRIVATE(rayDeltaV, ds, phi, hcol, heicol, heiicol, hitphotosphere, sourcenumber, costheta,weightfreq) &
          !$OMP PRIVATE(weightOmega, icont, neiter, iter,popsConverged, oldpops, mainoldpops, firstCheckonTau) &
          !$OMP PRIVATE(fac,dne,message,itmp,ne,recalcjbar,ratio,nstar,dpops,newne) &
          !$OMP PRIVATE(nhit, jnucont,tauav,newpops,ntot,iatom,itrans) &
          !$OMP SHARED(octalArray, grid, ioctal_beg, ioctal_end, nsource, nray, nrbbtrans) &
          !$OMP SHARED(indexRbbtrans, indexatom, sobolevApprox, ifilename) &
               !$OMP SHARED(freq,dfreq,nfreq, natom,myrankiszero,debug,rcore, iseed, fixedRays) &
          !$OMP SHARED(source, thisAtom, myrankGlobal, writeoutput, noctals)

          !$OMP MASTER
          call randomNumberGenerator(getIseed=iseed)
          !$OMP END MASTER
          allocate(oldPops(1:nAtom,1:maxval(thisAtom(1:nAtom)%nLevels)))
          allocate(mainoldPops(1:nAtom,1:maxval(thisAtom(1:nAtom)%nLevels)))
          allocate(newPops(1:nAtom,1:maxval(thisAtom(1:nAtom)%nLevels)))
          allocate(dPops(1:nAtom,1:maxval(thisAtom(1:nAtom)%nLevels)))
          allocate(jnuCont(1:nFreq)) 
          allocate(ds(1:nRay))
          allocate(phi(1:nRay))
          allocate(rayDeltaV(1:nRay))
          allocate(i0(1:nRBBTrans, 1:nRay))
          allocate(Hcol(1:nRay))
          allocate(HeIcol(1:nRay))
          allocate(HeIIcol(1:nRay))
          allocate(sourceNumber(1:nRay))
          allocate(cosTheta(1:nRay))
          allocate(weightFreq(1:nRay))
          allocate(weightOmega(1:nRay))
          allocate(hitPhotosphere(1:nRay))
          allocate(iCont(1:nRay,1:nFreq))
          allocate(position(1:nray))
          allocate(direction(1:nray))

          allocate(oldpops1(nAtom, maxval(thisAtom(1:nAtom)%nLevels)))
          allocate(oldpops2(nAtom, maxval(thisAtom(1:nAtom)%nLevels)))
          allocate(oldpops3(nAtom, maxval(thisAtom(1:nAtom)%nLevels)))
          allocate(oldpops4(nAtom, maxval(thisAtom(1:nAtom)%nLevels)))




          !$OMP DO SCHEDULE(DYNAMIC,1)
          do iOctal = ioctal_beg, ioctal_end

             thisOctal => octalArray(iOctal)%content

             nt = 0
#ifdef _OPENMP
             nt = omp_get_thread_num()
             iCellSeed = iseed + thisOctal%label(1)*10000
             if (fixedRays) then
                call randomNumberGenerator(putIseed = iCellSeed)
                call randomNumberGenerator(reset = .true.)
             endif
#endif

             !          if (doTuning) call tune(6, "One octal iteration")  ! start a stopwatch

             !             do subcell = thisOctal%maxChildren,1,-1
             do subcell = 1, thisOctal%maxChildren


                !                if (.not.thisOctal%hasChild(subcell)) then

                if (octalArray(iOctal)%inUse(subcell)) then

                   mainoldpops = thisOctal%newAtomLevel(subcell,:,:)



                   !          open(31, file="r.dat",status="unknown",form="formatted")
                   !          do ir = 1, 50
                   !             r = log10(20.d0*rsol/1.d10) + (log10(2000.d0*rSol/1.d10)-log10(20.d0*rsol/1.d10))*real(ir-1)/49.d0
                   !             r = 10.d0**r
                   !             posVec = VECTOR(r, 0.d0, 0.d0)
                   !             thisOctal => grid%octreeRoot
                   !             call findSubcellLocal(posVec, thisOctal, subcell)



                   if (thisOctal%inflow(subcell).and.(thisOctal%temperature(subcell) > 3000.)) then 


                      write(*,*) myrankGlobal, nt, subcell, " doing octal ",iOctal, " of ",nOctals




                      !.and.(.not.thisOctal%fixedTemperature(subcell))) then
                      nHit = 0
                      write(*,*) "nray ",nray
                      do iRay = 1, nRay
                         call getRay(grid, thisOCtal, subcell, position(iray), direction(iray), rayDeltaV(iray),&
                              ds(iRay), phi(iRay), i0(1:nRBBTrans,iRay), Hcol(iray), HeICol(iRay), HeIICol(iRay),&
                              nAtom, thisAtom, source, nSource, hitPhotosphere(iRay), sourceNumber(iray), &
                              cosTheta(iRay), weightFreq(iRay), weightOmega(iray), &
                              nRBBTrans, indexRBBTrans, indexAtom,  &
                              nfreq, freq, iCont(iray,1:nFreq), sobolevApprox, dble(iray-1)/dble(nRay-1))
                         if (hitPhotosphere(iray)) nHit = nHit + 1
                      enddo
                      write(*,*) "percent ",real(nhit)/real(nray)
                      iter = 0
                      neiter = 0
                      popsConverged = .false.
                      thisOctal%newatomLevel(subcell,:, :) = thisOctal%atomLevel(subcell,:, :)
                      ne = thisOctal%ne(subcell)

                      recalcJbar = .true.
                      firstCheckOnTau = .true.

                      do while (.not.popsConverged)
                         iter = iter + 1
                         mainoldpops = thisOctal%newatomLevel(subcell,1:nAtom,1:)

                         oldpops = thisOctal%newatomLevel(subcell,1:nAtom,1:)

                         if (recalcJbar) then
                            call calculateJbarCont(thisOctal, subcell, nAtom, thisAtom, ne, nray, ds, &
                                 freq, nfreq, &
                                 iCont, jnuCont, weightOmega)

                            thisOctal%JnuCont(subcell, :) = jnuCont(:)

                            !                            do i = 1, nfreq
                            !                               r = modulus(subcellCentre(thisOctal,subcell))
                            !                               w = 0.5d0*(1.d0 - sqrt(1.d0-source(1)%radius**2/r**2))
                            !                               thisOctal%jnuCont(subcell,i) = i_nu(source(1),freq(i),1)*w
                            !                            enddo

                            if (.not.sobolevApprox) then
                               do iRBB = 1, nRBBTrans
                                  iTrans = indexRBBTrans(iRBB)
                                  iAtom =  indexAtom(iRBB)
                                  call calculateJbar(grid, thisOctal, subcell, thisAtom(iAtom), nRay, position(1:nray), &
                                       direction(1:nray), rayDeltaV(1:nray), ds(1:nRay), &
                                       i0(iRBB,1:nRay), iTrans, thisOctal%jnuLine(subcell,iRBB), &
                                       thisOctal%newAtomLevel(subcell,iAtom,1:), &
                                       weightFreq(1:nRay) * weightOmega(1:nRay), tauAv)
                               enddo
                            endif


                         endif



                         neIter = neIter + 1
                         oldpops = thisOctal%newatomLevel(subcell,1:nAtom,1:)

                         newpops = thisOctal%newatomLevel(subcell, 1:nAtom, 1:)




                         call solveLevels(grid, source, thisOctal, subcell, newPops, &
                              thisOctal%jnuLine(subcell,1:nRBBTrans),  &
                              dble(thisOctal%temperature(subcell)), nAtom, thisAtom, ne, &
                              thisOctal%rho(subcell),&
                              jnuCont, freq, dfreq, nfreq, sobolevApprox)

                         dPops = newPops - thisOctal%newAtomLevel(subcell,1:nAtom,:) 


                         thisOctal%newAtomLevel(subcell,1:nAtom,:)  = &
                              thisOctal%newAtomLevel(subcell,1:nAtom,:)  + underCorrect * dPops


                         !                            ! improve convergence...
                         !                            thisOctal%atomLevel(subcell,:,:) = thisOctal%newatomLevel(subcell,:,:)!!!!!!!!!!!!!!!!!!!!!!!!!!


                         where (abs(thisOctal%newAtomLevel(subcell,1:nAtom,:)) < 1.d-30)
                            thisOctal%newAtomLevel(subcell,1:nAtom,:) = 1.d-30
                         end where

                         oldpops1 = oldpops2
                         oldpops2 = oldpops3
                         oldpops3 = oldpops4
                         oldpops4(1:nAtom,:) = thisOctal%newAtomLevel(subcell,1:nAtom,:)

                         if (mod(iter, iNgStep) == 0) then
                            !                               if (writeoutput) write(*,*) "Doing Ng acceleration step"
                            do iAtom = 1, nAtom
                               !                                  if (writeoutput) then
                               !                                     write(*,*) "oldpops 1",real(oldpops1(iatom, 1:6))
                               !                                     write(*,*) "oldpops 2",real(oldpops2(iatom, 1:6))
                               !                                     write(*,*) "oldpops 3",real(oldpops3(iatom, 1:6))
                               !                                     write(*,*) "oldpops 4",real(oldpops4(iatom, 1:6))
                               !                                  endifwrite(
                               call ngStep(thisOctal%newAtomLevel(subcell, iAtom, :), &
                                    oldpops1(iAtom, :), oldpops2(iAtom, :), &
                                    oldpops3(iAtom, :), oldpops4(iAtom, :), length=thisAtom(iAtom)%nLevels)
                               !                               if (writeoutput) write(*,*) "newpops ",real(thisOctal%newAtomLevel(subcell, iAtom, 1:6))
                            enddo
                         endif
                         newNe = tiny(newNe)
                         do iAtom = 1, nAtom
                            if (iAtom /= nAtom) then
                               if (thisAtom(iAtom)%nz /= thisAtom(iAtom+1)%nz) then
                                  newne =  newNe +  &
                                       SUM(thisOctal%newAtomLevel(subcell, iAtom, 1:thisAtom(iAtom)%nLevels-1)) &
                                       * dble(thisAtom(iAtom)%charge)
                                  newne = newne + thisOctal%newAtomLevel(subcell, iAtom, thisAtom(iAtom)%nLevels) &
                                       * dble((thisAtom(iAtom)%charge+1))
                               else
                                  newne =  newNe +  &
                                       SUM(thisOctal%newAtomLevel(subcell, iAtom, 1:thisAtom(iAtom)%nLevels-1)) &
                                       * dble(thisAtom(iAtom)%charge)
                               endif
                            else
                               newne =  newNe +  &
                                    SUM(thisOctal%newAtomLevel(subcell, iAtom, 1:thisAtom(iAtom)%nLevels-1)) &
                                    * dble(thisAtom(iAtom)%charge)
                               newne = newne + thisOctal%newAtomLevel(subcell, iAtom, thisAtom(iAtom)%nLevels) &
                                    * dble((thisAtom(iAtom)%charge+1))
                            endif
                         enddo
                         if (newNe < 0.d0) then
                            write(*,*) "newNe is negative"
                            newNE = TINY(newNE)
                         endif

                         ntot = 0.d0
                         ntot = ntot + SUM(thisOctal%newAtomLevel(subcell,1, &
                              1:thisAtom(1)%nLevels))
                         if (natom > 1) then
                            ntot = ntot + SUM(thisOctal%newAtomLevel(subcell,2, &
                                 1:thisAtom(2)%nLevels-1))
                         endif
                         if (natom  > 2) then
                            ntot = ntot + SUM(thisOctal%newAtomLevel(subcell,3, &
                                 1:thisAtom(3)%nLevels))
                         endif


                         fac = -1.d30
                         where (mainoldPops == 0.d0)
                            mainoldPops = 1.d-20
                         end where


                         fac = -1.d30
                         do iAtom = 1, nAtom
                            fac = max(fac,maxval(abs((thisOctal%newAtomLevel(subcell,iatom,1:thisAtom(iAtom)%nLevels-1) &
                                 - mainoldpops(iAtom,1:thisAtom(iAtom)%nLevels-1))/mainoldpops(iAtom,1:thisAtom(iAtom)%nLevels-1))))
                         enddo
                         dne = newne - ne
                         ne = ne + undercorrectne * dne
                         if ((fac < convergeTol).and.(iter > 1)) popsConverged = .true.
                         if (iter == maxIter) then
                            popsConverged = .true.
                            write(message,'(a,e12.5)') "Maximum number of iterations reached in pop solver. fac = ",fac
                            write(*,*) "fac, converged tol", fac,convergetol
                            write(*,*) trim(message)
                            call writeWarning(message)
                            write(*,*) "Iteration: ",iter
                            do iatom = 1, size(thisAtom)
                               write(*,*) "Atom: ",thisAtom(iatom)%name
                               write(*,*) "Number density: ",thisOctal%rho(subcell)*thisOctal%atomAbundance(subcell, iatom)
                               do i = 1, thisAtom(iatom)%nLevels-1


                                  nStar = boltzSahaGeneral(thisAtom(iAtom), i, ne, &
                                       dble(thisOctal%temperature(subcell))) * &
                                       thisOctal%newAtomLevel(subcell, iatom, thisAtom(iAtom)%nLevels)
                                  ratio = boltzSahaGeneral(thisAtom(iAtom), i, ne, &
                                       dble(thisOctal%temperature(subcell)))

                                  write(*,'(i2,1x,1p,7e12.3)') i,thisOctal%newAtomLevel(subcell,iatom,i), &
                                       mainoldpops(iatom,i), &
                                       abs((thisOctal%newAtomLevel(subcell,iAtom,i)-max(mainoldpops(iAtom,i),1.d-20)) &
                                       / max(mainoldpops(iAtom,i),1.d-20)), &
                                       thisOctal%newAtomLevel(subcell,iatom,i)/max(nstar,1.d-20), &
                                       thisOctal%newAtomLevel(subcell,iAtom,i)-mainoldpops(iAtom,i),nstar,ratio

                               enddo
                            enddo
                            !                           if (thisatom(1)%indetailedbalance(4)) then
                            !                              write(*,*) "Halpha is in detailed balance",tauHalpha
                            !                           else
                            !                              write(*,*) "Halpha is NOT in detailed balance",tauHalpha
                            !                           endif
                            write(*,*) "log Ne: ",log10(newne)
                            write(*,*) "T: ",thisOctal%temperature(subcell)
                            write(*,*) "R: ",modulus(subcellCentre(thisOctal,subcell))/rCore
                            write(*,*) "log(H I/ Ntot): ", &
                                 log10(SUM(thisOctal%newAtomLevel(subcell,1,1:thisAtom(1)%nlevels-1)) /ntot), &
                                 log10(SUM(thisOctal%newAtomLevel(subcell,1,1:thisAtom(1)%nlevels-1)))
                            if (nAtom > 1) &
                                 write(*,*) "log(He I/ Ntot): ", &
                                 log10(SUM(thisOctal%newAtomLevel(subcell,2,1:thisAtom(2)%nlevels-1)) / ntot), &
                                 SUM(thisOctal%newAtomLevel(subcell,2,1:thisAtom(2)%nlevels-1))
                            if (nAtom > 2) &
                                 write(*,*) "log(He II/ Ntot): ", &
                                 log10(SUM(thisOctal%newAtomLevel(subcell,3,1:thisAtom(3)%nlevels-1)) / ntot), &
                                 SUM(thisOctal%newAtomLevel(subcell,3,1:thisAtom(3)%nlevels-1))
                            if (nAtom > 2) &
                                 write(*,*) "log(He III/ Ntot): ", &
                                 log10(thisOctal%newAtomLevel(subcell,3,thisAtom(3)%nlevels) / ntot), &
                                 thisOctal%newAtomLevel(subcell,3,thisAtom(3)%nlevels)
                         endif

                      enddo

                      !                      write(*,*) "Main iteration route converged after ", iter, " iterations"

                      thisOctal%ne(subcell) = ne
                      if (debug) then
                         write(*,*) "Iteration: ",iter
                         do iatom = 1, size(thisAtom)
                            write(*,*) "Atom: ",thisAtom(iatom)%name
                            write(*,*) "Number density: ",thisOctal%rho(subcell)*thisOctal%atomAbundance(subcell, iatom)
                            do i = 1, thisAtom(iatom)%nLevels-1


                               nStar = boltzSahaGeneral(thisAtom(iAtom), i, ne, &
                                    dble(thisOctal%temperature(subcell))) * &
                                    thisOctal%newAtomLevel(subcell, iatom, thisAtom(iAtom)%nLevels)
                               ratio = boltzSahaGeneral(thisAtom(iAtom), i, ne, &
                                    dble(thisOctal%temperature(subcell)))

                               write(*,'(i2,1x,1p,7e12.3)') i,thisOctal%newAtomLevel(subcell,iatom,i), &
                                    mainoldpops(iatom,i), &
                                    abs((thisOctal%newAtomLevel(subcell,iAtom,i)-max(mainoldpops(iAtom,i),1.d-20)) &
                                    / max(mainoldpops(iAtom,i),1.d-20)), &
                                    thisOctal%newAtomLevel(subcell,iatom,i)/max(nstar,1.d-20), &
                                    thisOctal%newAtomLevel(subcell,iAtom,i)-mainoldpops(iAtom,i),nstar,ratio

                            enddo
                         enddo
                         !                           if (thisatom(1)%indetailedbalance(4)) then
                         !                              write(*,*) "Halpha is in detailed balance",tauHalpha
                         !                           else
                         !                              write(*,*) "Halpha is NOT in detailed balance",tauHalpha
                         !                           endif
                         write(*,*) "log Ne: ",log10(newne)
                         write(*,*) "T: ",thisOctal%temperature(subcell)
                         write(*,*) "R: ",modulus(subcellCentre(thisOctal,subcell))/rCore
                         write(*,*) "log(H I/ Ntot): ", &
                              log10(SUM(thisOctal%newAtomLevel(subcell,1,1:thisAtom(1)%nlevels-1)) /ntot), &
                              log10(SUM(thisOctal%newAtomLevel(subcell,1,1:thisAtom(1)%nlevels-1)))
                         if (nAtom > 1) &
                              write(*,*) "log(He I/ Ntot): ", &
                              log10(SUM(thisOctal%newAtomLevel(subcell,2,1:thisAtom(2)%nlevels-1)) / ntot), &
                              SUM(thisOctal%newAtomLevel(subcell,2,1:thisAtom(2)%nlevels-1))
                         if (nAtom > 2) &
                              write(*,*) "log(He II/ Ntot): ", &
                              log10(SUM(thisOctal%newAtomLevel(subcell,3,1:thisAtom(3)%nlevels-1)) / ntot), &
                              SUM(thisOctal%newAtomLevel(subcell,3,1:thisAtom(3)%nlevels-1))
                         if (nAtom > 2) &
                              write(*,*) "log(He III/ Ntot): ", &
                              log10(thisOctal%newAtomLevel(subcell,3,thisAtom(3)%nlevels) / ntot), &
                              thisOctal%newAtomLevel(subcell,3,thisAtom(3)%nlevels)
                      endif


!                      if (myRankisZero) then
                         open(69, file=ifilename, status="old", position = "append", form="formatted")
                         rCore = real(source(1)%radius)
                         if (nAtom == 1) write(69,'(6f10.4)') log10(modulus(subcellCentre(thisOctal,subcell))/rCore), &
                              log10(SUM(thisOctal%newAtomLevel(subcell,1,1:thisAtom(1)%nlevels-1)) /ntot)

                         if (nAtom == 2) write(69,'(6f10.4)') log10(modulus(subcellCentre(thisOctal,subcell))/rCore), &
                              log10(SUM(thisOctal%newAtomLevel(subcell,1,1:thisAtom(1)%nlevels-1)) /ntot), &
                              log10(SUM(thisOctal%newAtomLevel(subcell,2,1:thisAtom(2)%nlevels-1)) / ntot)

                         if (nAtom == 3) write(69,'(6f10.4)') log10(modulus(subcellCentre(thisOctal,subcell))/rCore), &
                              log10(SUM(thisOctal%newAtomLevel(subcell,1,1:thisAtom(1)%nlevels-1)) /ntot), &
                              log10(SUM(thisOctal%newAtomLevel(subcell,2,1:thisAtom(2)%nlevels-1)) / ntot), &
                              log10(SUM(thisOctal%newAtomLevel(subcell,3,1:thisAtom(3)%nlevels-1)) / ntot), &
                              log10(thisOctal%newAtomLevel(subcell,3,thisAtom(3)%nlevels) / ntot), &
                              log10(thisOctal%rho(subcell))
                         close(69) 
                         itmp = itmp + 1
                         !                           write(tfilename,'(a,i2.2,a)') "jbar",itmp,".dat"
                         !                           open(69, file=tfilename, status="unknown",form="formatted")
                         !                           x1 = sqrt(max(0.d0,(1.d0 - source(1)%radius**2 / modulus(subcellCentre(thisOctal,subcell))**2)))
                         !                           w = 0.5d0*(1.d0 - x1)
                         !                           do i = 1, nFreq
                         !                              write(69,*) freq(i),thisOctal%jnucont(subcell,i), w*i_nu(source(1), freq(i), 1), &
                         !                                   bnu(freq(i),dble(thisOctal%temperature(subcell)))
                         !                           enddo
                         !                           close(69)
!                      endif

                      !                call locate(freq,nfreq,cspeed/6562.8d-8,ifreq)
                      !                nStar = boltzSahaGeneral(thisAtom(1), 6, thisOctal%ne(subcell), &
                      !                     dble(thisOctal%temperature(subcell))) * &
                      !                     thisOctal%newAtomLevel(subcell, 1, thisAtom(1)%nLevels)
                      !                write(31,*) real(r*1.e10), real(thisOctal%ne(subcell)), real(thisOctal%newAtomLevel(subcell,1,1:6)),&
                      !                     real(jnuCont(ifreq)),real(nstar)

                      !             enddo
                      !             close(31)
                      !             stop
                   endif
                endif

             end do
          enddo
                !$OMP END DO
                !$OMP BARRIER



                deallocate(oldPops)
                deallocate(mainoldPops)
                deallocate(newPops)
                deallocate(dPops)
                deallocate(jnuCont)
                deallocate(ds)
                deallocate(phi)
                deallocate(rayDeltaV)
                deallocate(i0)
                deallocate(Hcol)
                deallocate(HeIcol)
                deallocate(HeIIcol)
                deallocate(sourceNumber)
                deallocate(cosTheta)
                deallocate(weightFreq)
                deallocate(weightOmega)
                deallocate(hitPhotosphere)
                deallocate(iCont)
                deallocate(position)
                deallocate(direction)
                deallocate(oldpops1, oldpops2, oldpops3, oldpops4)

                !$OMP END PARALLEL

                !          if (doTuning) call tune(6, "One octal iteration")  ! start a stopwatch

#ifdef MPI
             enddo
             endif

                write(*,*) myrankGlobal, " now waiting at barrier"
                call MPI_BARRIER(MPI_COMM_WORLD, ierr) 
                if(my_rank == 0) write(*,*) "Updating MPI grids"

                call countVoxels(grid%octreeRoot,nOctal,nVoxels)
                nVoxels = 0
                do i = 1, SIZE(octalArray)

                   thisOctal => octalArray(i)%content

                   do iSubcell = 1, thisOctal%maxChildren
                      if (.not.thisOctal%hasChild(iSubcell)) then
                         nVoxels = nVoxels + 1
                      endif
                   end do
                enddo
                allocate(tArrayd(1:nVoxels))
                allocate(tempArrayd(1:nVoxels))
                tArrayd = 0.d0
                tempArrayd = 0.d0
                do iAtom = 1, nAtom
                   do i = 1, thisAtom(iAtom)%nLevels
                      tArrayd = 0.d0
                      call packAtomLevel(octalArray, nVoxels, tArrayd,  iAtom, i, doneByThisThread)
                      call MPI_ALLREDUCE(tArrayd,tempArrayd,nVoxels,MPI_DOUBLE_PRECISION,&
                           MPI_SUM,MPI_COMM_WORLD,ierr)
                      tArrayd = tempArrayd
                      call unpackAtomLevel(octalArray, nVoxels, tArrayd, iAtom, i)
                   enddo
                enddo
                call calcNe(grid%octreeRoot, thisAtom)
                do i = 1, nFreq
                   tArrayd = 0.d0
                   call packJnu(octalArray, nVoxels, tArrayd, i, doneByThisThread)
                   call MPI_ALLREDUCE(tArrayd,tempArrayd,nVoxels,MPI_DOUBLE_PRECISION,&
                        MPI_SUM,MPI_COMM_WORLD,ierr)
                   tArrayd = tempArrayd
                   call unpackJnu(octalArray, nVoxels, tArrayd, i)
                enddo


                call packBiasLine3d(octalArray, nVoxels, tArrayd, doneByThisThread)
                call MPI_ALLREDUCE(tArrayd,tempArrayd,nVoxels,MPI_DOUBLE_PRECISION,&
                     MPI_SUM,MPI_COMM_WORLD,ierr)
                if (my_rank == 0) write(*,*) "allreduce biasline3d done"
                tArrayd = tempArrayd
                call unpackBiasLine3d(octalArray, nVoxels, tArrayd)


                deallocate(tArrayd, tempArrayd)

                if(my_rank == 0) write(*,*) "Done updating"
#endif

                maxFracChange = -1.d30
                nInUse = 0 ; nConverged = 0
                call swapPops(grid%octreeRoot, gridtolerance, nInUse, nConverged)
                percentageConverged = 100.d0 * dble(nConverged)/dble(nInUse)
                write(ifilename,'(a,i2.2,a)') "fracchange",idump,".vtk"
                call writeVTKfile(grid,ifilename, valueTypeString = (/"adot"/))
                write(*,*) myrankGlobal," Percentage converged: ",percentageConverged, ninuse, nconverged

                if (myRankIsZero) &
                     call writeAmrGrid("atom_tmp.grid",.false.,grid)


                if (myRankisZero) then
                   open(69, file="cmf_convergence.dat", status="old", position = "append", form="formatted")
                   write(69,'(i10, 1p, e10.2, 0p,  f10.2, i10, l10)') &
                        nIter,  gridtolerance, real(percentageConverged), nRay, fixedRays
                   close(69)
                endif

                if (percentageConverged > 99.d0) then
                   gridConverged = .true.
                endif
                !          gridconverged = .true.
                !          write(*,*) "forcing convergence !!!!!!!!!!"

                if (sobolevApprox.and.(istage==nstage)) gridConverged = .true.

                !         deallocate(ds, phi, i0, sourceNumber, cosTheta, hitPhotosphere, &
                !               weightFreq, weightOmega, hcol, heicol, heiicol, iCont)
                !         deallocate(position, direction, rayDeltaV)

                if (.not.gridConverged) then
                   if (.not.fixedRays) nRay = nRay * 2
                endif
                if (nRay > maxRay) then
                   nRay = maxRay
                   call writeWarning("Maximum number of rays exceeded - capping")
                endif

                !          gridconverged = .true.
                !          write(*,*) "!!!!!!!!!!!!! Forcing exit after only one iteration"


                if (doTuning)  call tune(6, "One cmf iteration")  ! stop a stopwatch
             enddo
          enddo
666       continue

          call writeInfo( "ATOM loop done.")
        end subroutine atomLoop

  recursive  subroutine  swapPops(thisOctal, tolerance, nInuse, nConverged)
    type(octal), pointer   :: thisOctal
    type(octal), pointer  :: child 
    integer :: subcell, i, j, iAtom
    real(double) :: maxFrac, temp, tolerance
    integer :: nInUse, nConverged
  
    do subcell = 1, thisOctal%maxChildren
       if (thisOctal%hasChild(subcell)) then
          ! find the child
          do i = 1, thisOctal%nChildren, 1
             if (thisOctal%indexChild(i) == subcell) then
                child => thisOctal%child(i)
                call swapPops(child, tolerance, nInUse, nConverged)
                exit
             end if
          end do
       else

          if (.not.associated(thisOctal%adot)) then
             allocate(thisOctal%adot(1:thisOctal%maxChildren))
             thisOctal%adot = 0.d0
          endif
          
          if (thisOctal%inflow(subcell).and.(thisOctal%temperature(subcell) > 3000.)) then
             nInuse = nInuse + 1
             maxFrac = -1.d30
             do iAtom = 1, size(thisOctal%newAtomLevel,2)
                do j = 1 , size(thisOctal%newAtomLevel,3)
                   write(30+myrankGlobal,*) iatom,j,thisOctal%newAtomLevel(subcell,iatom,j), thisOctal%atomLevel(subcell,iatom,j)
                   if (thisOctal%atomLevel(subcell,iAtom,j) > 1.d-20) then
                      temp = abs((thisOctal%newatomLevel(subcell,iAtom,j) - &
                           thisOctal%atomLevel(subcell,iAtom,j)) / &
                           thisOctal%atomLevel(subcell,iAtom,j))
                      thisOctal%adot(subcell) = temp
                      maxFrac = max(temp, maxFrac)
                   endif
                enddo
             enddo
             if (maxFrac < tolerance) then
                nConverged = nConverged + 1
             endif
          endif
          thisOctal%atomLevel(subcell,:,:) = &
               thisOctal%newatomLevel(subcell,:,:)
       endif
    enddo
  end subroutine swapPops

  recursive  subroutine checkVelocityInterp(thisOctal, grid)
    type(GRIDTYPE) :: grid
    type(octal), pointer   :: thisOctal
    type(octal), pointer  :: child 
    integer :: subcell, i
    type(VECTOR) :: interpVel, rVec
    real(double) :: diff
  
    do subcell = 1, thisOctal%maxChildren
       if (thisOctal%hasChild(subcell)) then
          ! find the child
          do i = 1, thisOctal%nChildren, 1
             if (thisOctal%indexChild(i) == subcell) then
                child => thisOctal%child(i)
                call checkVelocityInterp(child, grid)
                exit
             end if
          end do
       else
          rVec = subcellCentre(thisOctal, subcell)
          interpVel = amrGridVelocity(grid%octreeRoot, rVec, startOctal = thisOctal, actualSubcell = subcell) 
          if (modulus(thisOctal%velocity(subcell)) /= 0.d0) then
             diff = modulus(thisOctal%velocity(subcell) - interpVel)/modulus(thisOctal%velocity(subcell))
             if (diff > 0.1d0) then
                write(*,*) "Interpolated and grid centre velocities differ by more than 10%  ",diff
                write(*,*) "centre ", cspeed*thisOctal%velocity(subcell)
                write(*,*) "interp ",cspeed * interpVel
                write(*,*) "depth ", thisOctal%ndepth
                write(*,*) "dphi ",thisOctal%dphi * radtodeg
             endif
          endif
       endif
    enddo
  end subroutine checkVelocityInterp

  recursive  subroutine  checkInflow(thisOctal, nsource, source)
    integer :: nsource
    type(SOURCETYPE) :: source(:)
    type(octal), pointer   :: thisOctal
    type(octal), pointer  :: child 
    integer :: subcell, i

    do subcell = 1, thisOctal%maxChildren
       if (thisOctal%hasChild(subcell)) then
          ! find the child
          do i = 1, thisOctal%nChildren, 1
             if (thisOctal%indexChild(i) == subcell) then
                child => thisOctal%child(i)
                call checkInflow(child, nsource, source)
                exit
             end if
          end do
       else
          thisOctal%inflow(subcell) = thisOctal%inflow(subcell).and. &
               (.not.insidesource(thisOctal, subcell, nsource, Source))
       endif
    enddo
  end subroutine checkInflow

  recursive  subroutine  calcEtaLine(thisOctal, thisAtom, nAtom, iAtom, iTrans)
    type(MODELATOM) :: thisAtom(:)
    integer :: nAtom
    integer :: iTrans
    type(octal), pointer   :: thisOctal
    type(octal), pointer  :: child 
    integer :: subcell, i, iUpper, iAtom
    real(double) :: a, bul, blu
    real(double) :: etaLine

    a = 0.d0; blu = 0.d0; bul = 0.d0
    do subcell = 1, thisOctal%maxChildren
       if (thisOctal%hasChild(subcell)) then
          ! find the child
          do i = 1, thisOctal%nChildren, 1
             if (thisOctal%indexChild(i) == subcell) then
                child => thisOctal%child(i)
                call calcEtaLine(child, thisAtom, nAtom, iAtom, iTrans)
                exit
             end if
          end do
       else

          thisOctal%etaLine(subcell) = 1.d-30
          if (thisOctal%inflow(subcell)) then
             call returnEinsteinCoeffs(thisAtom(iatom), iTrans, a, Bul, Blu)
             iUpper = thisAtom(iatom)%iUpper(iTrans)
             etaLine = (hCgs/fourPi) * a * thisAtom(iatom)%transFreq(iTrans)
             etaLine = etaLine * thisOctal%atomLevel(subcell, iAtom,iUpper)
             thisOctal%etaLine(subcell) = etaLine * 1.d10
          endif
       endif
    enddo
  end subroutine calcEtaLine

  recursive  subroutine  removeInnerEtaChi(thisOctal, radius)
    type(octal), pointer   :: thisOctal
    type(octal), pointer  :: child 
    real(double) :: radius
    integer :: subcell, i

    do subcell = 1, thisOctal%maxChildren
       if (thisOctal%hasChild(subcell)) then
          ! find the child
          do i = 1, thisOctal%nChildren, 1
             if (thisOctal%indexChild(i) == subcell) then
                child => thisOctal%child(i)
                call removeInnerEtaChi(child, radius)
                exit
             end if
          end do
       else

          if (modulus(subcellCentre(thisOctal, subcell)) < radius) then

             thisOctal%etaLine(subcell) = 1.d-30
             thisOctal%chiLine(subcell) = 1.d-30
             thisOctal%etaCont(subcell) = 1.d-30
             thisOctal%kappaAbs(subcell,1) = 1.d-30
             thisOctal%kappaSca(subcell,1) = 1.d-30
          endif
       endif
    enddo
  end subroutine removeInnerEtaChi

  recursive  subroutine  calcChiLine(thisOctal, thisAtom, nAtom, iAtom, iTrans)
    type(MODELATOM) :: thisAtom(:)
    integer :: nAtom
    integer :: iTrans
    type(octal), pointer   :: thisOctal
    type(octal), pointer  :: child 
    integer :: subcell, i, iUpper, iAtom
    real(double) :: a, bul, blu
    real(double) :: alphaNu
    integer :: ilower
    real(double) :: nlower, nupper
    a = 0.d0; blu = 0.d0; bul = 0.d0
    do subcell = 1, thisOctal%maxChildren
       if (thisOctal%hasChild(subcell)) then
          ! find the child
          do i = 1, thisOctal%nChildren, 1
             if (thisOctal%indexChild(i) == subcell) then
                child => thisOctal%child(i)
                call calcChiLine(child, thisAtom, nAtom, iAtom, iTrans)
                exit
             end if
          end do
       else

          thisOctal%chiline(subcell) = 1.d-30
          if (thisOctal%inflow(subcell)) then
             iUpper = thisAtom(iatom)%iUpper(iTrans)
             iLower = thisAtom(iatom)%iLower(iTrans)
             nLower = thisOctal%atomLevel(subcell,iAtom, iLower)
             nUpper = thisOctal%atomLevel(subcell,iAtom, iUpper)
             
             alphanu = (hCgs*thisAtom(iAtom)%transFreq(iTrans)/fourPi) 
             call returnEinsteinCoeffs(thisAtom(iatom), iTrans, a, Bul, Blu)
             
             alphanu = alphanu * (nLower * Blu - nUpper * Bul)
             thisOctal%chiLine(subcell) = alphanu * 1.d10
          endif
!          write(45,*) modulus(subcellCentre(thisOctal,subcell)), thisOctal%chiline(subcell)
          
       endif
    enddo
  end subroutine calcChiLine

  recursive  subroutine  calcNe(thisOctal, thisAtom)
    type(MODELATOM) :: thisAtom(:)
    type(octal), pointer   :: thisOctal
    type(octal), pointer  :: child 
    integer :: subcell, i

    do subcell = 1, thisOctal%maxChildren
       if (thisOctal%hasChild(subcell)) then
          ! find the child
          do i = 1, thisOctal%nChildren, 1
             if (thisOctal%indexChild(i) == subcell) then
                child => thisOctal%child(i)
                call calcNe(child, thisAtom)
                exit
             end if
          end do
       else

          thisOctal%ne(subcell) = returnNe(thisOctal%atomLevel(subcell,:,:),thisAtom)

       endif
    enddo
  end subroutine calcNe


  recursive  subroutine calcContinuumOpacities(thisOctal, thisAtom, nAtom, freq)
    use inputs_mod, only : opticallyThickContinuum
    type(MODELATOM) :: thisAtom(:)
    real(double) :: freq
    real(double) :: nstar(10,50)
    integer :: nAtom
    type(octal), pointer   :: thisOctal
    type(octal), pointer  :: child 
    integer :: subcell, i, iAtom, iLevel

    do subcell = 1, thisOctal%maxChildren
       if (thisOctal%hasChild(subcell)) then
          ! find the child
          do i = 1, thisOctal%nChildren, 1
             if (thisOctal%indexChild(i) == subcell) then
                child => thisOctal%child(i)
                call calcContinuumOpacities(child, thisAtom, nAtom, freq)
                exit
             end if
          end do
       else



          thisOctal%kappaAbs(subcell,1) = 1.d-30
          thisOctal%kappaSca(subcell,1) = 1.d-30
          thisOctal%etaCont(subcell) = 1.d-30

          if (thisOctal%inflow(subcell).and.(thisOctal%temperature(subcell) > 2000.0)) then
          do iatom = 1, size(thisAtom)
             do iLevel = 1, thisAtom(iatom)%nLevels-1
                nStar(iatom,ilevel) = boltzSahaGeneral(thisAtom(iAtom), iLevel, thisOctal%ne(subcell), &
                     dble(thisOctal%temperature(subcell))) * &
                     thisOctal%atomLevel(subcell, iatom, thisAtom(iAtom)%nLevels)
             enddo
          enddo
          if (opticallyThickContinuum) then
             thisOctal%kappaAbs(subcell, 1) = bfOpacity(freq, nAtom, thisAtom, thisOctal%atomLevel(subcell,:,:), nstar, &
                  thisOctal%ne(subcell), dble(thisOctal%temperature(subcell))) * 1.d10

             thisOctal%kappaSca(subcell, 1) = 1.d-30 !e-scattering inc in absorption
             thisOctal%etaCont(subcell)  = bfEmissivity(freq, nAtom, thisAtom,  thisOctal%atomLevel(subcell,:,:), nstar, &
                  dble(thisOctal%temperature(subcell)), thisOctal%ne(subcell)) * 1.d10
          endif

       endif
       endif
    enddo
  end subroutine calcContinuumOpacities

  recursive subroutine  allocateLevels(grid, thisOctal, nAtom, thisAtom, nRBBTrans, nFreq, ionized)
    use inputs_mod, only : Xabundance, Yabundance
    use stateq_mod, only : z_hi
    type(GRIDTYPE) :: grid
    type(MODELATOM) :: thisAtom(:)
    type(octal), pointer   :: thisOctal
    type(octal), pointer  :: child 
    typE(VECTOR) :: rvec
    real(double) :: ne, n_h, ntot, phit, t
    real(double), parameter  :: CI = 2.07d-16   ! in cgs units
    integer :: i, subcell, j
    integer :: nAtom
    integer :: nRBBTrans
    integer :: iatom
    logical :: ionized
    integer :: nFreq


    if ( thisOctal%nChildren > 0) then
       do i = 1, thisOctal%nChildren
          child => thisOctal%child(i)
          call  allocateLevels(grid, child, nAtom, thisAtom, nRBBTrans, nfreq, ionized)
       end do
    end if
    call allocateAttribute(thisOctal%atomAbundance,thisOctal%maxchildren, nAtom)
    thisOctal%atomAbundance(:, 1) = Xabundance / ((Xabundance + 4.d0*Yabundance) * mHydrogen)
    if (nAtom > 1) then
       thisOctal%atomAbundance(:, 2:nAtom) =  Yabundance / ((Xabundance + 4.d0 * Yabundance) * mHydrogen)
       !assume higher atoms are helium
    endif
    call allocateAttribute(thisOctal%microturb, thisOctal%maxChildren)
    call allocateAttribute(thisOctal%etaLine, thisOctal%maxChildren)
    call allocateAttribute(thisOctal%chiLine, thisOctal%maxChildren)
    call allocateAttribute(thisOctal%ne, thisOctal%maxChildren)


    call allocateAttribute(thisOctal%atomLevel, thisOctal%maxChildren, nAtom, maxval(thisAtom(1:nAtom)%nLevels))
    call allocateAttribute(thisOctal%newatomLevel, thisOctal%maxChildren, nAtom, maxval(thisAtom(1:nAtom)%nLevels))


    call allocateAttribute(thisOctal%jnuLine, thisOctal%maxChildren, nRBBTrans)
    call allocateAttribute(thisOctal%jnuCont, thisOctal%maxChildren, nFreq)

    call allocateAttribute(thisOctal%microturb, thisOctal%maxChildren)

    if (ionized) then
       thisOctal%ne = thisOctal%rho(1:SIZE(thisOctal%ne))/mHydrogen
    else
       thisOctal%ne = tiny(1.d-30 * thisOctal%rho(1:SIZE(thisOctal%ne))/mHydrogen)
    endif


    do subcell = 1, thisOctal%maxChildren
       t = thisOctal%temperature(subcell)
       rVec = subcellCentre(thisOctal, subcell)
       !       write(*,*) " t ",t , " r ",modulus(rVec)/grid%rcore
       N_H = thisOctal%rho(subcell)/mHydrogen  ! number density of HI plus number density of HII
       if (real(hydE0eV,kind=double)/(kev*T) < 60.d0) then 
          phiT = CI*Z_HI(10,T)*(T**(-1.5))*EXP(real(hydE0eV,kind=double)/(kev*T))

          ! Solving for phi(T)*ne^2 + 2ne -nTot =0 and ne+N_H = nTot for ne where
          ! nTot is the number density of particles includeing all species.
          ! ==> phi(T)*ne^2 + ne - N_H =0
          ! Th physical solution  is chosen out of two ...  
          !    Ne = (sqrt(nTot*phiT+1.0_db) -1.0_db)/phiT
          Ne = (sqrt(4.0_db*N_H*phiT+1.0_db) -1.0_db)/(2.0_db*phiT)
       else 
          ne = tiny(ne)
       endif
       !       nTot = Ne + N_H
       !    Ne = min(Ne, nTot)     ! to avoid unphysical solution.
       !    if (Ne<=0) Ne =nTot   ! to avoid unphysical solution.
       if (Ne<=0) Ne =1.0d-40 ! to avoid unphysical solution.
       !       thisOctal%ne(subcell) = ne
       !          write(*,*) "ne ",thisOctal%ne(subcell),4.0_db*N_H*phiT+1.0_db, t,phit,n_h

       do j = 1, 5
          do iAtom = 1, nAtom

             ntot = thisOctal%atomAbundance(subcell,iAtom) * thisOctal%rho(subcell)

             do i = 1, thisAtom(iatom)%nLevels-1

                thisOctal%atomLevel(subcell, iAtom,i) = max(1.d-20,boltzSahaEquationAbsolute(thisAtom(iAtom), nTot, i, &
                     thisOctal%ne(subcell), &
                     dble(thisOctal%temperature(subcell))))
             enddo
             thisOctal%atomLevel(subcell, iAtom, thisAtom(iatom)%nLevels) = &
                  max(1.d-20,sahaEquationNextIon(thisAtom(iatom), nTot, &
                  thisOctal%ne(subcell), dble(thisOctal%temperature(subcell))))
          enddo
          thisOctal%ne(subcell) = returnNe(thisOctal%atomLevel(subcell,:,:),thisAtom)
          
       enddo
    enddo
    thisOctal%newAtomLevel = thisOctal%atomLevel

  end subroutine allocateLevels
  

  subroutine randomRayDirection(probTowardsSource, point, source, nSource, direction, weight, fracRay)
    type(VECTOR) :: point, direction, toStar
    type(SOURCETYPE) :: source(:)
    integer :: nSource
    real(double) :: probTowardsSource, weight
    real(double), optional :: fracRay
    integer :: i
    real(double) :: chanceSource
    real(double) :: omegaSubtendedBySource
    real(double) :: theta, dOmega, r, cosTheta, ang
    logical :: hitCore
    integer :: nBug

    omegaSubtendedBySource = 0.d0
    do i = 1 , nSource
       theta = asin(source(i)%radius/modulus(point-source(i)%position))
       domega = twoPi * (1.d0 - cos(theta))
       omegaSubtendedBySource = omegaSubtendedbySource + dOmega
    enddo


    chanceSource = omegaSubtendedBySource / fourPi

    weight = 1.d0
 
    if (PRESENT(fracRay)) then
       r = fracRay
    else
       call randomNumberGenerator(getDouble=r)
    endif

    if (r < probTowardsSource) then
       weight = chanceSource/probTowardsSource
       call randomNumberGenerator(getDouble=r)
       i = int(r*real(nsource))+1
       toStar = source(i)%position - point
       call normalize(toStar)
       theta = asin(min(1.d0, max(-1.d0,source(i)%radius/modulus(point-source(i)%position))))
       cosTheta = cos(theta)
       hitCore = .false.
       nbug = 0
       do while(.not.hitCore)
          direction = randomUnitVector()
          ang = acos(min(1.d0, max(-1.d0, direction.dot.toStar)))
          if (ang < theta) hitCore = .true.
          nbug = nbug  + 1
          if (nbug > 10000000) then
             write(*,*) "bug in direction to star"
             direction = toStar
             exit
          endif
       enddo
    else
       weight = (1.d0-chanceSource)/(1.d0-probTowardsSource)
       hitCore = .true.
       do while(hitCore)
          direction = randomUnitVector()
          do i = 1, nSource
             call distanceToSource(source, i, point, direction, hitCore, r)
          enddo
       end do
    endif
  end subroutine randomRayDirection



!!$  function intensityAlongRay(position, direction, grid, thisAtom, nAtom, iAtom, iTrans, deltaV, source, nSource, &
!!$       nFreq, freqArray,forceFreq, occultingDisc) result (i0)
!!$    use inputs_mod, only : lineOff,  mie, holeRadius
!!$    use amr_mod, only: distanceToGridFromOutside, returnKappa
!!$    use utils_mod, only : findIlambda
!!$    use atom_mod, only : bnu
!!$    logical ::     justPhotosphere
!!$    type(VECTOR) :: position, direction, pvec, photoDirection
!!$    type(GRIDTYPE) :: grid
!!$    logical, optional :: occultingDisc
!!$    integer :: nSource
!!$    real(double) :: freqArray(:)
!!$    real(double), optional :: forceFreq
!!$    integer :: nFreq
!!$    type(SOURCETYPE) :: source(:)
!!$    real(double) :: transitionFreq
!!$    integer :: iAtom, nAtom
!!$    type(MODELATOM) :: thisAtom(:)
!!$    real(double) :: disttoGrid
!!$    integer :: itrans, iFreq
!!$    real(double) :: totDist
!!$    logical :: hitSource
!!$    real(double) :: i0
!!$    type(OCTAL), pointer :: thisOctal, startOctal !, endOctal
!!$    !    integer :: endSubcell
!!$    integer :: subcell
!!$    real(double) :: costheta
!!$    type(VECTOR) :: currentPosition, thisPosition, thisVel, oldposition
!!$    type(VECTOR) :: rayVel, startVel, endVel, endPosition !, rvec
!!$    real(double) :: alphanu, snu, jnu
!!$    integer :: iLower , iUpper
!!$    real(double) :: gUpper, gLower
!!$    real(double) :: dv, deltaV
!!$    integer :: i, icount
!!$    real(double) :: tval
!!$    real(double), allocatable :: distArray(:)
!!$    integer :: nTau
!!$    real(double) :: nLower, nUpper
!!$    real(double) :: dTau, etaline, tau
!!$    real(double) :: intensityIntegral
!!$    real(double) :: dvAcrossCell
!!$    real(double) :: dv1, dv2
!!$    real(double) :: a, bul, blu
!!$    integer :: nHatom,nHeIAtom, nHeIIAtom
!!$    real(double) :: distToSource,disttoDisc
!!$    integer :: sourcenumber
!!$    integer :: iElement
!!$    logical :: endLoopAtPhotosphere
!!$    real(double) :: nstar(10,50), rhoCol
!!$    real(double) :: bfOpac, bfEmiss
!!$    real(double) :: dustOpac, dustEmiss
!!$    integer :: ilambda
!!$    real(double) :: transitionLambda, kappaSca, kappaAbs, kappaExt
!!$    real(double) :: tauStep, tauTmp, iStep, fac
!!$    integer :: j, k
!!$    logical :: ok, closeToResonance, passThroughResonance
!!$
!!$    i0 = tiny(i0)
!!$    justPhotosphere = .false.
!!$
!!$    hitsource = .false.; disttosource = 0.d0; sourceNumber = 0
!!$    a = 0.d0; blu = 0.d0; bul = 0.d0
!!$    nHAtom = 0
!!$    nHeIAtom = 0
!!$    nHeIIAtom = 0
!!$    do i = 1, nAtom
!!$       if (thisAtom(i)%name == "HI") nHatom = i
!!$       if (thisAtom(i)%name == "HeI") nHeIatom = i
!!$       if (thisAtom(i)%name == "HeII") nHeIIatom = i
!!$    enddo
!!$
!!$    transitionFreq = thisAtom(iAtom)%transFreq(iTrans)
!!$
!!$    if (PRESENT(forceFreq)) then
!!$       transitionFreq = forceFreq
!!$    endif
!!$
!!$    call locate(freqArray, nFreq, transitionFreq, iFreq)
!!$
!!$    transitionLambda = (cSpeed/transitionFreq) /angstromTocm
!!$    ilambda = 1
!!$    if (mie) iLambda = findIlambda(real(transitionLambda), grid%lamArray, grid%nLambda, ok)
!!$
!!$
!!$    distToGrid = distanceToGridFromOutside(grid, position, direction)
!!$
!!$    currentposition = position
!!$    distToDisc = 1.d30
!!$    if ((currentposition.dot.direction) < 0.d0) then
!!$       if (direction%z /= 0.d0) then
!!$          distToDisc = abs(currentPosition%z/direction%z)
!!$          oldPosition = currentPosition + distToDisc * direction
!!$          if (sqrt(oldPosition%x**2 + oldPosition%y**2) < (2.d0*grid%octreeRoot%subcellSize)) then
!!$             distToDisc = 1.d30
!!$          endif
!!$       else
!!$          distToDisc = 1.d30
!!$       endif
!!$    endif
!!$    if (present(OccultingDisc)) then
!!$       if (occultingDisc) then
!!$          if (distToDisc < distToGrid) then
!!$             i0 = tiny(i0)
!!$             goto 666
!!$          endif
!!$       endif
!!$    endif
!!$
!!$    if (distToGrid > 1.e29) then
!!$!              write(*,*) "ray does not intersect grid",position,direction
!!$       i0 = tiny(i0)
!!$       goto 666
!!$    endif
!!$
!!$    iUpper = thisAtom(iAtom)%iUpper(iTrans)
!!$    iLower = thisAtom(iAtom)%iLower(iTrans)
!!$
!!$    currentPosition = position + (distToGrid + 1.d-3*grid%halfSmallestSubcell) * direction
!!$ 
!!$ 
!!$
!!$    if (.not.inOctal(grid%octreeRoot, currentPosition)) then
!!$       write(*,*) "initial position not in grid"
!!$       write(*,*) "curre pos",currentPosition
!!$       write(*,*) "dir",direction
!!$       write(*,*) "pos",position
!!$       write(*,*) "modulsu",modulus(currentPosition - position)
!!$       stop
!!$    endif
!!$
!!$    totDist = 0.d0
!!$    call distanceToSource(source, nSource, currentposition, direction, hitSource, disttoSource, sourcenumber)
!!$
!!$    if ((.not.hitsource).and.justPhotosphere) goto 666
!!$    if (hitSource) then
!!$       pVec = (currentposition + (direction * distToSource) - source(sourceNumber)%position)
!!$       call normalize(pVec)
!!$       cosTheta = -1.d0*(pVec.dot.direction)
!!$       photoDirection = pVec
!!$       call normalize(photoDirection)
!!$    endif
!!$
!!$
!!$    !    write(*,*) "currentposition",sqrt(currentPosition%x**2+currentPosition%y**2),currentPosition%z, &
!!$    !         inOctal(grid%octreeRoot, currentPosition),distTogrid
!!$    i0 = tiny(i0)!0.d0
!!$    intensityIntegral = 0.0
!!$    tau = 0.d0
!!$    rayVel = VECTOR(0.d0, 0.d0, 0.d0)
!!$
!!$    thisOctal => grid%octreeRoot
!!$    icount = 0
!!$    rhoCol = 0.d0
!!$    endLoopAtPhotosphere = .false.
!!$
!!$    !    if (hitSource) endLoopAtphotosphere = .true.
!!$
!!$    !    write(*,*) lineoff,hitsource,endloopatphotosphere
!!$
!!$
!!$
!!$       do while(inOctal(grid%octreeRoot, currentPosition).and. &
!!$            (.not.endloopAtPhotosphere).and.(tau < 20.d0))
!!$          icount = icount + 1 
!!$          call findSubcellLocal(currentPosition, thisOctal, subcell)
!!$
!!$!          fac = 0.d0
!!$!          do i = 1,1000
!!$!             dv = (2.d0*dble(i-1)/999.d0-1.d0)* 0.01d0
!!$!             ddv = 0.02d0/1000.d0
!!$!             fac = fac + &
!!$!             phiProf2(dv, thisOctal, subcell, &
!!$!                  thisAtom(iatom)%transfreq(itrans), thisAtom(iatom))  * ddv
!!$!          enddo
!!$!          write(*,*) "prof test ",fac
!!$
!!$          !       rVec = subcellCentre(thisOctal,subcell)
!!$
!!$          call distanceToCellBoundary(grid, currentPosition, direction, tVal, sOctal=thisOctal)
!!$
!!$
!!$          if ((totDist + tval) > distTosource) then
!!$             tVal = distToSource - totDist
!!$             endLoopAtPhotosphere = .true.
!!$          endif
!!$
!!$          ntau = 4
!!$
!!$          if (.not.lineOff) then
!!$             startVel = amrGridVelocity(grid%octreeRoot, currentPosition, startOctal = thisOctal, actualSubcell = subcell) 
!!$
!!$             endPosition = currentPosition + tval * direction
!!$             endVel = amrGridVelocity(grid%octreeRoot, endPosition)
!!$
!!$             dv1 = deltaV + (startVel .dot. direction)
!!$             dv2 = deltaV + (endVel .dot. direction)
!!$
!!$             dvAcrossCell = abs((dv2-dv1) / thisOctal%microturb(subcell))
!!$
!!$
!!$             passThroughResonance =.false.
!!$             closeToResonance = .false.
!!$
!!$             if (dv1*dv2 <= 0.d0) passThroughResonance = .true.
!!$
!!$             closeToResonance = (min(abs(dv1),abs(dv2)) < 4.d0*thisOctal%microturb(subcell))
!!$!             if (modulus(endVel)==0.d0) passThroughResonance = .false.
!!$
!!$             if (passthroughresonance.or.closeToResonance) then
!!$                ntau = 20
!!$             endif
!!$          endif
!!$          bfOpac = 0.d0
!!$          bfEmiss = 0.d0
!!$
!!$          if (.not.thisOctal%inflow(subcell)) ntau = 2
!!$
!!$          ok = .false.
!!$          do while (.not.ok)
!!$             ok = .true.
!!$             tauStep = 0.d0
!!$             tautmp = tau
!!$             iStep = 0.d0
!!$             allocate(distArray(1:nTau))
!!$             do i = 1, ntau
!!$                distArray(i) = tval * dble(i-1)/dble(nTau-1)
!!$             enddo
!!$             do i = 2, nTau
!!$
!!$                startOctal => thisOctal
!!$                thisPosition = currentPosition + distArray(i)*direction
!!$                
!!$                if (.not.lineoff) then
!!$                   thisVel = amrGridVelocity(grid%octreeRoot, thisPosition, startOctal = startOctal, actualSubcell = subcell) 
!!$                   thisVel= thisVel - rayVel
!!$                   dv = (thisVel .dot. direction) + deltaV
!!$
!!$                   call returnEinsteinCoeffs(thisAtom(iAtom), iTrans, a, Bul, Blu)
!!$                   
!!$                   iUpper = thisAtom(iAtom)%iUpper(iTrans)
!!$                   iLower = thisAtom(iAtom)%iLower(iTrans)
!!$                   nLower = thisOctal%atomLevel(subcell,iAtom, iLower)
!!$                   nUpper = thisOctal%atomLevel(subcell,iAtom, iUpper)
!!$                   gLower = thisAtom(iatom)%g(iLower)
!!$                   gUpper = thisAtom(iatom)%g(iUpper)
!!$                   
!!$                   alphanu = ( (pi*eCharge**2) / (mElectron*cSpeed) ) * thisAtom(iatom)%fmatrix(iLower,iUpper)
!!$                   alphanu = alphanu * (nLower - ((gLower / gUpper) * nUpper) )  * &
!!$                        phiProf(dv, thisOctal, subcell, &
!!$                        thisAtom(iatom)%transfreq(itrans), thisAtom(iatom))/thisAtom(iatom)%transFreq(iTrans)
!!$                   
!!$                   if (nLower > 0.d0) then
!!$                      fac=(((nLower* gUpper) / (nUpper*gLower))-1.e0_db)
!!$                   else
!!$                      fac = 1.d30
!!$                   endif
!!$                   jnu = alphanu * (2.d0*hcgs*transitionfreq**3)/(cSpeed*cSpeed)/fac
!!$                   
!!$                else
!!$                   alphanu = 0.d0
!!$                endif
!!$                
!!$                
!!$                if (i == 2) then
!!$                   do k = 1, nAtom
!!$                      do j = 1, thisAtom(k)%nLevels - 1
!!$                         nStar(k,j) = BoltzSahaGeneral(thisAtom(k), j, thisOctal%ne(subcell), &
!!$                              dble(thisOctal%temperature(subcell))) * &
!!$                              Thisoctal%atomlevel(subcell, k,thisAtom(k)%nLevels)
!!$                      enddo
!!$                   enddo
!!$                   bfOpac = bfOpacity(transitionFreq, nAtom, thisAtom, thisOctal%atomLevel(subcell,:,:), &
!!$                        nstar, thisOctal%ne(subcell), dble(thisOctal%temperature(subcell)))
!!$                   bfEmiss = bfEmissivity(transitionFreq, nAtom, thisAtom,  thisOctal%atomLevel(subcell,:,:), nstar, &
!!$                        dble(thisOctal%temperature(subcell)), thisOctal%ne(subcell))
!!$                   dustOpac = 0.d0
!!$                   dustEmiss = 0.d0
!!$                   if (mie) then
!!$                      call returnKappa(grid, thisOctal, subcell, ilambda=ilambda, kappaSca=kappaSca, kappaAbs=kappaAbs)
!!$                      kappaExt = kappaAbs + kappaSca
!!$                      dustOpac = kappaExt/1.d10
!!$                      dustEmiss = kappaAbs * bnu(transitionFreq, dble(thisOctal%temperature(subcell)))/1.d10
!!$                      dustEmiss = dustEmiss + kappaSca * thisOctal%meanIntensity(subcell)/1.d10
!!$                   endif
!!$                endif
!!$                
!!$                
!!$                if (associated(thisOctal%fixedTemperature)) then
!!$                   if (.not.thisOctal%fixedTemperature(subcell)) then
!!$                      jnu = 0.d0
!!$                      etaline = 0.d0
!!$                   endif
!!$                endif
!!$                
!!$                if (thisOctal%rho(subcell) > 0.1d0) then ! opaque disc
!!$                   bfOpac = 1.d30
!!$                   bfEmiss = 0.d0
!!$                   alphanu = 1.d30
!!$                   etaLine = 0.d0
!!$                   jnu = 0.d0
!!$                   snu = 0.d0
!!$                   deallocate(distArray)
!!$                   goto 666
!!$                endif
!!$                
!!$                alphanu = alphanu + bfOpac + dustOpac
!!$                
!!$                ! add continuous bf and ff emissivity of hydrogen
!!$                
!!$                jnu = jnu !+ bfEmiss + dustEmiss
!!$                
!!$                if (alphanu /= 0.d0) then
!!$                   snu = jnu/alphanu                
!!$                else
!!$                   snu = tiny(snu)
!!$                endif
!!$                
!!$                
!!$                dTau = alphaNu *  (distArray(i)-distArray(i-1)) * 1.d10
!!$                
!!$                if ((dtau > 0.2d0).and.(tau < 20.d0)) then
!!$                   ntau = ntau * 2
!!$                   ok = .false.
!!$                   exit
!!$                endif
!!$                
!!$                
!!$                if (thisOctal%inflow(subcell)) then
!!$                   if (dtau > 0.1d0) then
!!$                      fac = (1.d0-exp(-dtau))
!!$                   else
!!$                      fac = (dtau - dtau**2/2.d0)
!!$                   endif
!!$                   
!!$                   
!!$                   
!!$                   istep = istep + jnu * exp(-tautmp) *  (distArray(i)-distArray(i-1)) * 1.d10
!!$                   tauStep = tauStep + dtau
!!$                   tautmp = tautmp + dtau
!!$                endif
!!$             enddo
!!$             deallocate(distArray)
!!$             if (ok) then
!!$                i0 = i0 + iStep
!!$                tau = tau + tauStep
!!$             endif
!!$
!!$          enddo
!!$
!!$          rhoCol = rhoCol + tval*thisOctal%rho(subcell)*1.d10
!!$          oldPosition = currentPosition
!!$          currentPosition = currentPosition + (tval+1.d-3*grid%halfSmallestSubcell) * direction
!!$          totdist = totdist + (tval+1.d-3*grid%halfSmallestSubcell)
!!$
!!$          if (PRESENT(occultingDisc)) then
!!$             if (occultingDisc) then
!!$                if  (oldPosition%z*currentPosition%z < 0.d0) then
!!$                   if (sqrt(currentPosition%x**2 + currentPosition%y**2) > holeRadius/1.d10) then
!!$                      goto 666
!!$                   endif
!!$                endif
!!$             endif
!!$          endif
!!$       enddo
!!$
!!$    if (endLoopAtPhotosphere) then
!!$
!!$       iElement = getElement(source(sourcenumber)%surface, photoDirection)
!!$       i0 = i0 + i_nu(source(sourceNumber), transitionFreq, iElement, cosTheta)*exp(-tau)
!!$    endif
!!$666 continue 
!!$
!!$  end function intensityAlongRay


  function intensityAlongRayGeneric(position, direction, grid,deltaV, source, nSource, thisAtom, itrans, &
      forceFreq, occultingDisc) result (i0)
    use inputs_mod, only : lineOff,  mie, lamLine, holeRadius, amr2d
    use amr_mod, only: distanceToGridFromOutside, returnKappa
    use utils_mod, only : findIlambda
    use atom_mod, only : bnu
    type(MODELATOM) :: thisAtom
    integer :: itrans
    logical ::     justPhotosphere
    type(VECTOR) :: position, direction, pvec, photoDirection
    type(GRIDTYPE) :: grid
    logical, optional :: occultingDisc
    integer :: nSource
    real(double), optional :: forceFreq
    type(SOURCETYPE) :: source(:)
    real(double) :: transitionFreq
    real(double) :: disttoGrid
    real(double) :: totDist
    logical :: hitSource
    real(double) :: i0
    type(OCTAL), pointer :: thisOctal, startOctal !, endOctal
    !    integer :: endSubcell
    integer :: subcell
    real(double) :: costheta
    type(VECTOR) :: currentPosition, thisPosition, thisVel, oldposition
    type(VECTOR) :: rayVel, startVel, endVel, endPosition !, rvec
    real(double) :: alphanu, snu, jnu, alphanuLine
    real(double) :: dv, deltaV
    integer :: i, icount
    real(double) :: tval
    real(double),allocatable :: distArray(:)
    integer :: nTau
    real(double) :: dTau, etaline, tau
    real(double) :: intensityIntegral
    real(double) :: dvAcrossCell
    real(double) :: dv1, dv2
    real(double) :: a, bul, blu
    real(double) :: distToSource,disttoDisc
    integer :: sourcenumber
    integer :: iElement
    logical :: endLoopAtPhotosphere
    real(double) ::  rhoCol
    real(double) :: bfOpac, bfEmiss
    real(double) :: dustOpac, dustEmiss
    integer :: ilambda, iomp
    real(double) :: transitionLambda, kappaSca, kappaAbs, kappaExt
    
    real(double) :: tauStep, tauTmp, iStep
    logical :: passThroughResonance, ok, closeToResonance, hitgrid
#ifdef _OPENMP
    integer :: omp_get_thread_num
#endif

       iomp = 0
#ifdef _OPENMP
       iomp = omp_get_thread_num()
#endif


    i0 = tiny(i0)
    justPhotosphere = .false.

    hitsource = .false.; disttosource = 0.d0; sourceNumber = 0
    a = 0.d0; blu = 0.d0; bul = 0.d0



    transitionLambda = lamLine 

    transitionFreq = cSpeed / (lamLine * angstromtocm)
    if (PRESENT(forceFreq)) then
       transitionFreq = forceFreq
       transitionLambda = (cspeed/transitionFreq)/angstromToCm
    endif



    ilambda = 1
    if (mie) iLambda = findIlambda(real(transitionLambda), grid%lamArray, grid%nLambda, ok)


    distToGrid = distanceToGridFromOutside(grid, position, direction, hitgrid=hitgrid)
    if (.not.hitgrid) then
       i0 = tiny(i0)
       goto 666
    endif


    currentposition = position
    distToDisc = 1.d30
    if ((currentposition.dot.direction) < 0.d0) then
       if (direction%z /= 0.d0) then
          distToDisc = abs(currentPosition%z/direction%z)
          oldPosition = currentPosition + distToDisc * direction
          if (sqrt(oldPosition%x**2 + oldPosition%y**2) < (2.d0*grid%octreeRoot%subcellSize)) then
             distToDisc = 1.d30
          endif
       else
          distToDisc = 1.d30
       endif
    endif
    if (present(OccultingDisc)) then
       if (occultingDisc) then
          if (distToDisc < distToGrid) then
             i0 = tiny(i0)
             write(*,*) "ray hit occulting disc"
             goto 666
          endif
       endif
    endif

    if (distToGrid > 1.e29) then
!              write(*,*) "ray does not intersect grid",position,direction
       i0 = tiny(i0)
       goto 666
    endif

    currentPosition = position + (distToGrid + 1.d-6*grid%halfSmallestSubcell) * direction
 
 

    if (.not.inOctal(grid%octreeRoot, currentPosition)) then
       write(*,*) "initial position not in grid"
       write(*,*) "curre pos",currentPosition
       if (amr2d) then
          write(*,*) "current position r ",sqrt(currentposition%x**2 + currentposition%y**2),&
               "current position z ",currentposition%z
       endif
       write(*,*) "dir",direction
       write(*,*) "pos",position
       write(*,*) "modulsu",modulus(currentPosition - position)
       stop
    endif

    totDist = 0.d0
    call distanceToSource(source, nSource, currentposition, direction, hitSource, disttoSource, sourcenumber)

    if ((.not.hitsource).and.justPhotosphere) goto 666
    if (hitSource) then
       pVec = (currentposition + (direction * distToSource) - source(sourceNumber)%position)
       call normalize(pVec)
       cosTheta = -1.d0*(pVec.dot.direction)
       photoDirection = pVec
       call normalize(photoDirection)
    endif


    !    write(*,*) "currentposition",sqrt(currentPosition%x**2+currentPosition%y**2),currentPosition%z, &
    !         inOctal(grid%octreeRoot, currentPosition),distTogrid
    i0 = tiny(i0)!0.d0
    intensityIntegral = 0.0
    tau = 0.d0
    rayVel = VECTOR(0.d0, 0.d0, 0.d0)

    thisOctal => grid%octreeRoot
    icount = 0
    rhoCol = 0.d0
    endLoopAtPhotosphere = .false.

    !    if (hitSource) endLoopAtphotosphere = .true.

    !    write(*,*) lineoff,hitsource,endloopatphotosphere


       do while(inOctal(grid%octreeRoot, currentPosition).and.(.not.endloopAtPhotosphere).and.(tau < 20.d0))
          icount = icount + 1 
          call findSubcellLocal(currentPosition, thisOctal, subcell)

          !       rVec = subcellCentre(thisOctal,subcell)

          call distanceToCellBoundary(grid, currentPosition, direction, tVal, sOctal=thisOctal)

          if ((totDist + tval) > distTosource) then
             tVal = distToSource - totDist
             endLoopAtPhotosphere = .true.
          endif

          if (thisOctal%blackBody(subcell)) then
             i0 = i0 + bnu(transitionFreq, dble(thisOctal%temperature(subcell))) * exp(-tau)
             tau = 1.d10
!             write(*,*) "hit blackbody ",i0
          else


          nTau = 2

          if (.not.lineOff) then
             startVel = amrGridVelocity(grid%octreeRoot, currentPosition, startOctal = thisOctal, actualSubcell = subcell, &
                  linearInterp=.false.) 

             endPosition = currentPosition + tval * direction
             endVel = amrGridVelocity(grid%octreeRoot, endPosition, &
                  linearInterp=.false.)

             dv1 = deltaV + (startVel .dot. direction)
             dv2 = deltaV + (endVel .dot. direction)

             dvAcrossCell = abs((dv2-dv1) / thisOctal%microturb(subcell))

             passThroughResonance =.false.
             closeToResonance = .false.

             if (dv1*dv2 < 0.d0) passThroughResonance = .true.

!             if (modulus(endVel)==0.d0) passThroughResonance = .false.

             if (passthroughresonance.or.(min(abs(dv1),abs(dv2)) < 10.d0*thisOctal%microturb(subcell))) then
                closeToResonance = .true.
             endif

             if (closeToResonance.or.passThroughResonance) nTau = 20

!             if (passThroughResonance) write(*,*) "ray passes through resonance ",dv1*cspeed/1.d5,dv2*cspeed/1.d5
!             if (closeToResonance) write(*,*) "close to resonance ",dv1*cspeed/1.d5,dv2*cspeed/1.d5

          endif
          bfOpac = 0.d0
          bfEmiss = 0.d0


       ok = .false.
       do while (.not.ok)
          ok = .true.
          tauStep = 0.d0
          tautmp = tau
          iStep = 0.d0
          if (allocated(distArray)) write(*,*) "Error: dist array already allocated"
          allocate(distArray(1:nTau))
          do i = 1, ntau
             distArray(i) = tval * dble(i-1)/dble(nTau-1)
          enddo
          do i = 2, nTau

             startOctal => thisOctal
             thisPosition = currentPosition + distArray(i)*direction




             if (.not.lineoff) then
                thisVel = amrGridVelocity(grid%octreeRoot, thisPosition, startOctal = startOctal, actualSubcell = subcell, &
                     linearInterp=.false.) 

                thisVel= thisVel - rayVel
                dv = (thisVel .dot. direction) + deltaV
                alphanu = thisOctal%chiLine(subcell) * phiProf(dv, thisOctal, subcell, &
                        thisAtom%transfreq(itrans), thisAtom)/transitionFreq
             else
                alphanu = 0.d0
             endif
             alphaNuLine = alphaNu

             if (i == 2) then
                bfOpac = thisOctal%kappaAbs(subcell,1)
                bfEmiss = thisOctal%etaCont(subcell)
                dustOpac = 0.d0
                dustEmiss = 0.d0
                if (mie) then
                   call returnKappa(grid, thisOctal, subcell, ilambda=ilambda, kappaSca=kappaSca, kappaAbs=kappaAbs)
                   kappaExt = kappaAbs + kappaSca
                   dustOpac = kappaExt
                   dustEmiss = kappaAbs * bnu(transitionFreq, dble(thisOctal%temperature(subcell)))
                   dustEmiss = dustEmiss + kappaSca * thisOctal%meanIntensity(subcell)
                endif
             endif



             if (.not.lineoff) then
                etaLine = thisOctal%etaLine(subcell)
                jnu = etaLine * phiProf(dv, thisOctal, subcell, &
                        thisAtom%transfreq(itrans), thisAtom)/transitionFreq
             else
                jnu = 0.d0
                etaline = 0.d0
             endif

!             if (associated(thisOctal%fixedTemperature)) then
!                if (.not.thisOctal%fixedTemperature(subcell)) then
!                   jnu = 0.d0
!                   etaline = 0.d0
!                endif
!             endif

             if (thisOctal%rho(subcell) > 0.1d0) then ! opaque disc
                bfOpac = 1.d30
                bfEmiss = 0.d0
                alphanu = 1.d30
                etaLine = 0.d0
                jnu = 0.d0
                snu = 0.d0
                deallocate(distArray)
                goto 666
             endif

             alphanu = alphanu + bfOpac + dustOpac

             ! add continuous bf and ff emissivity of hydrogen

             jnu = jnu + bfEmiss + dustEmiss

             if (alphanu /= 0.d0) then
                snu = jnu/alphanu
             else
                snu = tiny(snu)
             endif


             dTau = alphaNu *  (distArray(i)-distArray(i-1))

             if ((dtau > 0.1d0).and.(tau < 20.d0).and.(alphanu < 1.d29)) then
                ok = .false.
                ntau = ntau * 2
!                write(*,*) "ntau doubled to ",ntau,tau
                exit
             endif


             if (thisOctal%inflow(subcell)) then
   
                istep = istep + jnu * exp(-tautmp) *  (distArray(i)-distArray(i-1))
                tauStep = tauStep + dtau
                tautmp = tautmp + dtau

             endif
          enddo
             deallocate(distArray)
             if (ok) then
                i0 = i0 + iStep
                tau = tau + tauStep
!                if ((myrankGlobal==1).and.(iomp==0).and.(tau > 0.01d0))write(*,*) "i0, tau ",real(i0),real(tau),real(taustep)
             endif
             if ((.not. ok).and.(ntau > 100000)) then
                write(*,*) "ntau cap limit reached ",alphanu, " dust ",dustopac, &
                     " tau ",tau, " dtau ",dtau, " temp ",thisOctal%temperature(subcell)
                write(*,*) "line, continuum opac ",alphanuLine, bfOpac
                ok = .true.
             endif
          enddo
       endif


          rhoCol = rhoCol + tVal*thisOctal%rho(subcell)*1.d10
          oldPosition = currentPosition
          currentPosition = currentPosition + (tVal+1.d-3*grid%halfSmallestSubcell) * direction
          totdist = totdist + (tVal+1.d-3*grid%halfSmallestSubcell)

          if (PRESENT(occultingDisc)) then
             if (occultingDisc) then
                if  (oldPosition%z*currentPosition%z < 0.d0) then
                   if (sqrt(currentPosition%x**2 + currentPosition%y**2) > holeRadius/1.d10) goto 666
                endif
             endif
          endif
       enddo

    if (endLoopAtPhotosphere) then

       iElement = getElement(source(sourcenumber)%surface, photoDirection)

       i0 = i0 + i_nu(source(sourceNumber), transitionFreq, iElement, cosTheta)*exp(-tau)
    endif
666 continue 

  end function intensityAlongRayGeneric

  
  subroutine calculateAtomSpectrum(grid, thisAtom, nAtom, iAtom, iTrans, viewVec, distance, source, nsource, &
       totalFlux, prefix, forceLambda, occultingDisc)
    use inputs_mod, only : vturb, lineoff, nv, calcDataCube, lamLine, cmf, calcPhotometry, calcSpectrum
    use inputs_mod, only : minvel, maxvel
    use source_mod, only : globalSourceArray
    use messages_mod, only : myRankIsZero
    use datacube_mod, only: DATACUBE, freedatacube
    use modelatom_mod, only : identifyTransitionCmf
    use datacube_mod, only : dumpCubeToSpectrum, dumpCubeToVisibilityCurves, writeSpectroastrometry
#ifdef USECFITSIO
    use datacube_mod, only : writedataCube
#endif
#ifdef MPI
    use mpi
#endif
    logical, optional :: occultingDisc
    character(len=*) :: prefix
    type(GRIDTYPE) :: grid
    type(MODELATOM) :: thisAtom(:)
    integer :: nSource
    real(double), optional :: forceLambda
    type(SOURCETYPE) :: source(:)
    integer :: nAtom, iAtom
    real(double) :: distance, totalFlux
    integer :: itrans
    integer :: nRay,iray1,iray2
    integer, parameter :: maxRay  = 1000000
    type(VECTOR),allocatable :: rayPosition(:)
    real(double),allocatable :: da(:), dOmega(:)
    type(VECTOR) :: viewVec
    real(double) :: deltaV
    integer :: iv, iray
    real(double) :: i0
    real(double), allocatable :: vArray(:), spec(:)
    integer :: iv1, iv2, i
    character(len=80) :: plotfile,message
    type(DATACUBE) :: cube
    integer :: nFreqArray
    real(double) :: totalOmega
    integer, parameter :: maxFreq = 2000
    real(double) :: freqArray(maxFreq), broadBandFreq, transitionFreq
    logical :: doCube, doSpec
    logical :: storeLineoff
#ifdef USECFITSIO
    character(len=80) :: tempFilename
#endif

#ifdef MPI
    ! For MPI implementations
    integer       ::   my_rank        ! my processor rank
    integer       ::   np             ! The number of processes
    integer       ::   ierr           ! error flag
    real(double), allocatable :: tempArray(:)



    ! FOR MPI IMPLEMENTATION=======================================================
    !  Get my process rank # 
    call MPI_COMM_RANK(MPI_COMM_WORLD, my_rank, ierr)
  
    ! Find the total # of precessor being used in this run
    call MPI_COMM_SIZE(MPI_COMM_WORLD, np, ierr)
#endif

    storeLineOff = lineOff

    iAtom = 1
    iTrans = 1
    if (cmf.and.(.not.calcPhotometry)) then
       call identifyTransitionCmf(dble(lamLine), thisAtom, iAtom, iTrans)
       transitionFreq = thisAtom(iAtom)%transfreq(iTrans)
!       open(45,file="chiline.dat",form="formatted",status="unknown")
       call calcChiLine(grid%octreeRoot, thisAtom, nAtom, iAtom, iTrans)
!       close(45)
!       open(45,file="etaline.dat",form="formatted",status="unknown")
       call calcEtaLine(grid%octreeRoot, thisAtom, nAtom, iAtom, iTrans)
!       close(45)
       call calcContinuumOpacities(grid%octreeRoot, thisAtom, nAtom, transitionfreq)
       call removeInnerEtaChi(grid%octreeRoot, source(1)%radius*1.1)
    endif

    call setMicroturb(grid%octreeRoot, dble(vTurb))
    call writeVTKfile(grid,"eta_cmf.vtk", valueTypeString = (/"etaline    ","chiline    ",&
         "sourceline ",  &
         "ne         ", "jnu        ","haschild   ", &
         "inflow     ","temperature", "velocity   ", &
         "cornervel  ","level2     ", "level3     ", &
         "blackbody  "/))


    doCube = calcDataCube
    doSpec = calcSpectrum

    broadBandFreq = 1.d15
    if (PRESENT(forceLambda)) then
       broadBandFreq = cSpeed/(forceLambda * angstromToCm)
       write(message,'(a,f7.1)') "Calculating flux at ",forceLambda
       call writeInfo(message)
       lineoff = .true.
       nv = 1
    endif

    if (lineoff) call writeWarning("Line transfer switched off")

    cube%label = " "
    freqArray = 0.d0; nFreqArray = 0
    call createContFreqArray(nFreqArray, freqArray, nAtom, thisAtom, nsource, source)


    if (myRankIsZero.and.(.not.PRESENT(forcelambda))) &
         write(*,*) "Calculating spectrum for: ",lamLine

    
    if (doCube) then
#ifdef USECFITSIO
       call createDataCube(cube, grid, viewVec, nSource, source, thisAtom(iAtom), iTrans)
       
#ifdef MPI
       write(*,*) "Process ",my_rank, " create data cube done"
#endif
       if (myrankiszero) then
          write(tempFilename,'(a,a)') trim(prefix),".fits"
          call writeDataCube(cube,tempfilename)
          write(tempFilename,'(a,a)') trim(prefix),".dat"
          call dumpCubeToSpectrum(cube, tempFilename)

          write(tempFilename,'(a,a)') trim(prefix),"_spectroastrometry.dat"
          call writeSpectroastrometry(cube, tempFilename)

       endif
!       write(tempFilename,'(a,i3.3)') "vis",nFile
! Import gridDistance from inputs_mod if this line needs to be reinstated. 
!       call dumpCubeToVisibilityCurves(cube, tempFilename, cspeed/transitionFreq, gridDistance)
       call torus_mpi_barrier
       call freeDataCube(cube)
#else
       call writeWarning("No data cubes written. Torus was build without FITS support")
#endif
    endif

    if (.not.doSpec) goto 666

#ifdef MPI
  call randomNumberGenerator(syncIseed=.true.)
#endif
  allocate(da(1:maxray), domega(1:maxRay),  rayPosition(1:maxray))
    da = 0.d0; dOmega = 0.d0
    nray = 0; rayPosition = VECTOR(0.d0, 0.d0, 0.d0)

    call createRayGrid(nRay, rayPosition, da, dOmega, viewVec, distance, grid)


    iv1 = 1
    iv2 = nv
 

    allocate(spec(1:nv), vArray(1:nv))
    spec = 0.d0
    if (PRESENT(forceLambda)) then
       varray(1) = 0.d0
    else
       if (nv == 1) then
          varray(1) = 0.d0
       else
          do iv = 1, nv
             vArray(iv) = (minvel + (maxvel-minvel)*dble(iv-1)/dble(nv-1))*1.d5/cspeed
          enddo
       endif
    endif


    do iv = iv1, iv2
!       write(*,*) iv,varray(iv)*cspeed/1.d5
       deltaV  = vArray(iv)

       iray1 = 1
       iray2 = nray
#ifdef MPI
    iray1 = (my_rank) * (nray / (np)) + 1
    iray2 = (my_rank+1) * (nray / (np))
    if (my_rank == (np-1)) iv2 = nray
#endif
    totalOmega = 0.d0
!$OMP PARALLEL DEFAULT (NONE) &
!$OMP PRIVATE (iray, i0) &
!$OMP SHARED (iray1, iray2, iv, occultingDisc, rayposition, viewvec, grid, thisAtom, nAtom, iatom) &
!$OMP SHARED ( itrans, deltaV, source, nsource) &
!$OMP SHARED (nFreqArray, freqArray, broadbandFreq, spec, domega, totalOmega, calcPhotometry) 
!$OMP DO SCHEDULE(DYNAMIC)
       do iRay = iray1, iray2
          if (PRESENT(occultingDisc)) then
             if (calcPhotometry) then
!                i0 = intensityAlongRay(rayposition(iRay), viewvec, grid, thisAtom, nAtom, iAtom, iTrans, -deltaV, source, nSource, &
!                     nFreqArray, freqArray, occultingDisc=.true., forceFreq=broadBandFreq)

                i0 = intensityAlongRayGeneric(rayposition(iray), viewVec, grid, -deltaV, source, nSource, thisAtom(iatom), itrans, &
                     forceFreq=broadBandFreq, occultingDisc=.true.)

             else
!                i0 = intensityAlongRay(rayposition(iRay), viewvec, grid, thisAtom, nAtom, iAtom, iTrans, -deltaV, source, nSource, &
!                     nFreqArray, freqArray, occultingDisc=.true.)

                i0 = intensityAlongRayGeneric(rayposition(iray), viewVec, grid, -deltaV, source, nSource, thisAtom(iAtom), itrans, &
                      occultingDisc=.true.)

             endif
          else
!             i0 = intensityAlongRay(rayposition(iRay), viewvec, grid, thisAtom, nAtom, iAtom, iTrans, -deltaV, source, nSource, &
!                  nFreqArray, freqArray)

                i0 = intensityAlongRayGeneric(rayposition(iray), viewVec, grid, -deltaV, source, nSource, thisAtom(iatom), itrans, &
                      occultingDisc=.false.)

          endif
!$OMP CRITICAL
          spec(iv) = spec(iv) + i0 * domega(iRay) 
          totalOmega = totalOmega + domega(iray)
!$OMP END CRITICAL
       enddo
!$OMP END DO
!$OMP BARRIER
!$OMP END PARALLEL

    enddo

#ifdef MPI
     call MPI_BARRIER(MPI_COMM_WORLD, ierr) 
     allocate(tempArray(1:nv))
     call MPI_ALLREDUCE(spec,tempArray,nv,MPI_DOUBLE_PRECISION,&
          MPI_SUM,MPI_COMM_WORLD,ierr)
     spec(1:nv) = tempArray(1:nv)
     deallocate(tempArray)

     allocate(tempArray(1:1))
     call MPI_ALLREDUCE(totalOmega,tempArray,1,MPI_DOUBLE_PRECISION,&
          MPI_SUM,MPI_COMM_WORLD,ierr)
     totalOmega=temparray(1)
     deallocate(tempArray)
     

#endif
     if (myrankiszero) then
!        write(*,*) "Solid angle check: ", totalOmega, pi* globalSourceArray(1)%radius**2/(distance/1.d10)**2
     endif

    if (myRankIsZero) then
       write(plotfile,'(a,a)') trim(prefix),"_from_rays.dat"
       open(42, file=plotfile,status="unknown",form="formatted")
       do i = 1, nv
          transitionFreq = thisAtom(iAtom)%transFreq(iTrans)
          write(42, *) vArray(i)*cspeed/1.d5, spec(i)/spec(1), &
               spec(i)*(distance/1.d10)**2/(globalSourceArray(1)%radius**2)
       enddo
       close(42)
    endif
    totalFlux = toPerAngstrom(spec(1), broadBandFreq)
    deallocate(vArray, spec)
    deallocate(da, domega, rayPosition)

    lineOff = storeLineOff
666 continue
  end subroutine calculateAtomSpectrum


  subroutine createRayGrid(nRay, rayPosition, da, dOmega, viewVec, distance, grid)
    use inputs_mod, only : ttauriwind, ttauriRouter, ttauriStellarwind, SW_rMin, SW_Rmax
    use source_mod, only : globalSourceArray
    use utils_mod
    type(GRIDTYPE) :: grid
    integer :: nRay
    type(VECTOR) :: rayPosition(:), viewVec, xProj,yProj
    real(double) :: da(:), dOmega(:), distance
    real(double), allocatable :: rGrid(:), dr(:), phigrid(:), dphi(:)
    real(double) :: rMax, rMin
    integer :: nr, nphi, ir, iphi
    real(double) :: r1 , r2, phi1, phi2, phiOffset
    real(double) :: xPos, yPos, zPos
    integer :: nr1, nr2, nr3, nr4,  i

    nr1 = 200
    nr2 = 100
    nr3 = 100
    nr4 = 100
    if (.not.(ttauriWind)) nr3 = 0
    if (.not.(ttauriStellarWind)) nr4 = 0

    nr = nr1 + nr2 + nr3 + nr4
    nphi = 200
    nray = 0
    i = 0

    allocate(rGrid(1:nr), dr(1:nr), phiGrid(1:nPhi), dphi(1:nPhi))
    rmin = 0.d0
    rMax = globalSourceArray(1)%radius 

    do ir = 1, nr1
       r1 = rMin + (rmax-rMin) * (dble(ir-1)/dble(nr1))
       r2 = rMin + (rmax-rMin) * (dble(ir)/dble(nr1))
       i = i + 1
       rgrid(i) = 0.5d0 * (r1 + r2)
       dr(i) = r2 - r1
!       write(*,*) 1.d10*rGrid(i)/(20.d0*rSol)
    enddo
    
    if (nr2 > 0) then
       rmin = globalSourceArray(1)%radius 
       rMax = max(rMin*10.d0,ttaurirOuter/1.d10)
    

       do ir = 1, nr2
          r1 = rMin + (rmax-rMin) * (dble(ir-1)/dble(nr2))**3
          r2 = rMin + (rmax-rMin) * (dble(ir)/dble(nr2))**3
          i = i + 1
          rgrid(i) = 0.5d0 * (r1 + r2)
          dr(i) = r2 - r1
          !       write(*,*) 1.d10*rGrid(i)/(20.d0*rSol)
       enddo
    endif


    if (nr3 > 0) then
       rmin = ttauriRouter/1.d10 
       rMax = grid%octreeRoot%subcellsize*2.d0
       do ir = 1, nr3
          r1 = rMin + (rmax-rMin) * (dble(ir-1)/dble(nr3))**3
          r2 = rMin + (rmax-rMin) * (dble(ir)/dble(nr3))**3
          i = i + 1
          rgrid(i) = 0.5d0 * (r1 + r2)
          dr(i) = r2 - r1
          !       write(*,*) 1.d10*rGrid(i)/(20.d0*rSol)
       enddo
    endif



    if (nr4 > 0) then
       rmin = SW_Rmin
       rMax = SW_rmax
       do ir = 1, nr4
          r1 = rMin + (rmax-rMin) * (dble(ir-1)/dble(nr4))**3
          r2 = rMin + (rmax-rMin) * (dble(ir)/dble(nr4))**3
          i = i + 1
          rgrid(i) = 0.5d0 * (r1 + r2)
          dr(i) = r2 - r1
          !       write(*,*) 1.d10*rGrid(i)/(20.d0*rSol)
       enddo
    endif


    call sort(nr, rgrid)
       
       do iphi = 1, nPhi
          phi1 = twoPi * dble(iphi-1)/dble(nPhi)
          phi2 = twoPi * dble(iphi)/dble(nPhi)
          phiGrid(iPhi) = 0.5d0 * (phi1 + phi2)
          dphi(iPhi) = phi2 - phi1
       enddo

       if(writeoutput) open(66,file="points_spec_from_rays.dat",status="unknown",form="formatted")
    do ir = 1, nr
       r1 = rGrid(ir)

       call randomNumberGenerator(getDouble=phiOffset)
       phiOffset = phiOffset * dphi(1)
       do iPhi = 1, nPhi
          phi1 = phiGrid(iPhi) + phiOffset
          if (phi1 > twoPi) phi1 = phi1 - twoPi

          xPos = r1 * sin(phi1)
          yPos = 0.d0
          zPos = r1 * cos(phi1)

          if (writeoutput) then
             write(66,*) xpos,zpos
          endif

          xProj =  VECTOR(0.d0, 0.d0, 1.d0)  .cross. viewVec
          call normalize(xProj)
          yProj = viewVec .cross. xProj
         call normalize(yProj)

          nRay = nRay + 1
         rayPosition(nray) =  (xPos * xProj) + (zPos * yProj)
         rayposition(nray) = rayPosition(nRay) + ((-1.d0*grid%octreeRoot%subcellSize*10.d0) * viewVec)

          da(nRay) = pi*( (r1 + dr(ir)/2.d0)**2 - (r1 - dr(ir)/2.d0)**2) * dphi(iPhi)/twoPi
          dOmega(nRay) = da(nRay) / (distance/1.d10)**2
       enddo
    enddo
    if (writeoutput) close(66)
  end subroutine createRayGrid


  subroutine createDataCube(cube, grid, viewVec,nSource, source, thisAtom, itrans)
    use mpi_global_mod
    use inputs_mod, only : nv, imageSide, maxVel, griddistance
    use datacube_mod, only: DATACUBE, initCube, addspatialaxes, addvelocityAxis, cubePositionAngle
#ifdef MPI
    use mpi
#endif
#ifdef _OPENMP
    integer :: omp_get_thread_num
#endif
    integer :: nSource
    type(SOURCETYPE) :: source(:)
    type(GRIDTYPE) :: grid
    type(DATACUBE) :: cube
    type(VECTOR) :: viewvec, rayPos, xProj, yProj, northVec
    type(MODELATOM) :: thisAtom
    integer :: itrans
    real(double) :: deltaV
    integer :: ix, iy, iv
    real(double) :: vstart,vend
    real(double), allocatable :: vArray(:)
    integer ::  i
    integer :: nMonte
    integer :: iv1, iv2
    integer :: nPoints
    real(double), pointer :: xPoints(:), yPoints(:)
    real(double) :: dx, dy
    integer :: nRay
    integer, parameter :: maxRay = 100000
    real(double) :: xRay(maxray), yRay(maxray)
    real(double) :: area(maxray)
    real(double) :: totArea, tmp
    integer :: iRay
    integer :: iomp
    logical :: doingCalc
    ! For MPI implementations
    integer       ::   my_rank        ! my processor rank
    real(double) :: thisIntensity
#ifdef MPI
    integer :: j
    integer       ::   np             ! The number of processes
    integer       ::   ierr           ! error flag
    integer       ::   n
    integer       ::   tag, tag2, tag3
    integer       :: iThread, status(MPI_STATUS_SIZE)

    real(double), allocatable :: tempArray(:)

    ! FOR MPI IMPLEMENTATION=======================================================
    !  Get my process rank # 
    status = 0
    call MPI_COMM_RANK(MPI_COMM_WORLD, my_rank, ierr)

    ! Find the total # of precessor being used in this run
    call MPI_COMM_SIZE(MPI_COMM_WORLD, np, ierr)
    tag = 77
    tag2 = 88
    tag3 = 99
#else
! Set rank to zero for non-MPI cases
    my_rank = 0
#endif

    nMonte = 1

    vStart = -maxVel
    vEnd = maxVel

    iv1 = 1
    iv2 = nv


    doingCalc = .true.
#ifdef MPI
    if (nv < np) then
       iv1 = my_rank+1
       iv2 = my_rank+1
       if ((my_rank+1) > nv) then
          doingCalc = .false.
       endif
    else
       iv1 = int(real(my_rank) * (real(nv) / real(np))) + 1
       iv2 = int(real(my_rank+1) * (real(nv) / real(np)))
       if (my_rank == (np-1)) iv2 = nv
    endif
#endif

    if (doingCalc) then
    if (myRankGlobal == 0) then
       call initCube(cube, nv)
    else
       call initCube(cube, iv2-iv1+1)
    endif
    allocate(vArray(1:nv))
    if (nv > 1) then
       do i = 1, nv
          vArray(i) = vStart + (vEnd-vStart)*dble(i-1)/dble(nv-1)
       enddo
    else
       vArray(1) = 0.d0
    endif


    call addSpatialAxes(cube, -dble(imageSide/2.), dble(imageSide/2.), griddistance)


    if (myRankGlobal == 0) then
       call addVelocityAxis(cube, vStart, vEnd)
    else
       call addvelocityAxis(cube, vArray(iv1), vArray(iv2))
    endif

    northVec = VECTOR(0.d0, 0.d0, 1.d0)
    northVec = rotateY(northVec, dble(cubePositionAngle))

    xProj =   viewVec .cross. northVec
    call normalize(xProj)
    yProj =  xProj .cross.viewVec
    call normalize(yProj)


    dx = cube%xAxis(2)-cube%xAxis(1)
    dy = cube%yAxis(2)-cube%yAxis(1)
#ifdef MPI
  call randomNumberGenerator(syncIseed=.true.)
#endif
    call createRayGridGeneric(cube, source, xPoints, yPoints, nPoints, xProj, yProj)
    if (writeoutput) then
       open(22, file="points.dat",status="unknown",form="formatted")
       do i = 1, nPoints
          write(22,*) xPoints(i), yPoints(i)
       enddo
       close(22)
    endif
    do iv = iv1, iv2
       deltaV = cube%vAxis(iv-iv1+1)*1.d5/cSpeed
    
       do ix = 1, cube%nx


       !$OMP PARALLEL DEFAULT (NONE) &
       !$OMP PRIVATE (iomp, iy, nRay, xRay, yRay, area, iRay, rayPos, tmp, thisIntensity, totArea) &
       !$OMP SHARED (cube, viewVec, grid, ix,  xPoints, yPoints, nPoints) &
       !$OMP SHARED (deltaV, source, nSource, myrankGlobal) &
       !$OMP SHARED (iv, iv1, xproj, yproj, nMonte, dx, dy, thisAtom, itrans)
       
       write(*,*) "in parallel sec"
       iomp = 0
       write(*,*) iomp
#ifdef _OPENMP
       iomp = omp_get_thread_num()
#endif

       write(*,*) "found iomp ",iomp

       !$OMP DO SCHEDULE(DYNAMIC,1)
          do iy = 1, cube%ny
             write(*,*) myrankglobal, iomp," doing ray ",iv,ix,iy

             call findRaysInPixel(cube%xAxis(ix),cube%yAxis(iy),dx,dy, xpoints, ypoints, &
                  nPoints,  nRay, xRay, yRay, area)

             write(*,*) "find rays done"
             thisIntensity = 0.
             totArea = 0.
             do iRay = 1, nRay
                write(*,*) "iray ",iray
                rayPos =  (xRay(iRay) * xProj) + (yRay(iRay) * yProj)
                raypos = rayPos + ((-1.d0*grid%octreeRoot%subcellsize*30.d0) * Viewvec)
                tmp = intensityAlongRayGeneric(rayPos, viewVec, grid,  &
                        -deltaV, source, nSource, thisAtom, iTrans, occultingDisc=.true.)
                thisIntensity =  thisIntensity + real(tmp * area(iRay))
                totArea = totArea + Area(iray)
             enddo

             thisIntensity = thisIntensity / real(SUM(area(1:nray)))
             cube%intensity(ix,iy,iv-iv1+1) = real(thisIntensity)

             
          enddo
          !$OMP END DO

          !$OMP BARRIER
          !$OMP END PARALLEL


       enddo
       write(*,*) "Velocity bin ",iv, " done."

    enddo
    deallocate(xPoints, yPoints)

 endif

#ifdef MPI
 write(*,*) "Rank ",my_rank, " waiting at barrier"
    call MPI_BARRIER(MPI_COMM_WORLD, ierr) 


    n = (cube%nx * cube%ny)

    do iThread = 1, min(nv-1,nThreadsGlobal-1)
       if (my_rank == iThread) then
          call MPI_SEND(iv2-iv1+1, 1, MPI_INTEGER, 0, tag, MPI_COMM_WORLD,  ierr)
          do iv = 1, nv                
             if ((iv >= iv1).and.(iv <= iv2)) then
                allocate(tempArray(1:n))
                tempArray = reshape(cube%intensity(:,:,iv-iv1+1), (/  n /))
                call MPI_SEND(iv, 1, MPI_INTEGER, 0, tag2, MPI_COMM_WORLD,  ierr)
                call MPI_SEND(tempArray, n, MPI_DOUBLE_PRECISION, 0, tag3, MPI_COMM_WORLD,  ierr)
                deallocate(tempArray)
             endif
          enddo
       endif
       if (my_rank == 0) then
          call MPI_RECV(j, 1, MPI_INTEGER, iThread, tag, MPI_COMM_WORLD, status, ierr)
          do i = 1, j
             call MPI_RECV(iv, 1, MPI_INTEGER, iThread, tag2, MPI_COMM_WORLD, status, ierr)
             allocate(tempArray(1:n))
             tempArray = reshape(cube%intensity(:,:,iv-iv1+1), (/  n /))
             call MPI_RECV(tempArray, n, MPI_DOUBLE_PRECISION, iThread, tag3, MPI_COMM_WORLD, status, ierr)
             cube%intensity(:, :, iv) = real(reshape(tempArray, (/ cube%nx, cube%ny /)))
             deallocate(tempArray)
          enddo
       endif
       call torus_mpi_barrier
    enddo



    write(*,*) "Process ",my_rank, " reduce done."
#endif

  end subroutine createDataCube


  subroutine findRaysInPixel(xcen, yCen, dx, dy, xPoints, yPoints, nPoints, &
                  nRay, xRay, yRay, area)
    use utils_mod, only : voron2
    
    logical :: ok
    real(double) :: xCen, yCen, dx, dy
    real(double) :: xPoints(:), yPoints(:)
    integer :: nPoints
    integer :: nRay, i
    real(double) :: xRay(:), yRay(:)
    real(double) :: area(:)
    real(double) , allocatable:: xTmp(:), yTmp(:)


    nRay = 0

    do i = 1, nPoints
       if ((abs(xCen-xPoints(i)) < dx/2.d0).and. &
            (abs(yCen-yPoints(i)) < dy/2.d0)) then
          nRay = nRay + 1
          xRay(nRay) = xPoints(i)
          yRay(nRay) = yPoints(i)
          if (nRay == SIZE(xRay)) then
             write(*,*) "max array sized reached for nray"
             stop
          endif
       endif
    enddo

    if (nRay == 1) then
       area(1) = dx*dy
    else if (nRay == 2) then
       area(1:2) = 0.5*dx*dy
    else if (nRay == 3) then
       area(1:3) = 0.33333*dx*dy
    else
       call removeIdenticalPoints(nRay, xRay, yRay)
       if (allocated(xtmp)) then
          write(*,*) "Error xtmp already allocated"
       endif
       allocate(xtmp(1:nray),ytmp(1:nRay))
       xtmp(1:nRay) = xRay(1:nray) - (xcen-dx/2.d0)
       ytmp(1:nray) = yRay(1:nRay) - (yCen-dy/2.d0)
       if (nRay <= 10000) then
          call voron2(nRay, xTmp, yTmp, dx, area(1:nRay), ok)
       else
          ok = .false.
       endif
       if (.not.ok) then
          area(1:nRay) = dx*dy/dble(nray)
       endif
       deallocate(xTmp, yTmp)
    endif
  end subroutine findRaysInPixel
          
          


#ifdef MPI
      subroutine packAtomLevel(octalArray, nTemps, tArray, iAtom, iLevel, doneByThisThread)

        type(OCTALWRAPPER) :: octalArray(:)
        integer :: nTemps
        real(double) :: tArray(:)
        integer :: iOctal, iSubcell, iAtom
        integer :: iLevel
        type(OCTAL), pointer :: thisOctal
        logical :: doneByThisThread(:)

       !
       ! Update the edens values of grid computed by all processors.
       !
       nTemps = 0
       do iOctal = 1, SIZE(octalArray)

          thisOctal => octalArray(iOctal)%content

          
          do iSubcell = 1, thisOctal%maxChildren
              if (.not.thisOctal%hasChild(iSubcell)) then
                 nTemps = nTemps + 1
                 if (doneByThisThread(iOctal)) then
                   tArray(nTemps) = thisOctal%newAtomLevel(isubcell, iAtom, iLevel)
                 else 
                   tArray(nTemps) = 0.d0
                 endif
              endif
          end do
       end do
     end subroutine packAtomLevel

      subroutine unpackAtomLevel(octalArray, nTemps, tArray, iAtom, iLevel)

        type(OCTALWRAPPER) :: octalArray(:)
        integer :: nTemps
        real(double) :: tArray(:)
        integer :: iOctal, iSubcell, iAtom
        integer :: iLevel
        type(OCTAL), pointer :: thisOctal

       !
       ! Update the edens values of grid computed by all processors.
       !
       nTemps = 0
       do iOctal = 1, SIZE(octalArray)

          thisOctal => octalArray(iOctal)%content
          
          do iSubcell = 1, thisOctal%maxChildren
              if (.not.thisOctal%hasChild(iSubcell)) then
                 nTemps = nTemps + 1
                 thisOctal%newAtomLevel(isubcell, iAtom, iLevel) = tArray(nTemps) 
              endif
          end do
       end do
     end subroutine unpackAtomLevel

      subroutine packjnu(octalArray, nTemps, tArray, iFreq, doneByThisThread)

        type(OCTALWRAPPER) :: octalArray(:)
        integer :: nTemps
        real(double) :: tArray(:)
        integer :: iOctal, iSubcell, iFreq
        type(OCTAL), pointer :: thisOctal
        logical :: doneByThisThread(:)
       !
       ! Update the edens values of grid computed by all processors.
       !
       nTemps = 0
       do iOctal = 1, SIZE(octalArray)

          thisOctal => octalArray(iOctal)%content
          
          do iSubcell = 1, thisOctal%maxChildren
              if (.not.thisOctal%hasChild(iSubcell)) then
                 nTemps = nTemps + 1
                 if (doneByThisThread(iOctal)) then
                   tArray(nTemps) = thisOctal%jnuCont(isubcell, ifreq)
                 else 
                   tArray(nTemps) = 0.d0
                 endif
              endif
          end do
       end do
     end subroutine packJnu

      subroutine packbiasline3d(octalArray, nTemps, tArray, doneByThisThread)

        type(OCTALWRAPPER) :: octalArray(:)
        integer :: nTemps
        real(double) :: tArray(:)
        integer :: iOctal, iSubcell
        type(OCTAL), pointer :: thisOctal
        logical :: doneByThisThread(:)

       !
       ! Update the edens values of grid computed by all processors.
       !
       nTemps = 0
       do iOctal = 1, SIZE(octalArray)

          thisOctal => octalArray(iOctal)%content
          
          do iSubcell = 1, thisOctal%maxChildren
              if (.not.thisOctal%hasChild(iSubcell)) then
                 nTemps = nTemps + 1
                 if (DoneByThisThread(iOctal)) then
                   tArray(nTemps) = thisOctal%biasLine3d(isubcell)
                 else 
                   tArray(nTemps) = 0.d0
                 endif
              endif
          end do
       end do
     end subroutine packbiasline3d

      subroutine unpackJnu(octalArray, nTemps, tArray, iFreq)

        type(OCTALWRAPPER) :: octalArray(:)
        integer :: nTemps
        real(double) :: tArray(:)
        integer :: iOctal, iSubcell, iFreq
        type(OCTAL), pointer :: thisOctal

       !
       ! Update the edens values of grid computed by all processors.
       !
       nTemps = 0
       do iOctal = 1, SIZE(octalArray)

          thisOctal => octalArray(iOctal)%content
          
          do iSubcell = 1, thisOctal%maxChildren
              if (.not.thisOctal%hasChild(iSubcell)) then
                 nTemps = nTemps + 1
                 thisOctal%jnuCont(isubcell, iFreq) = tArray(nTemps) 
              endif
          end do
       end do
     end subroutine unpackJnu

      subroutine unpackbiasLine3d(octalArray, nTemps, tArray)

        type(OCTALWRAPPER) :: octalArray(:)
        integer :: nTemps
        real(double) :: tArray(:)
        integer :: iOctal, iSubcell
        type(OCTAL), pointer :: thisOctal

       !
       ! Update the edens values of grid computed by all processors.
       !
       nTemps = 0
       do iOctal = 1, SIZE(octalArray)

          thisOctal => octalArray(iOctal)%content
          
          do iSubcell = 1, thisOctal%maxChildren
              if (.not.thisOctal%hasChild(iSubcell)) then
                 nTemps = nTemps + 1
                 thisOctal%biasLine3d(isubcell) = tArray(nTemps) 
              endif
          end do
       end do
     end subroutine unpackBiasLine3d
#endif

  recursive  subroutine  setMicroturb(thisOctal, microTurb)
    type(octal), pointer   :: thisOctal
    type(octal), pointer  :: child 
    integer :: subcell, i
    real(double) :: microTurb
  
    do subcell = 1, thisOctal%maxChildren
       if (thisOctal%hasChild(subcell)) then
          ! find the child
          do i = 1, thisOctal%nChildren, 1
             if (thisOctal%indexChild(i) == subcell) then
                child => thisOctal%child(i)
                call setMicroturb(child, microTurb)
                exit
             end if
          end do
       else
          thisOctal%microTurb(subcell) = microturb
       endif
    enddo
  end subroutine setMicroturb


!!$  subroutine testRays(grid, nSource, source)
!!$    type(GRIDTYPE) :: grid
!!$    integer :: nSource
!!$    type(SOURCETYPE) :: source(:)
!!$    type(OCTAL), pointer :: thisOctal
!!$    integer :: subcell
!!$    real(double) :: weight
!!$    type(VECTOR) :: position, direction, pvec, photoDirection
!!$    integer :: sourceNumber, i, j, nray, iElement
!!$    real(double) :: i0, distTosource, cosTheta, freq
!!$    logical :: hitSource
!!$    
!!$    freq  = cSpeed / (6562.8d0 * 1.d-8)
!!$    position = VECTOR(0.d0 , 0.d0 , source(1)%radius*5.d0)
!!$
!!$    thisOctal => grid%octreeRoot
!!$    call findSubcellLocal(position, thisOctal, subcell)
!!$
!!$    do i = 1, 10
!!$       nray = 100 * 2**(i-1)
!!$       i0 = 0.d0
!!$       do j = 1, nray
!!$          call randomRayDirection(0.8d0, position, source, nSource, direction, weight)
!!$          
!!$          call distanceToSource(source, nSource, position, direction, hitSource, disttoSource, sourcenumber)
!!$          if (hitSource) then
!!$             pVec = (position + (direction * distToSource) - source(sourceNumber)%position)
!!$             call normalize(pVec)
!!$             cosTheta = -1.d0*(pVec.dot.direction)
!!$             photoDirection = pVec
!!$             call normalize(photoDirection)
!!$             iElement = getElement(source(sourcenumber)%surface, photoDirection)
!!$             i0 = i0 + i_nu(source(sourceNumber), freq, iElement,costheta)*weight
!!$          endif
!!$       enddo
!!$       write(*,*) "nray ",nray, "j_nu ",i0/dble(nray)
!!$    enddo
!!$  end subroutine testRays


  subroutine createRayGridGeneric(cube, SourceArray, xPoints, yPoints, nPoints, xProj, yProj)
    use inputs_mod, only :  ttaurirouter, amrgridsize, ttauriStellarWind, SW_Rmin, SW_rmax, &
         ttauriWind
    use inputs_mod,only : nr1,nr2,nr3,nr4,nphi1,nphi2,nphi3,nphi4, ttauriMagnetosphere
    use source_mod, only : globalnSource
    use amr_mod, only : countVoxels
    use datacube_mod, only : datacube
    type(SOURCETYPE) :: sourceArray(:)
    type(DATACUBE) :: cube
    type(VECTOR) :: xProj, yProj, rVec
    integer :: nPoints, i, j
    real(double), pointer :: xPoints(:), yPoints(:)
    real(double) :: r, phi, dphi, dx, dy, rMin, rMax, r1, r2, dxOffset, dyOffset
    integer :: ix, iy, iSource
    logical :: enhanced
    enhanced = .true.

    nPoints = (nr1*nphi1 + nr2*nphi2 + nr3*nphi3 + nr4*nphi4) +  2*globalnSource * nr1 * nphi1
    nPoints = nPoints + 4*cube%nx*cube%ny

    allocate(xPoints(1:nPoints),yPoints(1:nPoints))
    npoints = 0

    do iSource = 1, globalnSource
       do i = 1, nr1
          r = (dble(i)/dble(nr1)) * sourceArray(iSource)%radius
          call randomNumberGenerator(getDouble=dphi)
          dphi = dphi * twoPi
          do j = 1, nphi1
             phi = twoPi * dble(j-1)/dble(nPhi1)+dphi
             rVec = VECTOR(r*cos(phi),r*sin(phi),0.d0)
             nPoints = nPoints + 1
             xPoints(nPoints) = (sourceArray(isource)%position.dot.xproj) + r * cos (phi)
             yPoints(nPoints) = (sourceArray(isource)%position.dot.yproj) + r * sin (phi)
          enddo
       enddo

       rMin = sourceArray(iSource)%radius
       rMax = rMin * 20.d0
       do i = 1, nr1
          r1 = rMin + (rMax-rMin) * (dble(i-1)/dble(nr1))**3
          r2 = rMin + (rMax-rMin) * (dble(i)/dble(nr1))**3
          r = 0.5d0*(r1+r2)
          call randomNumberGenerator(getDouble=dphi)
          dphi = dphi * twoPi
          do j = 1, nphi1
             phi = twoPi * dble(j-1)/dble(nPhi1)+dphi
             rVec = VECTOR(r*cos(phi),r*sin(phi),0.d0)
             nPoints = nPoints + 1
             xPoints(nPoints) = (sourceArray(isource)%position.dot.xproj) + r * cos (phi)
             yPoints(nPoints) = (sourceArray(isource)%position.dot.yproj) + r * sin (phi)
          enddo
       enddo

    enddo

    if (ttauriMagnetosphere) then
       rmin = sourceArray(1)%radius 
       rMax = ttauriRouter/1.d10

       do i = 1, nr2
          r1 = rMin + (rMax-rMin) * (dble(i-1)/dble(nr2))**3
          r2 = rMin + (rMax-rMin) * (dble(i)/dble(nr2))**3
          r = 0.5d0*(r1+r2)
          call randomNumberGenerator(getDouble=dphi)
          dphi = dphi * twoPi
          do j = 1, nphi2
             phi = twoPi * dble(j-1)/dble(nPhi2)+dphi
             rVec = VECTOR(r*cos(phi),r*sin(phi),0.d0)
             nPoints = nPoints + 1
!             xPoints(nPoints) = (sourceArray(isource)%position + rVec).dot.xproj
!             yPoints(nPoints) = (sourceArray(isource)%position + rVec).dot.yproj


             xPoints(nPoints) = sourceArray(isource)%position%x + rVec%x
             yPoints(nPoints) = sourceArray(isource)%position%y + rVec%y
          enddo
       enddo
    endif
    if (ttauriWind) then
       rmin = ttaurirOuter/1.d10 !dw_rmin
       rMax = amrGridSize
       do i = 1, nr3
          r1 = rMin + (rMax-rMin) * (dble(i-1)/dble(nr3))**3
          r2 = rMin + (rMax-rMin) * (dble(i)/dble(nr3))**3
          r = 0.5d0*(r1+r2)
          call randomNumberGenerator(getDouble=dphi)
          dphi = dphi * twoPi
          do j = 1, nphi3
             phi = twoPi * dble(j-1)/dble(nPhi3)+dphi
             rVec = VECTOR(r*cos(phi),r*sin(phi),0.d0)
             nPoints = nPoints + 1
!             xPoints(nPoints) = (sourceArray(isource)%position + rVec).dot.xproj
!             yPoints(nPoints) = (sourceArray(isource)%position + rVec).dot.yproj
             xPoints(nPoints) = sourceArray(isource)%position%x + rVec%x
             yPoints(nPoints) = sourceArray(isource)%position%y + rVec%y
          enddo
       enddo
    endif


    if (ttauriStellarwind) then
       rmin = SW_rMin
       rMax = SW_rMax
       do i = 1, nr4
          r1 = rMin + (rMax-rMin) * (dble(i-1)/dble(nr4))**3
          r2 = rMin + (rMax-rMin) * (dble(i)/dble(nr4))**3
          r = 0.5d0*(r1+r2)
          call randomNumberGenerator(getDouble=dphi)
          dphi = dphi * twoPi
          do j = 1, nphi4
             phi = twoPi * dble(j-1)/dble(nPhi4)+dphi
             rVec = VECTOR(r*cos(phi),r*sin(phi),0.d0)
             nPoints = nPoints + 1
!             xPoints(nPoints) = (sourceArray(isource)%position + rVec).dot.xproj
!             yPoints(nPoints) = (sourceArray(isource)%position + rVec).dot.yproj
             xPoints(nPoints) = sourceArray(isource)%position%x + rVec%x
             yPoints(nPoints) = sourceArray(isource)%position%y + rVec%y
         enddo
       enddo
    endif

    dx = cube%xAxis(2) - cube%xAxis(1)
    dy = cube%yAxis(2) - cube%yAxis(1)
    do ix = 1, cube%nx
       do iy = 1, cube%ny

          call randomNumberGenerator(getDouble=dxOffset)
          call randomNumberGenerator(getDouble=dyOffset)
          dxOffset = (2.d0*dxOffset-1.d0) * dx/8.d0
          dyOffset = (2.d0*dyOffset-1.d0) * dy/8.d0

          nPoints = nPoints + 1
          xPoints(nPoints) = cube%xAxis(ix) - dx / 4.d0 + dxOffset
          yPoints(nPoints) = cube%yAxis(iy) - dy / 4.d0 + dyOffset


          call randomNumberGenerator(getDouble=dxOffset)
          call randomNumberGenerator(getDouble=dyOffset)
          dxOffset = (2.d0*dxOffset-1.d0) * dx/8.d0
          dyOffset = (2.d0*dyOffset-1.d0) * dy/8.d0

          nPoints = nPoints + 1
          xPoints(nPoints) = cube%xAxis(ix) + dx / 4.d0 + dxOffset
          yPoints(nPoints) = cube%yAxis(iy) + dy / 4.d0 + dyOffset

          call randomNumberGenerator(getDouble=dxOffset)
          call randomNumberGenerator(getDouble=dyOffset)
          dxOffset = (2.d0*dxOffset-1.d0) * dx/8.d0
          dyOffset = (2.d0*dyOffset-1.d0) * dy/8.d0

          nPoints = nPoints + 1
          xPoints(nPoints) = cube%xAxis(ix) - dx / 4.d0 + dxOffset
          yPoints(nPoints) = cube%yAxis(iy) + dy / 4.d0 + dyOffset

          call randomNumberGenerator(getDouble=dxOffset)
          call randomNumberGenerator(getDouble=dyOffset)
          dxOffset = (2.d0*dxOffset-1.d0) * dx/8.d0
          dyOffset = (2.d0*dyOffset-1.d0) * dy/8.d0

          nPoints = nPoints + 1
          xPoints(nPoints) = cube%xAxis(ix) + dx / 4.d0 + dxOffset
          yPoints(nPoints) = cube%yAxis(iy) - dy / 4.d0 + dyOffset

       enddo
    enddo
    if (writeoutput) then
       open(23,file="rays.dat", status="unknown",form="formatted")
       do ix = 1, nPoints
          write(23,*) xPoints(ix),yPoints(ix)
       enddo
       close(23)
    endif

  end subroutine createRayGridGeneric

  subroutine removeIdenticalPoints(n, x, y)
    integer :: n
    real(double) :: x(:), y(:)
    real(double), allocatable :: xt(:), yt(:), d(:)
    integer :: nt, i, j
    real(double) :: d1, eps

    eps = 1.d-6

    allocate(d(1:n))
    d = 1.d30
    do i = 1, n
       do j = 1, n
          if (i /= j) then
             d1 =  sqrt((x(i)-x(j))**2 + (y(i)-y(j))**2)
             d(i) = min(d1, d(i))
          endif
       enddo
    enddo
    nt = 0
    do i = 1, n
       if (d(i) > eps) then
          nt = nt + 1
       endif
    enddo
    allocate(xt(n), yt(n))

    xt(1:n) = x(1:n)
    yt(1:n) = y(1:n)
    nt = 0
    do i = 1, n
       if (d(i) > eps) then
          nt = nt + 1
          x(nt) = xt(i)
          y(nt) = yt(i)
       endif
    enddo
    deallocate(xt,yt,d)
    n = nt
  end subroutine removeIdenticalPoints

!!$  subroutine getProjectedPoints(grid, xProj, yProj, xPoints, yPoints, nPoints, count)
!!$    type(GRIDTYPE) :: grid
!!$    integer :: nPoints
!!$    type(VECTOR) :: xProj, yProj
!!$    real(double), pointer :: xPoints(:), yPoints(:)
!!$    logical, optional :: count
!!$
!!$
!!$    call getProjectedPointsRecursive(grid, grid%octreeRoot,  xProj, yProj, xPoints, yPoints, nPoints, count)
!!$
!!$  end subroutine getProjectedPoints
!!$
!!$  recursive  subroutine  getProjectedPointsRecursive(grid, thisOctal,  xProj, yProj, xPoints, yPoints, nPoints, count)
!!$    use inputs_mod, only : smallestCellSize
!!$    type(octal), pointer   :: thisOctal
!!$    type(GRIDTYPE) :: grid
!!$    type(octal), pointer  :: child 
!!$    logical, optional :: count
!!$    integer :: subcell, i,j
!!$    integer :: nPoints
!!$    type(VECTOR) :: xProj, yProj, rVec
!!$    real(double) :: xPoints(:), yPoints(:), phi, dphi
!!$    logical :: addPoint
!!$    logical :: converged
!!$  
!!$    addPoint = .true.
!!$    if (PRESENT(count)) then
!!$       addPoint = .not.count
!!$    endif
!!$
!!$
!!$    do subcell = 1, thisOctal%maxChildren
!!$       if (thisOctal%hasChild(subcell)) then
!!$          ! find the child
!!$          do i = 1, thisOctal%nChildren, 1
!!$             if (thisOctal%indexChild(i) == subcell) then
!!$                child => thisOctal%child(i)
!!$                call getProjectedPointsRecursive(grid, child,  xProj, yProj, xPoints, yPoints, nPoints, count)
!!$                exit
!!$             end if
!!$          end do
!!$       else
!!$          if (thisOctal%inflow(subcell)) then
!!$             call randomNumberGenerator(getDouble=dphi)
!!$             dphi = dphi * twoPi
!!$             if (thisOctal%threeD) then
!!$                nPoints = nPoints + 1
!!$                if (addPoint) then
!!$                   rVec = subcellCentre(thisOctal, subcell)
!!$                   xPoints(nPoints) = xProj.dot.rVec
!!$                   yPoints(nPoints) = yProj.dot.rVec
!!$                endif
!!$             else if (thisOctal%twoD) then
!!$                do j = 1, 50
!!$                   phi = dble(j-1)/49.d0 * twoPi + dphi
!!$                   rVec =  subcellCentre(thisOctal, subcell)
!!$                   rVec = rotateZ(rVec, phi)
!!$                   nPoints = nPoints + 1
!!$                   if (addPoint) then
!!$                      xPoints(nPoints) = xProj.dot.rVec
!!$                      yPoints(nPoints) = yProj.dot.rVec
!!$                   endif
!!$                enddo
!!$             else if (thisOctal%oneD) then
!!$                do j = 1, 50
!!$                   phi = dble(j)/50.d0 * twoPi + dphi
!!$                   rVec =  subcellCentre(thisOctal, subcell)
!!$                   rVec = rotateZ(rVec, phi)
!!$                   nPoints = nPoints + 1
!!$                   if (addPoint) then
!!$                      xPoints(nPoints) = rVec%x
!!$                      yPoints(nPoints) = rVec%y
!!$                   endif
!!$                enddo
!!$             endif
!!$             if (addpoint) then
!!$                converged = .false.
!!$                do while(.not.converged)
!!$                   converged = .true.
!!$                   do i = 1, nPoints-1
!!$                      if (sqrt( (xpoints(nPoints)-xPoints(i))**2 +&
!!$                           (ypoints(nPoints)-yPoints(i))**2) < smallestCellSize) then
!!$                         nPoints = nPoints - 1
!!$                         converged = .false.
!!$                         exit
!!$                      endif
!!$                   enddo
!!$                enddo
!!$             endif
!!$
!!$          endif
!!$       endif
!!$    enddo
!!$  end subroutine getProjectedPointsRecursive



  recursive subroutine testSobolevJnuLine(grid, thisOctal, iatom, itrans, thisAtom, source, &
       inu_times_betacmn, betamn, sobJnuLine)

    use amr_mod, only : amrgridDirectionalDeriv
    type(GRIDTYPE) :: grid
    type(OCTAL), pointer :: thisOctal, child
    integer :: subcell
    real(double) :: inu_times_betacmn, betamn, sobJnuLine
    type(MODELATOM) :: thisAtom(:)
    integer :: iAtom
    type(SOURCETYPE) :: source
    integer :: iTrans
    integer :: i


    do subcell = 1, thisOctal%maxChildren
       if (thisOctal%hasChild(subcell)) then
          ! find the child
          do i = 1, thisOctal%nChildren, 1
             if (thisOctal%indexChild(i) == subcell) then
                child => thisOctal%child(i)
                call testSobolevJnuLine(grid, child, iatom, itrans, thisAtom, source, &
       inu_times_betacmn, betamn, sobJnuLine)
                exit
             end if
          end do
       else
          if (.not.associated(thisOctal%rhou)) then
             allocate(thisOctal%rhou(1:thisOctal%maxChildren))
             thisOctal%rhou = 0.d0
          endif
          if (.not.associated(thisOctal%rhov))  then
             allocate(thisOctal%rhov(1:thisOctal%maxChildren))
             thisOctal%rhov = 0.d0
          endif
          if (thisOctal%inflow(subcell)) then
             call getSobolevJnuLine(grid, thisOctal, subcell, iatom, itrans, thisAtom, source, &
                  inu_times_betacmn, betamn, sobJnuLine)
          endif
       endif
    enddo
  end subroutine testSobolevJnuLine



  subroutine getSobolevJnuLine(grid, thisOctal, subcell, iatom, itrans, thisAtom, source, &
       inu_times_betacmn, betamn, sobJnuLine)
    use source_mod, only : globalSourceArray, globalnSource
    use amr_mod, only : amrgridDirectionalDeriv
    type(GRIDTYPE) :: grid
    type(OCTAL), pointer :: thisOctal
    integer :: subcell
    real(double) :: inu_times_betacmn
    type(MODELATOM) :: thisAtom(:)
    integer :: iAtom
    type(SOURCETYPE) :: source
    integer :: iTrans
    integer :: iUpper, iLower
    real(double) :: nUpper, nLower, gUpper, gLower
    real(double) :: transitionFreq, inu, chiline, a, blu, bul
    real(double) :: betamn,  grad, tauij, theta, fij
    real(double) :: sobJnuLine, dphi, phi, escProb
    integer :: i, j
    integer :: ntheta, nphi
    real(double) :: thetaToStar, phiToStar, tauAv, sphericalCapAngle
    type(VECTOR) :: uHat, position, toStar, photoDirection,  norm, direction
    real(double) :: dotprod, betacmn, disttostar, domega, dtheta, r, sinang
    real(double) :: totomega
    logical :: hitSource
    integer :: sourcenumber
    integer :: iElement
    nTheta = 10

    iUpper = thisAtom(iAtom)%iUpper(iTrans)
    iLower = thisAtom(iAtom)%iLower(iTrans)

    nLower = thisOctal%newatomLevel(subcell,iAtom, iLower)
    nUpper = thisOctal%newatomLevel(subcell,iAtom, iUpper)

    gLower = thisAtom(iAtom)%g(iLower)
    gUpper = thisAtom(iAtom)%g(iUpper)

    transitionFreq = thisAtom(iAtom)%transFreq(iTrans)


    call returnEinsteinCoeffs(thisAtom(iatom), iTrans, a, Bul, Blu)

    fij = thisAtom(iatom)%fMatrix(ilower,iupper)


    chiline = (pi * eCharge**2 * fij)/(mElectron * cSpeed)
    chiLine = chiLine *  gLower * (Nlower/gLower - nUpper/gUpper)
 
    betamn = 0.d0

    position = subcellCentre(thisoctal,subcell)

    totomega = 0.d0
    tauAv = 0.d0
    dtheta = pi / real(ntheta)
    do i = 1, ntheta
       theta = dtheta/2.d0 + dtheta*dble(i-1)
       nphi = max(2,nint(real(ntheta)*sin(theta)))
       dphi = twopi / real(nphi)
       do j = 1, nphi
          phi = dphi/2.d0 + dphi*dble(j-1)
          uHat = vector(sin(theta)*cos(phi),sin(theta)*sin(phi),cos(theta))
          domega = sin(theta)*dtheta*dphi
          totomega = totomega + domega
          grad =  abs(amrGridDirectionalDeriv(grid, position, uHat, startOctal=thisOctal)/1.d10)
          tauij = chiLine / grad 
          tauij =  tauij / transitionFreq
          tauij = max(1.d-20,tauij)
          if (tauij < 0.1d0) then
             escProb = 1.0-tauij*0.5*(1.0 - tauij/3.0*(1. - tauij*0.25*(1.0 - 0.20*tauij)))
          else if (tauij < 15.d0) then
             escProb = (1.0-exp(-tauij))/tauij
          else
             escProb = 1.d0/tauij
          end if
          

          tauav = tauav + dOmega*tauij
          betamn = betamn + domega*escProb
       enddo
    enddo
    betamn = betamn / totomega
    tauAv = tauAv /totOmega

    thisOctal%rhou(subcell) = tauAv


    tostar = source%position - position
    disttostar = modulus(tostar)
    tostar = tostar / dble(disttostar)

    sinAng = source%radius/distToStar
    sphericalCapAngle = asin(min(1.d0,max(-1.d0,sinAng)))

    call getPolar(toStar, r, thetaTostar, phiToStar)

    betacmn = 0.d0
    totomega = 0.d0
    inu_times_betacmn = 0.d0
    ntheta = 20
    nphi = 20

    dTheta = sphericalCapAngle/dble(nTheta)
    dPhi = twoPi / dble(nPhi)
    do i = 1, ntheta
       theta = dTheta/2.d0 + dble(i-1)*dTheta
       do j = 1, nphi
          phi = dPhi/2.d0 + dble(j-1)*dPhi
          direction = toStar
          norm = direction.cross.randomUnitVector()
          call normalize(norm)
          direction = arbitraryRotate(direction, theta, norm)
          call normalize(direction)
          direction =  arbitraryRotate(direction, phi, toStar)
          call normalize(direction)
          domega = sin(theta)*dtheta*dphi
          dotprod = direction .dot. tostar
          call distanceToSource(globalSourceArray, globalnSource, position, direction, hitSource, distToStar, sourcenumber)
          if (.not.hitsource) write(*,*) "bug in betacmn"
          photoDirection = (position + distToStar*direction) - source%position
          call normalize(photoDirection)
          iElement = getElement(source%surface, photoDirection)
          inu = i_nu(source, transitionFreq, iElement, 1.d0)
          grad =  abs(amrGridDirectionalDeriv(grid, position, direction, startOctal=thisOctal)/1.d10)
          tauij = chiLine / grad 
          tauij =  tauij / transitionFreq
          tauij = max(1.d-20,tauij)


             
          if (tauij < 0.1d0) then
             escProb = 1.0-tauij*0.5*(1.0 - tauij/3.0*(1. - tauij*0.25*(1.0 - 0.20*tauij)))
          else if (tauij < 15.d0) then
             escProb = (1.0-exp(-tauij))/tauij
          else
             escProb = 1.d0/tauij
          end if
          betacmn = betacmn + escprob * domega
          inu_times_betacmn = inu_times_betacmn + inu * escprob * domega
          totOmega = totOmega + dOmega
       enddo
    enddo


    betacmn = betacmn / fourPi


    thisOctal%rhov(subcell) = betacmn

    inu_times_betacmn = inu_times_betacmn / fourPi

    if ((ilower==2).and.(iUpper==4)) thisOctal%biasline3d(subcell) = inu_times_betacmn

    sobJnuLine = (1.d0 - betamn) * &
         ((2.d0*hcgs*transitionFreq**3)/cSpeed**2)*((gupper*nLower)/(glower*nUpper) - 1.d0)**(-1.d0) + inu_times_betacmn

!    if ((thisAtom(iatom)%name == "HeII").and.(ilower==1).and.(iupper==2)) write(*,*) "tausob ",tauav
!    if ((thisAtom(iatom)%name == "HeII").and.(ilower==1).and.(iupper==2)) write(*,*) "jnu sob (line, cont)", &
!         ((2.d0*hcgs*transitionFreq**3)/cSpeed**2)*((gupper*nLower)/(glower*nUpper) - 1.d0)**(-1.d0),betacmn * inu

  end subroutine getSobolevJnuLine

! Commented out so daily test builds (DMA 8/2/11)
!  subroutine getSurfacePoints(source, viewVec, xProj, yProj, xPoints, yPoints, nPoints)
!    type(SOURCETYPE) :: source
!    type(VECTOR) :: viewVec, xProj, yProj
!    real(double) :: xPoints(:), yPoints(:)
!    integer :: nPoints
!
!  end subroutine getSurfacePoints

  RECURSIVE SUBROUTINE getOctalArrayLocal(thisOctal,array,counter, docountOnly) 
    ! returns an array of pointers to all of the subcells in the grid.
    ! NB because fortran cannot create arrays of pointers, the output
    !   array is actually of a derived type which *contains* the 
    !   pointer to an octal.
    ! counter should be set to 0 before this routine is called

    IMPLICIT NONE

    TYPE(octal), POINTER                            :: thisOctal
    TYPE(octalWrapper), DIMENSION(:), INTENT(INOUT) :: array 
    INTEGER, INTENT(INOUT)                          :: counter 
    logical :: docountOnly
    INTEGER              :: i
    TYPE(octal), POINTER :: child


    ! if this is the root of the tree, we initialize the counter
    IF (.NOT. ASSOCIATED(thisOctal%parent)) counter = 0
    
    counter = counter + 1 
    if (.not.doCountOnly) then
       array(counter)%content => thisOctal
       !array(counter)%inUse = .TRUE. 
       array(counter)%inUse = .NOT. thisOctal%hasChild 
    endif


    
    IF ( thisOctal%nChildren > 0 ) THEN
      DO i = 1, thisOctal%nChildren, 1
        
        ! call this subroutine recursively on each of its children
        child => thisOctal%child(i)
        CALL getOctalArrayLocal(child,array,counter, docountOnly)
        
      END DO
    END IF

  END SUBROUTINE getOctalArrayLocal



end module cmf_mod
#endif
